const Aw=Object.create;const QS=Object.defineProperty;const gw=Object.getOwnPropertyDescriptor;const Rw=Object.getOwnPropertyNames;
const Nw=Object.getPrototypeOf;
const yw=Object.prototype.hasOwnProperty;
const Ow=(e,t,n,r)=>{if (t&&typeof t=="object"||typeof t=="function") {
  for (let o of Rw(t)) {
    if (!yw.call(e,o)&&o!==n) {
      QS(e,o,{get:() => t[o],enumerable:!(r=gw(t,o))||r.enumerable});
    }
  }
}return e};const Fl=(e, t, n) => {
  n=e!=null?Aw(Nw(e)):{};
  return Ow(t||!e||!e.__esModule?QS(n,"default",{value:e,enumerable:true}):n,e);
};
const Ku=require("node:worker_threads");
const hc=require("path");
const jo=require("node:os");
const ce=require("node:path");
const zu=require("events");
const Kp=require("child_process");
const de=require("node:fs");
const tc=require("node:crypto");
const Tc=require("node:child_process");
const Un=require("node:buffer");
const bw=require("path/posix");
const JS=require("node:string_decoder");
const qo=require("node:util");
const Cw=require("node:net");
require("crypto");
const VC=require("node:fs/promises");
const Iw=require("perf_hooks");
const Xr=require("util");
const Zu=require("url");
const xC=require("module");
const $C=require("tty");
const Pw=require("os");
const np=require("worker_threads");
const Mw=require("fs");
const Sn=require("node:diagnostics_channel");
const vw=require("node:events");
const BC=require("diagnostics_channel");
const HC=require("async_hooks");
const Lw=require("node:readline");
const ww=require("node:http");
const Dw=require("node:https");
const Uw=require("node:stream");
const kw=require("node:zlib");
const Gw=require("node:tls");
const Yl=typeof document !== "undefined"?document.currentScript:null;function ln(e){
  const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(e){for (const n in e) {
    if(n!=="default"){const r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:true,get:() => e[n]})}
  }}
  t.default=e;
  return Object.freeze(t);
}
const qr=ln(hc);
const wt=ln(jo);
const FC=ln(ce);
const Vw=ln(qo);
const No=ln(Cw);
const xw=ln(xC);
const ou=ln(Sn);
const jl=ln(BC);
const su=ln(ww);
const $w=ln(Dw);
const em=ln(Gw);
const rp=typeof globalThis !== "undefined"?globalThis:typeof window !== "undefined"?window:typeof global !== "undefined"?global:typeof self !== "undefined"?self:{};function zp(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function YC(e){
  if (Object.prototype.hasOwnProperty.call(e,"__esModule")) {
    return e;
  }const t=e.default;if (typeof t=="function")
    {var n=function r(...args) {let o=false;try{o=this instanceof r}catch{}return o?Reflect.construct(t,args,this.constructor):t.apply(this,args);};n.prototype=t.prototype} else {
    n={};
  }
  Object.defineProperty(n,"__esModule",{value:true});
  Object.keys(e).forEach(r => {const o=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(n,r,o.get?o:{enumerable:true,get() {return e[r]}})});
  return n;
}
const ql={};
const dr={};
const Ni={};
const yi={};
const Cn={};
const fr={};
const _r={};
const Oi={};
let tm;
function Bw(){
  if (!tm) {
    tm=1;
    Object.defineProperty(Oi,"__esModule",{value:true});
    Oi._globalThis=void 0;
    Oi._globalThis=typeof globalThis=="object"?globalThis:rp;
  }

  return Oi;
}let nm;function Hw(){
  if (!nm) {
    nm=1;

    (e => {
      const t=_r&&_r.__createBinding||(Object.create?((r, o, s, i = s) => {
        Object.defineProperty(r,i,{enumerable:true,get() {return o[s]}});
      }):((r, o, s, i = s) => {
        r[i]=o[s];
      }));

      const n=_r&&_r.__exportStar||((r, o) => {for (const s in r) {
        if (s!=="default"&&!Object.prototype.hasOwnProperty.call(o,s)) {
          t(o,r,s);
        }
      }});

      Object.defineProperty(e,"__esModule",{value:true});
      n(Bw(),e);
    })(_r);
  }

  return _r;
}let rm;function Fw(){
  if (!rm) {
    rm=1;

    (e => {
      const t=fr&&fr.__createBinding||(Object.create?((r, o, s, i = s) => {
        Object.defineProperty(r,i,{enumerable:true,get() {return o[s]}});
      }):((r, o, s, i = s) => {
        r[i]=o[s];
      }));

      const n=fr&&fr.__exportStar||((r, o) => {for (const s in r) {
        if (s!=="default"&&!Object.prototype.hasOwnProperty.call(o,s)) {
          t(o,r,s);
        }
      }});

      Object.defineProperty(e,"__esModule",{value:true});
      n(Hw(),e);
    })(fr);
  }

  return fr;
}
const bi={};
let om;
function jC(){
  if (!om) {
    om=1;
    Object.defineProperty(bi,"__esModule",{value:true});
    bi.VERSION=void 0;
    bi.VERSION="1.9.0";
  }

  return bi;
}
const pr={};
let sm;
function Yw(){
  if (sm) {
    return pr;
  }
  sm=1;
  Object.defineProperty(pr,"__esModule",{value:true});
  pr.isCompatible = void 0;
  pr._makeCompatibilityCheck = void 0;
  const e=jC();
  const t=/^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
  function n(r){
    const o=new Set([r]);
    const s=new Set;
    const i=r.match(t);
    if (!i) {
      return () => false;
    }const a={major:+i[1],minor:+i[2],patch:+i[3],prerelease:i[4]};if (a.prerelease!=null) {
      return d => d===r;
    }function c(f){
      s.add(f);
      return false;
    }function l(f){
      o.add(f);
      return true;
    }return d => {
    if (o.has(d)) {
        return true;
      }if (s.has(d)) {
        return false;
      }const u=d.match(t);if (!u) {
        return c(d);
      }const _={major:+u[1],minor:+u[2],patch:+u[3],prerelease:u[4]};

    if (_.prerelease!=null||a.major!==_.major) {
      return c(d);
    }

    if (a.major===0) {
      if (a.minor===_.minor&&a.patch<=_.patch) {
        return l(d);
      }

      return c(d);
    }

    if (a.minor<=_.minor) {
      return l(d);
    }

    return c(d);
  };
  }
  pr._makeCompatibilityCheck=n;
  pr.isCompatible=n(e.VERSION);
  return pr;
}let im;function Wo(){
  if (im) {
    return Cn;
  }
  im=1;
  Object.defineProperty(Cn,"__esModule",{value:true});
  Cn.unregisterGlobal = void 0;
  Cn.getGlobal = void 0;
  Cn.registerGlobal = void 0;
  const e=Fw();
  const t=jC();
  const n=Yw();
  const r=t.VERSION.split(".")[0];
  const o=Symbol.for(`opentelemetry.js.api.${r}`);
  const s=e._globalThis;
  function i(l,f,d,u=false){
    const p=s[o]=s[o] ?? {version:t.VERSION};if(!u&&p[l]){
        const E=new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${l}`);
        d.error(E.stack||E.message);
        return false;
      }if(p.version!==t.VERSION){
        const E=new Error(`@opentelemetry/api: Registration of version v${p.version} for ${l} does not match previously registered API v${t.VERSION}`);
        d.error(E.stack||E.message);
        return false;
      }
    p[l]=f;
    d.debug(`@opentelemetry/api: Registered a global for ${l} v${t.VERSION}.`);
    return true;
  }Cn.registerGlobal=i;function a(l){
    let f;
    let d;
    const u=(f=s[o])===null||f===void 0?void 0:f.version;if (!(!u||!(0,n.isCompatible)(u))) {
      return(d=s[o])===null||d===void 0?void 0:d[l]
    }
  }Cn.getGlobal=a;function c(l,f){
  f.debug(`@opentelemetry/api: Unregistering a global for ${l} v${t.VERSION}.`);const d=s[o];

  if (d) {
    delete d[l];
  }
}
  Cn.unregisterGlobal=c;
  return Cn;
}let am;function jw(){
  if (am) {
    return yi;
  }
  am=1;
  Object.defineProperty(yi,"__esModule",{value:true});
  yi.DiagComponentLogger=void 0;
  const e=Wo();class t{constructor(o){this._namespace=o.namespace||"DiagComponentLogger"}debug(...o){return n("debug",this._namespace,o)}error(...o){return n("error",this._namespace,o)}info(...o){return n("info",this._namespace,o)}warn(...o){return n("warn",this._namespace,o)}verbose(...o){return n("verbose",this._namespace,o)}}yi.DiagComponentLogger=t;function n(r,o,s){const i=(0,e.getGlobal)("diag");if (i) {
    s.unshift(o);
    return i[r](...s);
  }}return yi
}
const Ci={};
const Wl={};
let cm;
function Zp(){
  if (!cm) {
    cm=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.DiagLogLevel=void 0;

      (t => {
        t[t.NONE=0]="NONE";
        t[t.ERROR=30]="ERROR";
        t[t.WARN=50]="WARN";
        t[t.INFO=60]="INFO";
        t[t.DEBUG=70]="DEBUG";
        t[t.VERBOSE=80]="VERBOSE";
        t[t.ALL=9999]="ALL";
      })(e.DiagLogLevel||(e.DiagLogLevel={}));
    })(Wl);
  }

  return Wl;
}let um;function qw(){
  if (um) {
    return Ci;
  }
  um=1;
  Object.defineProperty(Ci,"__esModule",{value:true});
  Ci.createLogLevelDiagLogger=void 0;
  const e=Zp();function t(n,r){
  if (n<e.DiagLogLevel.NONE) {
    n=e.DiagLogLevel.NONE;
  } else if (n>e.DiagLogLevel.ALL) {
    (n = e.DiagLogLevel.ALL);
  }

  r=r||{};
  function o(s,i){const a=r[s];return typeof a=="function"&&n>=i?a.bind(r):() => {};}return{error:o("error",e.DiagLogLevel.ERROR),warn:o("warn",e.DiagLogLevel.WARN),info:o("info",e.DiagLogLevel.INFO),debug:o("debug",e.DiagLogLevel.DEBUG),verbose:o("verbose",e.DiagLogLevel.VERBOSE)}
}
  Ci.createLogLevelDiagLogger=t;
  return Ci;
}let lm;function Ko(){
  if (lm) {
    return Ni;
  }
  lm=1;
  Object.defineProperty(Ni,"__esModule",{value:true});
  Ni.DiagAPI=void 0;
  const e=jw();
  const t=qw();
  const n=Zp();
  const r=Wo();
  const o="diag";
  class s{constructor(){
    function a(f){return (...d) => {const u=(0,r.getGlobal)("diag");if (u) {
      return u[f](...d)
    }};}
    const c=this;

    const l=(f,d={logLevel:n.DiagLogLevel.INFO})=>{
      if(f===c){
        const T=new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
        c.error(T.stack ?? T.message);
        return false;
      }

      if (typeof d=="number") {
        (d = {logLevel:d});
      }

      const E=(0,r.getGlobal)("diag");
      const h=(0,t.createLogLevelDiagLogger)(d.logLevel ?? n.DiagLogLevel.INFO,f);
      if(E&&!d.suppressOverrideMessage){
        const T=new Error().stack ?? "<failed to generate stacktrace>";
        E.warn(`Current logger will be overwritten from ${T}`);
        h.warn(`Current logger will overwrite one already registered from ${T}`);
      }return (0,r.registerGlobal)("diag",h,c,true);
    };

    c.setLogger=l;
    c.disable=()=>{(0,r.unregisterGlobal)(o,c)};

    c.createComponentLogger=f => new e.DiagComponentLogger(f);

    c.verbose=a("verbose");
    c.debug=a("debug");
    c.info=a("info");
    c.warn=a("warn");
    c.error=a("error");
  }static instance(){
    if (!this._instance) {
      (this._instance = new s);
    }

    return this._instance;
  }}
  Ni.DiagAPI=s;
  return Ni;
}
const Ii={};
let dm;
function Ww(){
  if (dm) {
    return Ii;
  }
  dm=1;
  Object.defineProperty(Ii,"__esModule",{value:true});
  Ii.BaggageImpl=void 0;
  class e{constructor(n){this._entries=n?new Map(n):new Map}getEntry(n){const r=this._entries.get(n);if (r) {
    return Object.assign({},r)
  }}getAllEntries(){return Array.from(this._entries.entries()).map(([n,r]) => [n,r]);}setEntry(n,r){
    const o=new e(this._entries);
    o._entries.set(n,r);
    return o;
  }removeEntry(n){
    const r=new e(this._entries);
    r._entries.delete(n);
    return r;
  }removeEntries(...n){const r=new e(this._entries);for (const o of n) {
    r._entries.delete(o);
  }return r}clear(){return new e}}
  Ii.BaggageImpl=e;
  return Ii;
}
const Pi={};
let fm;
function Kw(){
  if (!fm) {
    fm=1;
    Object.defineProperty(Pi,"__esModule",{value:true});
    Pi.baggageEntryMetadataSymbol=void 0;
    Pi.baggageEntryMetadataSymbol=Symbol("BaggageEntryMetadata");
  }

  return Pi;
}let _m;function qC(){
  if (_m) {
    return dr;
  }
  _m=1;
  Object.defineProperty(dr,"__esModule",{value:true});
  dr.baggageEntryMetadataFromString = void 0;
  dr.createBaggage = void 0;
  const e=Ko();
  const t=Ww();
  const n=Kw();
  const r=e.DiagAPI.instance();
  function o(i={}){return new t.BaggageImpl(new Map(Object.entries(i)))}dr.createBaggage=o;function s(i){
  if (typeof i!="string") {
    r.error(`Cannot create baggage metadata from unknown type: ${typeof i}`);
    i="";
  }

  return {__TYPE__:n.baggageEntryMetadataSymbol,toString(){return i}};
}
  dr.baggageEntryMetadataFromString=s;
  return dr;
}
const Er={};
let pm;
function Xu(){
  if (pm) {
    return Er;
  }
  pm=1;
  Object.defineProperty(Er,"__esModule",{value:true});
  Er.ROOT_CONTEXT = void 0;
  Er.createContextKey = void 0;
  function e(n){return Symbol.for(n)}Er.createContextKey=e;class t{constructor(r){
    const o=this;
    o._currentContext=r?new Map(r):new Map;

    o.getValue=s => o._currentContext.get(s);

    o.setValue=(s,i)=>{
      const a=new t(o._currentContext);
      a._currentContext.set(s,i);
      return a;
    };

    o.deleteValue=s=>{
      const i=new t(o._currentContext);
      i._currentContext.delete(s);
      return i;
    };
  }}
  Er.ROOT_CONTEXT=new t;
  return Er;
}
const Mi={};
let Em;
function zw(){
  if (Em) {
    return Mi;
  }
  Em=1;
  Object.defineProperty(Mi,"__esModule",{value:true});
  Mi.DiagConsoleLogger=void 0;
  const e=[{n:"error",c:"error"},{n:"warn",c:"warn"},{n:"info",c:"info"},{n:"debug",c:"debug"},{n:"verbose",c:"trace"}];class t{constructor(){function r(o){return (...s) => {if(console){
  let i=console[o];

  if (typeof i!="function") {
    (i = console.log);
  }

  if (typeof i=="function") {
    return i.apply(console,s)
  }
}};}for (let o=0; o<e.length; o++) {
    this[e[o].n]=r(e[o].c)
  }}}
  Mi.DiagConsoleLogger=t;
  return Mi;
}
const Kl={};
let hm;
function WC(){
  if (!hm) {
    hm=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.createNoopMeter = void 0;
      e.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = void 0;
      e.NOOP_OBSERVABLE_GAUGE_METRIC = void 0;
      e.NOOP_OBSERVABLE_COUNTER_METRIC = void 0;
      e.NOOP_UP_DOWN_COUNTER_METRIC = void 0;
      e.NOOP_HISTOGRAM_METRIC = void 0;
      e.NOOP_GAUGE_METRIC = void 0;
      e.NOOP_COUNTER_METRIC = void 0;
      e.NOOP_METER = void 0;
      e.NoopObservableUpDownCounterMetric = void 0;
      e.NoopObservableGaugeMetric = void 0;
      e.NoopObservableCounterMetric = void 0;
      e.NoopObservableMetric = void 0;
      e.NoopHistogramMetric = void 0;
      e.NoopGaugeMetric = void 0;
      e.NoopUpDownCounterMetric = void 0;
      e.NoopCounterMetric = void 0;
      e.NoopMetric = void 0;
      e.NoopMeter = void 0;
      class t{constructor(){}createGauge(_,p){return e.NOOP_GAUGE_METRIC}createHistogram(_,p){return e.NOOP_HISTOGRAM_METRIC}createCounter(_,p){return e.NOOP_COUNTER_METRIC}createUpDownCounter(_,p){return e.NOOP_UP_DOWN_COUNTER_METRIC}createObservableGauge(_,p){return e.NOOP_OBSERVABLE_GAUGE_METRIC}createObservableCounter(_,p){return e.NOOP_OBSERVABLE_COUNTER_METRIC}createObservableUpDownCounter(_,p){return e.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC}addBatchObservableCallback(_,p){}removeBatchObservableCallback(_){}}e.NoopMeter=t;class n{}e.NoopMetric=n;class r extends n{add(_,p){}}e.NoopCounterMetric=r;class o extends n{add(_,p){}}e.NoopUpDownCounterMetric=o;class s extends n{record(_,p){}}e.NoopGaugeMetric=s;class i extends n{record(_,p){}}e.NoopHistogramMetric=i;class a{addCallback(_){}removeCallback(_){}}e.NoopObservableMetric=a;class c extends a{}e.NoopObservableCounterMetric=c;class l extends a{}e.NoopObservableGaugeMetric=l;class f extends a{}
      e.NoopObservableUpDownCounterMetric=f;
      e.NOOP_METER=new t;
      e.NOOP_COUNTER_METRIC=new r;
      e.NOOP_GAUGE_METRIC=new s;
      e.NOOP_HISTOGRAM_METRIC=new i;
      e.NOOP_UP_DOWN_COUNTER_METRIC=new o;
      e.NOOP_OBSERVABLE_COUNTER_METRIC=new c;
      e.NOOP_OBSERVABLE_GAUGE_METRIC=new l;
      e.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC=new f;
      function d(){return e.NOOP_METER}e.createNoopMeter=d
    })(Kl);
  }

  return Kl;
}
const zl={};
let Tm;
function Zw(){
  if (!Tm) {
    Tm=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.ValueType=void 0;

      (t => {
        t[t.INT=0]="INT";
        t[t.DOUBLE=1]="DOUBLE";
      })(e.ValueType||(e.ValueType={}));
    })(zl);
  }

  return zl;
}
const hr={};
let Sm;
function KC(){
  if (!Sm) {
    Sm=1;
    Object.defineProperty(hr,"__esModule",{value:true});
    hr.defaultTextMapSetter=hr.defaultTextMapGetter=void 0;

    hr.defaultTextMapGetter={get(e,t){if (e!=null) {
      return e[t]
    }},keys(e){return e==null?[]:Object.keys(e)}};

    hr.defaultTextMapSetter={set(e,t,n){
      if (e!=null) {
        (e[t] = n);
      }
    }};
  }

  return hr;
}
const vi={};
const Li={};
const wi={};
const Di={};
let mm;
function Xw(){
  if (mm) {
    return Di;
  }
  mm=1;
  Object.defineProperty(Di,"__esModule",{value:true});
  Di.NoopContextManager=void 0;
  const e=Xu();let t=class{active(){return e.ROOT_CONTEXT}with(r,o,s,...i){return o.call(s,...i)}bind(r,o){return o}enable(){return this}disable(){return this}};
  Di.NoopContextManager=t;
  return Di;
}let Am;function Qu(){
  if (Am) {
    return wi;
  }
  Am=1;
  Object.defineProperty(wi,"__esModule",{value:true});
  wi.ContextAPI=void 0;
  const e=Xw();
  const t=Wo();
  const n=Ko();
  const r="context";
  const o=new e.NoopContextManager;
  class s{constructor(){}static getInstance(){
    if (!this._instance) {
      (this._instance = new s);
    }

    return this._instance;
  }setGlobalContextManager(a){return(0,t.registerGlobal)(r,a,n.DiagAPI.instance())}active(){return this._getContextManager().active()}with(a,c,l,...f){return this._getContextManager().with(a,c,l,...f)}bind(a,c){return this._getContextManager().bind(a,c)}_getContextManager(){return(0,t.getGlobal)(r)||o}disable(){
    this._getContextManager().disable();
    (0,t.unregisterGlobal)(r,n.DiagAPI.instance());
  }}
  wi.ContextAPI=s;
  return wi;
}
const Et={};
const Ui={};
const Zl={};
const Xl={};
let gm;
function zC(){
  if (!gm) {
    gm=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.TraceFlags=void 0;

      (t => {
        t[t.NONE=0]="NONE";
        t[t.SAMPLED=1]="SAMPLED";
      })(e.TraceFlags||(e.TraceFlags={}));
    })(Xl);
  }

  return Xl;
}let Rm;function Xp(){
  if (!Rm) {
    Rm=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.INVALID_SPAN_CONTEXT = void 0;
      e.INVALID_TRACEID = void 0;
      e.INVALID_SPANID = void 0;
      const t=zC();
      e.INVALID_SPANID="0000000000000000";
      e.INVALID_TRACEID="00000000000000000000000000000000";
      e.INVALID_SPAN_CONTEXT={traceId:e.INVALID_TRACEID,spanId:e.INVALID_SPANID,traceFlags:t.TraceFlags.NONE};
    })(Zl);
  }

  return Zl;
}let Nm;function Qp(){
  if (Nm) {
    return Ui;
  }
  Nm=1;
  Object.defineProperty(Ui,"__esModule",{value:true});
  Ui.NonRecordingSpan=void 0;
  const e=Xp();let t=class{constructor(r=e.INVALID_SPAN_CONTEXT){this._spanContext=r}spanContext(){return this._spanContext}setAttribute(r,o){return this}setAttributes(r){return this}addEvent(r,o){return this}addLink(r){return this}addLinks(r){return this}setStatus(r){return this}updateName(r){return this}end(r){}isRecording(){return false;}recordException(r,o){}};
  Ui.NonRecordingSpan=t;
  return Ui;
}let ym;function ZC(){
  if (ym) {
    return Et;
  }
  ym=1;
  Object.defineProperty(Et,"__esModule",{value:true});
  Et.getSpanContext = void 0;
  Et.setSpanContext = void 0;
  Et.deleteSpan = void 0;
  Et.setSpan = void 0;
  Et.getActiveSpan = void 0;
  Et.getSpan = void 0;
  const e=Xu();
  const t=Qp();
  const n=Qu();
  const r=(0,e.createContextKey)("OpenTelemetry Context Key SPAN");
  function o(f){return f.getValue(r)||void 0}Et.getSpan=o;function s(){return o(n.ContextAPI.getInstance().active())}Et.getActiveSpan=s;function i(f,d){return f.setValue(r,d)}Et.setSpan=i;function a(f){return f.deleteValue(r)}Et.deleteSpan=a;function c(f,d){return i(f,new t.NonRecordingSpan(d))}Et.setSpanContext=c;function l(f){let d;return(d=o(f))===null||d===void 0?void 0:d.spanContext()}
  Et.getSpanContext=l;
  return Et;
}
const Xt={};
let Om;
function Jp(){
  if (Om) {
    return Xt;
  }
  Om=1;
  Object.defineProperty(Xt,"__esModule",{value:true});
  Xt.wrapSpanContext = void 0;
  Xt.isSpanContextValid = void 0;
  Xt.isValidSpanId = void 0;
  Xt.isValidTraceId = void 0;
  const e=Xp();
  const t=Qp();
  const n=/^([0-9a-f]{32})$/i;
  const r=/^[0-9a-f]{16}$/i;
  function o(c){return n.test(c)&&c!==e.INVALID_TRACEID}Xt.isValidTraceId=o;function s(c){return r.test(c)&&c!==e.INVALID_SPANID}Xt.isValidSpanId=s;function i(c){return o(c.traceId)&&s(c.spanId)}Xt.isSpanContextValid=i;function a(c){return new t.NonRecordingSpan(c)}
  Xt.wrapSpanContext=a;
  return Xt;
}let bm;function XC(...args) {
  if (bm) {
    return Li;
  }
  bm=1;
  Object.defineProperty(Li,"__esModule",{value:true});
  Li.NoopTracer=void 0;
  const e=Qu();
  const t=ZC();
  const n=Qp();
  const r=Jp();
  const o=e.ContextAPI.getInstance();
  let s=class{startSpan(c,l,f=o.active()){if (!!l?.root) {
    return new n.NonRecordingSpan;
  }const u=f&&(0,t.getSpanContext)(f);return i(u)&&(0,r.isSpanContextValid)(u)?new n.NonRecordingSpan(u):new n.NonRecordingSpan}startActiveSpan(c,l,f,d){
    let u;
    let _;
    let p;
    if (args.length<2) {
      return;
    }

    if (args.length===2) {
      p=l;
    } else if (args.length===3) {
      u=l;
      p=f;
    } else {
      u=l;
      _=f;
      p=d;
    }

    const E=_??o.active();
    const h=this.startSpan(c,u,E);
    const T=(0,t.setSpan)(E,h);
    return o.with(T,p,void 0,h)
  }};Li.NoopTracer=s;function i(a){return typeof a=="object"&&typeof a.spanId=="string"&&typeof a.traceId=="string"&&typeof a.traceFlags=="number"}return Li
}let Cm;function QC(...args) {
  if (Cm) {
    return vi;
  }
  Cm=1;
  Object.defineProperty(vi,"__esModule",{value:true});
  vi.ProxyTracer=void 0;
  const e=XC();
  const t=new e.NoopTracer;
  let n=class{constructor(o,s,i,a){
    this._provider=o;
    this.name=s;
    this.version=i;
    this.options=a;
  }startSpan(o,s,i){return this._getTracer().startSpan(o,s,i)}startActiveSpan(o,s,i,a){const c=this._getTracer();return Reflect.apply(c.startActiveSpan,c,args);}_getTracer(){if (this._delegate) {
    return this._delegate;
  }const o=this._provider.getDelegateTracer(this.name,this.version,this.options);return o?(this._delegate=o,this._delegate):t}};
  vi.ProxyTracer=n;
  return vi;
}
const ki={};
const Gi={};
let Im;
function Qw(){
  if (Im) {
    return Gi;
  }
  Im=1;
  Object.defineProperty(Gi,"__esModule",{value:true});
  Gi.NoopTracerProvider=void 0;
  const e=XC();let t=class{getTracer(r,o,s){return new e.NoopTracer}};
  Gi.NoopTracerProvider=t;
  return Gi;
}let Pm;function JC(){
  if (Pm) {
    return ki;
  }
  Pm=1;
  Object.defineProperty(ki,"__esModule",{value:true});
  ki.ProxyTracerProvider=void 0;
  const e=QC();
  const t=Qw();
  const n=new t.NoopTracerProvider;
  let r=class{getTracer(s,i,a){
    return this.getDelegateTracer(s,i,a) ?? new e.ProxyTracer(this,s,i,a);
  }getDelegate(){
    return this._delegate ?? n;
  }setDelegate(s){this._delegate=s}getDelegateTracer(s,i,a){let c;return(c=this._delegate)===null||c===void 0?void 0:c.getTracer(s,i,a)}};
  ki.ProxyTracerProvider=r;
  return ki;
}
const Ql={};
let Mm;
function Jw(){
  if (!Mm) {
    Mm=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.SamplingDecision=void 0;

      (t => {
        t[t.NOT_RECORD=0]="NOT_RECORD";
        t[t.RECORD=1]="RECORD";
        t[t.RECORD_AND_SAMPLED=2]="RECORD_AND_SAMPLED";
      })(e.SamplingDecision||(e.SamplingDecision={}));
    })(Ql);
  }

  return Ql;
}
const Jl={};
let vm;
function eD(){
  if (!vm) {
    vm=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.SpanKind=void 0;

      (t => {
        t[t.INTERNAL=0]="INTERNAL";
        t[t.SERVER=1]="SERVER";
        t[t.CLIENT=2]="CLIENT";
        t[t.PRODUCER=3]="PRODUCER";
        t[t.CONSUMER=4]="CONSUMER";
      })(e.SpanKind||(e.SpanKind={}));
    })(Jl);
  }

  return Jl;
}
const ed={};
let Lm;
function tD(){
  if (!Lm) {
    Lm=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.SpanStatusCode=void 0;

      (t => {
        t[t.UNSET=0]="UNSET";
        t[t.OK=1]="OK";
        t[t.ERROR=2]="ERROR";
      })(e.SpanStatusCode||(e.SpanStatusCode={}));
    })(ed);
  }

  return ed;
}
const Vi={};
const xi={};
const Tr={};
let wm;
function nD(){
  if (wm) {
    return Tr;
  }
  wm=1;
  Object.defineProperty(Tr,"__esModule",{value:true});
  Tr.validateValue = void 0;
  Tr.validateKey = void 0;
  const e="[_0-9a-z-*/]";
  const t=`[a-z]${e}{0,255}`;
  const n=`[a-z0-9]${e}{0,240}@[a-z]${e}{0,13}`;
  const r=new RegExp(`^(?:${t}|${n})$`);
  const o=/^[ -~]{0,255}[!-~]$/;
  const s=/,|=/;
  function i(c){return r.test(c)}Tr.validateKey=i;function a(c){return o.test(c)&&!s.test(c)}
  Tr.validateValue=a;
  return Tr;
}let Dm;function rD(){
  if (Dm) {
    return xi;
  }
  Dm=1;
  Object.defineProperty(xi,"__esModule",{value:true});
  xi.TraceStateImpl=void 0;
  const e=nD();
  const t=32;
  const n=512;
  const r=",";
  const o="=";
  class s{constructor(a){
    this._internalState=new Map;

    if (a) {
      this._parse(a);
    }
  }set(a,c){
    const l=this._clone();

    if (l._internalState.has(a)) {
      l._internalState.delete(a);
    }

    l._internalState.set(a,c);
    return l;
  }unset(a){
    const c=this._clone();
    c._internalState.delete(a);
    return c;
  }get(a){return this._internalState.get(a)}serialize(){return this._keys().reduce((a, c) => {
    a.push(c+o+this.get(c));
    return a;
  },[]).join(r);}_parse(a){
    if (a.length <= n) {
      this._internalState=a.split(r).reverse().reduce((c,l)=>{
        const f=l.trim();
        const d=f.indexOf(o);
        if(d!==-1){
          const u=f.slice(0,d);
          const _=f.slice(d+1,l.length);

          if ((0,e.validateKey)(u)&&(0,e.validateValue)(_)) {
            c.set(u,_);
          }
        }return c
      },new Map);

      this._internalState.size>t&&(this._internalState=new Map(Array.from(this._internalState.entries()).reverse().slice(0,t)));
    }
  }_keys(){return Array.from(this._internalState.keys()).reverse()}_clone(){
    const a=new s;
    a._internalState=new Map(this._internalState);
    return a;
  }}
  xi.TraceStateImpl=s;
  return xi;
}let Um;function oD(){
  if (Um) {
    return Vi;
  }
  Um=1;
  Object.defineProperty(Vi,"__esModule",{value:true});
  Vi.createTraceState=void 0;
  const e=rD();function t(n){return new e.TraceStateImpl(n)}
  Vi.createTraceState=t;
  return Vi;
}
const $i={};
let km;
function sD(){
  if (km) {
    return $i;
  }
  km=1;
  Object.defineProperty($i,"__esModule",{value:true});
  $i.context=void 0;
  const e=Qu();
  $i.context=e.ContextAPI.getInstance();
  return $i;
}
const Bi={};
let Gm;
function iD(){
  if (Gm) {
    return Bi;
  }
  Gm=1;
  Object.defineProperty(Bi,"__esModule",{value:true});
  Bi.diag=void 0;
  const e=Ko();
  Bi.diag=e.DiagAPI.instance();
  return Bi;
}
const Hi={};
const Fi={};
const Sr={};
let Vm;
function aD(){
  if (Vm) {
    return Sr;
  }
  Vm=1;
  Object.defineProperty(Sr,"__esModule",{value:true});
  Sr.NOOP_METER_PROVIDER = void 0;
  Sr.NoopMeterProvider = void 0;
  const e=WC();let t=class{getMeter(r,o,s){return e.NOOP_METER}};
  Sr.NoopMeterProvider=t;
  Sr.NOOP_METER_PROVIDER=new t;
  return Sr;
}let xm;function cD(){
  if (xm) {
    return Fi;
  }
  xm=1;
  Object.defineProperty(Fi,"__esModule",{value:true});
  Fi.MetricsAPI=void 0;
  const e=aD();
  const t=Wo();
  const n=Ko();
  const r="metrics";
  class o{constructor(){}static getInstance(){
    if (!this._instance) {
      (this._instance = new o);
    }

    return this._instance;
  }setGlobalMeterProvider(i){return(0,t.registerGlobal)(r,i,n.DiagAPI.instance())}getMeterProvider(){return(0,t.getGlobal)(r)||e.NOOP_METER_PROVIDER}getMeter(i,a,c){return this.getMeterProvider().getMeter(i,a,c)}disable(){(0,t.unregisterGlobal)(r,n.DiagAPI.instance())}}
  Fi.MetricsAPI=o;
  return Fi;
}let $m;function uD(){
  if ($m) {
    return Hi;
  }
  $m=1;
  Object.defineProperty(Hi,"__esModule",{value:true});
  Hi.metrics=void 0;
  const e=cD();
  Hi.metrics=e.MetricsAPI.getInstance();
  return Hi;
}
const Yi={};
const ji={};
const qi={};
let Bm;
function lD(){
  if (Bm) {
    return qi;
  }
  Bm=1;
  Object.defineProperty(qi,"__esModule",{value:true});
  qi.NoopTextMapPropagator=void 0;
  let e=class{inject(n,r){}extract(n,r){return n}fields(){return[]}};
  qi.NoopTextMapPropagator=e;
  return qi;
}
const Qt={};
let Hm;
function dD(){
  if (Hm) {
    return Qt;
  }
  Hm=1;
  Object.defineProperty(Qt,"__esModule",{value:true});
  Qt.deleteBaggage = void 0;
  Qt.setBaggage = void 0;
  Qt.getActiveBaggage = void 0;
  Qt.getBaggage = void 0;
  const e=Qu();
  const n=(0,Xu().createContextKey)("OpenTelemetry Baggage Key");
  function r(a){return a.getValue(n)||void 0}Qt.getBaggage=r;function o(){return r(e.ContextAPI.getInstance().active())}Qt.getActiveBaggage=o;function s(a,c){return a.setValue(n,c)}Qt.setBaggage=s;function i(a){return a.deleteValue(n)}
  Qt.deleteBaggage=i;
  return Qt;
}let Fm;function fD(){
  if (Fm) {
    return ji;
  }
  Fm=1;
  Object.defineProperty(ji,"__esModule",{value:true});
  ji.PropagationAPI=void 0;
  const e=Wo();
  const t=lD();
  const n=KC();
  const r=dD();
  const o=qC();
  const s=Ko();
  const i="propagation";
  const a=new t.NoopTextMapPropagator;
  class c{constructor(){
    this.createBaggage=o.createBaggage;
    this.getBaggage=r.getBaggage;
    this.getActiveBaggage=r.getActiveBaggage;
    this.setBaggage=r.setBaggage;
    this.deleteBaggage=r.deleteBaggage;
  }static getInstance(){
    if (!this._instance) {
      (this._instance = new c);
    }

    return this._instance;
  }setGlobalPropagator(f){return(0,e.registerGlobal)(i,f,s.DiagAPI.instance())}inject(f,d,u=n.defaultTextMapSetter){return this._getGlobalPropagator().inject(f,d,u)}extract(f,d,u=n.defaultTextMapGetter){return this._getGlobalPropagator().extract(f,d,u)}fields(){return this._getGlobalPropagator().fields()}disable(){(0,e.unregisterGlobal)(i,s.DiagAPI.instance())}_getGlobalPropagator(){return(0,e.getGlobal)(i)||a}}
  ji.PropagationAPI=c;
  return ji;
}let Ym;function _D(){
  if (Ym) {
    return Yi;
  }
  Ym=1;
  Object.defineProperty(Yi,"__esModule",{value:true});
  Yi.propagation=void 0;
  const e=fD();
  Yi.propagation=e.PropagationAPI.getInstance();
  return Yi;
}
const Wi={};
const Ki={};
let jm;
function pD(){
  if (jm) {
    return Ki;
  }
  jm=1;
  Object.defineProperty(Ki,"__esModule",{value:true});
  Ki.TraceAPI=void 0;
  const e=Wo();
  const t=JC();
  const n=Jp();
  const r=ZC();
  const o=Ko();
  const s="trace";
  class i{constructor(){
    this._proxyTracerProvider=new t.ProxyTracerProvider;
    this.wrapSpanContext=n.wrapSpanContext;
    this.isSpanContextValid=n.isSpanContextValid;
    this.deleteSpan=r.deleteSpan;
    this.getSpan=r.getSpan;
    this.getActiveSpan=r.getActiveSpan;
    this.getSpanContext=r.getSpanContext;
    this.setSpan=r.setSpan;
    this.setSpanContext=r.setSpanContext;
  }static getInstance(){
    if (!this._instance) {
      (this._instance = new i);
    }

    return this._instance;
  }setGlobalTracerProvider(c){
    const l=(0,e.registerGlobal)(s,this._proxyTracerProvider,o.DiagAPI.instance());

    if (l) {
      this._proxyTracerProvider.setDelegate(c);
    }

    return l;
  }getTracerProvider(){return(0,e.getGlobal)(s)||this._proxyTracerProvider}getTracer(c,l){return this.getTracerProvider().getTracer(c,l)}disable(){
    (0,e.unregisterGlobal)(s,o.DiagAPI.instance());
    this._proxyTracerProvider=new t.ProxyTracerProvider;
  }}
  Ki.TraceAPI=i;
  return Ki;
}let qm;function ED(){
  if (qm) {
    return Wi;
  }
  qm=1;
  Object.defineProperty(Wi,"__esModule",{value:true});
  Wi.trace=void 0;
  const e=pD();
  Wi.trace=e.TraceAPI.getInstance();
  return Wi;
}let Wm;function Pe(){
  if (!Wm) {
    Wm=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.trace = void 0;
      e.propagation = void 0;
      e.metrics = void 0;
      e.diag = void 0;
      e.context = void 0;
      e.INVALID_SPAN_CONTEXT = void 0;
      e.INVALID_TRACEID = void 0;
      e.INVALID_SPANID = void 0;
      e.isValidSpanId = void 0;
      e.isValidTraceId = void 0;
      e.isSpanContextValid = void 0;
      e.createTraceState = void 0;
      e.TraceFlags = void 0;
      e.SpanStatusCode = void 0;
      e.SpanKind = void 0;
      e.SamplingDecision = void 0;
      e.ProxyTracerProvider = void 0;
      e.ProxyTracer = void 0;
      e.defaultTextMapSetter = void 0;
      e.defaultTextMapGetter = void 0;
      e.ValueType = void 0;
      e.createNoopMeter = void 0;
      e.DiagLogLevel = void 0;
      e.DiagConsoleLogger = void 0;
      e.ROOT_CONTEXT = void 0;
      e.createContextKey = void 0;
      e.baggageEntryMetadataFromString = void 0;
      const t=qC();Object.defineProperty(e,"baggageEntryMetadataFromString",{enumerable:true,get() {return t.baggageEntryMetadataFromString}});const n=Xu();
      Object.defineProperty(e,"createContextKey",{enumerable:true,get() {return n.createContextKey}});
      Object.defineProperty(e,"ROOT_CONTEXT",{enumerable:true,get() {return n.ROOT_CONTEXT}});
      const r=zw();Object.defineProperty(e,"DiagConsoleLogger",{enumerable:true,get() {return r.DiagConsoleLogger}});const o=Zp();Object.defineProperty(e,"DiagLogLevel",{enumerable:true,get() {return o.DiagLogLevel}});const s=WC();Object.defineProperty(e,"createNoopMeter",{enumerable:true,get() {return s.createNoopMeter}});const i=Zw();Object.defineProperty(e,"ValueType",{enumerable:true,get() {return i.ValueType}});const a=KC();
      Object.defineProperty(e,"defaultTextMapGetter",{enumerable:true,get() {return a.defaultTextMapGetter}});
      Object.defineProperty(e,"defaultTextMapSetter",{enumerable:true,get() {return a.defaultTextMapSetter}});
      const c=QC();Object.defineProperty(e,"ProxyTracer",{enumerable:true,get() {return c.ProxyTracer}});const l=JC();Object.defineProperty(e,"ProxyTracerProvider",{enumerable:true,get() {return l.ProxyTracerProvider}});const f=Jw();Object.defineProperty(e,"SamplingDecision",{enumerable:true,get() {return f.SamplingDecision}});const d=eD();Object.defineProperty(e,"SpanKind",{enumerable:true,get() {return d.SpanKind}});const u=tD();Object.defineProperty(e,"SpanStatusCode",{enumerable:true,get() {return u.SpanStatusCode}});const _=zC();Object.defineProperty(e,"TraceFlags",{enumerable:true,get() {return _.TraceFlags}});const p=oD();Object.defineProperty(e,"createTraceState",{enumerable:true,get() {return p.createTraceState}});const E=Jp();
      Object.defineProperty(e,"isSpanContextValid",{enumerable:true,get() {return E.isSpanContextValid}});
      Object.defineProperty(e,"isValidTraceId",{enumerable:true,get() {return E.isValidTraceId}});
      Object.defineProperty(e,"isValidSpanId",{enumerable:true,get() {return E.isValidSpanId}});
      const h=Xp();
      Object.defineProperty(e,"INVALID_SPANID",{enumerable:true,get() {return h.INVALID_SPANID}});
      Object.defineProperty(e,"INVALID_TRACEID",{enumerable:true,get() {return h.INVALID_TRACEID}});
      Object.defineProperty(e,"INVALID_SPAN_CONTEXT",{enumerable:true,get() {return h.INVALID_SPAN_CONTEXT}});
      const T=sD();Object.defineProperty(e,"context",{enumerable:true,get() {return T.context}});const m=iD();Object.defineProperty(e,"diag",{enumerable:true,get() {return m.diag}});const A=uD();Object.defineProperty(e,"metrics",{enumerable:true,get() {return A.metrics}});const g=_D();Object.defineProperty(e,"propagation",{enumerable:true,get() {return g.propagation}});const R=ED();
      Object.defineProperty(e,"trace",{enumerable:true,get() {return R.trace}});
      e.default={context:T.context,diag:m.diag,metrics:A.metrics,propagation:g.propagation,trace:R.trace};
    })(ql);
  }

  return ql;
}
const C=Pe();
const td={};
const zi={};
const eE=C.createContextKey("OpenTelemetry SDK Context Key SUPPRESS_TRACING");function Qr(e){return e.setValue(eE,true);}function hD(e){return e.deleteValue(eE)}function yn(e){return e.getValue(eE)===true;}
const TD="=";
const op=";";
const iu=",";
const nd="baggage";
const SD=180;
const mD=4096;
const AD=8192;
function gD(e){return e.reduce((t,n)=>{const r=`${t}${t!==""?iu:""}${n}`;return r.length>AD?t:r},"")}function RD(e){return e.getAllEntries().map(([t,n])=>{
  let r=`${encodeURIComponent(t)}=${encodeURIComponent(n.value)}`;

  if (n.metadata!==void 0) {
    (r += op+n.metadata.toString());
  }

  return r;
});}function eI(e){
  const t=e.split(op);if (t.length<=0) {
      return;
    }const n=t.shift();if (!n) {
      return;
    }const r=n.indexOf(TD);if (r<=0) {
      return;
    }
  const o=decodeURIComponent(n.substring(0,r).trim());
  const s=decodeURIComponent(n.substring(r+1).trim());
  let i;

  if (t.length>0) {
    (i = C.baggageEntryMetadataFromString(t.join(op)));
  }

  return {key:o,value:s,metadata:i};
}function ND(e){
  const t={};

  if (typeof e=="string"&&e.length>0) {
    e.split(iu).forEach(n=>{
      const r=eI(n);

      if (r!==void 0&&r.value.length>0) {
        (t[r.key] = r.value);
      }
    });
  }

  return t;
}class tI{inject(t,n,r){
  const o=C.propagation.getBaggage(t);if (!o||yn(t)) {
      return;
    }

  const s=RD(o).filter(a => a.length<=mD).slice(0,SD);

  const i=gD(s);

  if (i.length>0) {
    r.set(n,nd,i);
  }
}extract(t,n,r){
  const o=r.get(n,nd);
  const s=Array.isArray(o)?o.join(iu):o;
  if (!s) {
    return t;
  }const i={};return s.length===0||(s.split(iu).forEach(c=>{const l=eI(c);if(l){
  const f={value:l.value};

  if (l.metadata) {
    (f.metadata = l.metadata);
  }

  i[l.key]=f;
}}),Object.entries(i).length===0)?t:C.propagation.setBaggage(t,C.propagation.createBaggage(i));
}fields(){return[nd]}}class yD{_monotonicClock;_epochMillis;_performanceMillis;constructor(t,n){
  this._monotonicClock=n;
  this._epochMillis=t.now();
  this._performanceMillis=n.now();
}now(){const t=this._monotonicClock.now()-this._performanceMillis;return this._epochMillis+t}}function Wa(e){const t={};if (typeof e!="object"||e==null) {
  return t;
}for(const n in e){
  if (!Object.prototype.hasOwnProperty.call(e,n)) {
    continue;
  }if(!OD(n)){C.diag.warn(`Invalid attribute key: ${n}`);continue}const r=e[n];if(!tE(r)){C.diag.warn(`Invalid attribute value set for key: ${n}`);continue}

  if (Array.isArray(r)) {
    t[n]=r.slice();
  } else {
    t[n]=r;
  }
}return t}function OD(e){return typeof e=="string"&&e!==""}function tE(e){return e==null?true:Array.isArray(e)?bD(e):nI(typeof e);}function bD(e){let t;for(const n of e){if (n==null) {
  continue;
}const r=typeof n;if(r!==t){if(!t){if(nI(r)){t=r;continue}return false;}return false;}}return true;}function nI(e){switch(e){case"number":case"boolean":case "string":
  {
    return true;
  }}return false;}function rI(){return e=>{C.diag.error(CD(e))}}function CD(e){return typeof e=="string"?e:JSON.stringify(ID(e))}function ID(e){
  const t={};let n=e;

  while (n!==null) {
    Object.getOwnPropertyNames(n).forEach(r=>{
      if (t[r]) {
        return;
      }const o=n[r];

      if (o) {
        (t[r] = String(o));
      }
    });

    n=Object.getPrototypeOf(n);
  }

  return t
}let oI=rI();function PD(e){oI=e}function nE(e){try{oI(e)}catch{}}function bt(e){const t=process.env[e];if (t==null||t.trim()==="") {
  return;
}const n=Number(t);if(isNaN(n)){C.diag.warn(`Unknown value ${Xr.inspect(t)} for ${e}, expected a number, using defaults`);return}return n}function rE(e){const t=process.env[e];if (!(t==null||t.trim()==="")) {
  return t
}}function MD(e){const t=process.env[e]?.trim().toLowerCase();return t==null||t===""?false:t==="true"?true:(t==="false"||C.diag.warn(`Unknown value ${Xr.inspect(t)} for ${e}, expected 'true' or 'false', falling back to 'false' (default)`),false);}function vD(e){return rE(e)?.split(",").map(t => t.trim()).filter(t => t!=="");}
const LD=typeof globalThis=="object"?globalThis:global;
const zr=Iw.performance;
const wD="2.2.0";
const mr={};
const Ar={};
const S={};
const Zi={};
let Km;
function sI(){
  if (Km) {
    return Zi;
  }
  Km=1;
  Object.defineProperty(Zi,"__esModule",{value:true});
  Zi.createConstMap=void 0;
  function e(t){let n={};const r=t.length;for(let o=0;o<r;o++){
    const s=t[o];

    if (s) {
      (n[String(s).toUpperCase().replace(/[-.]/g,"_")] = s);
    }
  }return n}
  Zi.createConstMap=e;
  return Zi;
}let zm;function DD(){
  if (zm) {
    return S;
  }
  zm=1;
  Object.defineProperty(S,"__esModule",{value:true});
  S.SEMATTRS_NET_HOST_CARRIER_ICC = void 0;
  S.SEMATTRS_NET_HOST_CARRIER_MNC = void 0;
  S.SEMATTRS_NET_HOST_CARRIER_MCC = void 0;
  S.SEMATTRS_NET_HOST_CARRIER_NAME = void 0;
  S.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = void 0;
  S.SEMATTRS_NET_HOST_CONNECTION_TYPE = void 0;
  S.SEMATTRS_NET_HOST_NAME = void 0;
  S.SEMATTRS_NET_HOST_PORT = void 0;
  S.SEMATTRS_NET_HOST_IP = void 0;
  S.SEMATTRS_NET_PEER_NAME = void 0;
  S.SEMATTRS_NET_PEER_PORT = void 0;
  S.SEMATTRS_NET_PEER_IP = void 0;
  S.SEMATTRS_NET_TRANSPORT = void 0;
  S.SEMATTRS_FAAS_INVOKED_REGION = void 0;
  S.SEMATTRS_FAAS_INVOKED_PROVIDER = void 0;
  S.SEMATTRS_FAAS_INVOKED_NAME = void 0;
  S.SEMATTRS_FAAS_COLDSTART = void 0;
  S.SEMATTRS_FAAS_CRON = void 0;
  S.SEMATTRS_FAAS_TIME = void 0;
  S.SEMATTRS_FAAS_DOCUMENT_NAME = void 0;
  S.SEMATTRS_FAAS_DOCUMENT_TIME = void 0;
  S.SEMATTRS_FAAS_DOCUMENT_OPERATION = void 0;
  S.SEMATTRS_FAAS_DOCUMENT_COLLECTION = void 0;
  S.SEMATTRS_FAAS_EXECUTION = void 0;
  S.SEMATTRS_FAAS_TRIGGER = void 0;
  S.SEMATTRS_EXCEPTION_ESCAPED = void 0;
  S.SEMATTRS_EXCEPTION_STACKTRACE = void 0;
  S.SEMATTRS_EXCEPTION_MESSAGE = void 0;
  S.SEMATTRS_EXCEPTION_TYPE = void 0;
  S.SEMATTRS_DB_SQL_TABLE = void 0;
  S.SEMATTRS_DB_MONGODB_COLLECTION = void 0;
  S.SEMATTRS_DB_REDIS_DATABASE_INDEX = void 0;
  S.SEMATTRS_DB_HBASE_NAMESPACE = void 0;
  S.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = void 0;
  S.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = void 0;
  S.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = void 0;
  S.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = void 0;
  S.SEMATTRS_DB_CASSANDRA_TABLE = void 0;
  S.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = void 0;
  S.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = void 0;
  S.SEMATTRS_DB_CASSANDRA_KEYSPACE = void 0;
  S.SEMATTRS_DB_MSSQL_INSTANCE_NAME = void 0;
  S.SEMATTRS_DB_OPERATION = void 0;
  S.SEMATTRS_DB_STATEMENT = void 0;
  S.SEMATTRS_DB_NAME = void 0;
  S.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = void 0;
  S.SEMATTRS_DB_USER = void 0;
  S.SEMATTRS_DB_CONNECTION_STRING = void 0;
  S.SEMATTRS_DB_SYSTEM = void 0;
  S.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = void 0;
  S.SEMATTRS_MESSAGING_DESTINATION_KIND = void 0;
  S.SEMATTRS_MESSAGING_DESTINATION = void 0;
  S.SEMATTRS_MESSAGING_SYSTEM = void 0;
  S.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = void 0;
  S.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = void 0;
  S.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = void 0;
  S.SEMATTRS_AWS_DYNAMODB_COUNT = void 0;
  S.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = void 0;
  S.SEMATTRS_AWS_DYNAMODB_SEGMENT = void 0;
  S.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = void 0;
  S.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = void 0;
  S.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = void 0;
  S.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = void 0;
  S.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = void 0;
  S.SEMATTRS_AWS_DYNAMODB_SELECT = void 0;
  S.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = void 0;
  S.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = void 0;
  S.SEMATTRS_AWS_DYNAMODB_LIMIT = void 0;
  S.SEMATTRS_AWS_DYNAMODB_PROJECTION = void 0;
  S.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = void 0;
  S.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = void 0;
  S.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = void 0;
  S.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = void 0;
  S.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = void 0;
  S.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = void 0;
  S.SEMATTRS_HTTP_CLIENT_IP = void 0;
  S.SEMATTRS_HTTP_ROUTE = void 0;
  S.SEMATTRS_HTTP_SERVER_NAME = void 0;
  S.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = void 0;
  S.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = void 0;
  S.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = void 0;
  S.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = void 0;
  S.SEMATTRS_HTTP_USER_AGENT = void 0;
  S.SEMATTRS_HTTP_FLAVOR = void 0;
  S.SEMATTRS_HTTP_STATUS_CODE = void 0;
  S.SEMATTRS_HTTP_SCHEME = void 0;
  S.SEMATTRS_HTTP_HOST = void 0;
  S.SEMATTRS_HTTP_TARGET = void 0;
  S.SEMATTRS_HTTP_URL = void 0;
  S.SEMATTRS_HTTP_METHOD = void 0;
  S.SEMATTRS_CODE_LINENO = void 0;
  S.SEMATTRS_CODE_FILEPATH = void 0;
  S.SEMATTRS_CODE_NAMESPACE = void 0;
  S.SEMATTRS_CODE_FUNCTION = void 0;
  S.SEMATTRS_THREAD_NAME = void 0;
  S.SEMATTRS_THREAD_ID = void 0;
  S.SEMATTRS_ENDUSER_SCOPE = void 0;
  S.SEMATTRS_ENDUSER_ROLE = void 0;
  S.SEMATTRS_ENDUSER_ID = void 0;
  S.SEMATTRS_PEER_SERVICE = void 0;
  S.DBSYSTEMVALUES_FILEMAKER = void 0;
  S.DBSYSTEMVALUES_DERBY = void 0;
  S.DBSYSTEMVALUES_FIREBIRD = void 0;
  S.DBSYSTEMVALUES_ADABAS = void 0;
  S.DBSYSTEMVALUES_CACHE = void 0;
  S.DBSYSTEMVALUES_EDB = void 0;
  S.DBSYSTEMVALUES_FIRSTSQL = void 0;
  S.DBSYSTEMVALUES_INGRES = void 0;
  S.DBSYSTEMVALUES_HANADB = void 0;
  S.DBSYSTEMVALUES_MAXDB = void 0;
  S.DBSYSTEMVALUES_PROGRESS = void 0;
  S.DBSYSTEMVALUES_HSQLDB = void 0;
  S.DBSYSTEMVALUES_CLOUDSCAPE = void 0;
  S.DBSYSTEMVALUES_HIVE = void 0;
  S.DBSYSTEMVALUES_REDSHIFT = void 0;
  S.DBSYSTEMVALUES_POSTGRESQL = void 0;
  S.DBSYSTEMVALUES_DB2 = void 0;
  S.DBSYSTEMVALUES_ORACLE = void 0;
  S.DBSYSTEMVALUES_MYSQL = void 0;
  S.DBSYSTEMVALUES_MSSQL = void 0;
  S.DBSYSTEMVALUES_OTHER_SQL = void 0;
  S.SemanticAttributes = void 0;
  S.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = void 0;
  S.SEMATTRS_MESSAGE_COMPRESSED_SIZE = void 0;
  S.SEMATTRS_MESSAGE_ID = void 0;
  S.SEMATTRS_MESSAGE_TYPE = void 0;
  S.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = void 0;
  S.SEMATTRS_RPC_JSONRPC_ERROR_CODE = void 0;
  S.SEMATTRS_RPC_JSONRPC_REQUEST_ID = void 0;
  S.SEMATTRS_RPC_JSONRPC_VERSION = void 0;
  S.SEMATTRS_RPC_GRPC_STATUS_CODE = void 0;
  S.SEMATTRS_RPC_METHOD = void 0;
  S.SEMATTRS_RPC_SERVICE = void 0;
  S.SEMATTRS_RPC_SYSTEM = void 0;
  S.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = void 0;
  S.SEMATTRS_MESSAGING_KAFKA_PARTITION = void 0;
  S.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = void 0;
  S.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = void 0;
  S.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = void 0;
  S.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = void 0;
  S.SEMATTRS_MESSAGING_CONSUMER_ID = void 0;
  S.SEMATTRS_MESSAGING_OPERATION = void 0;
  S.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = void 0;
  S.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = void 0;
  S.SEMATTRS_MESSAGING_CONVERSATION_ID = void 0;
  S.SEMATTRS_MESSAGING_MESSAGE_ID = void 0;
  S.SEMATTRS_MESSAGING_URL = void 0;
  S.SEMATTRS_MESSAGING_PROTOCOL_VERSION = void 0;
  S.SEMATTRS_MESSAGING_PROTOCOL = void 0;
  S.SEMATTRS_MESSAGING_TEMP_DESTINATION = void 0;
  S.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = void 0;
  S.FaasDocumentOperationValues = void 0;
  S.FAASDOCUMENTOPERATIONVALUES_DELETE = void 0;
  S.FAASDOCUMENTOPERATIONVALUES_EDIT = void 0;
  S.FAASDOCUMENTOPERATIONVALUES_INSERT = void 0;
  S.FaasTriggerValues = void 0;
  S.FAASTRIGGERVALUES_OTHER = void 0;
  S.FAASTRIGGERVALUES_TIMER = void 0;
  S.FAASTRIGGERVALUES_PUBSUB = void 0;
  S.FAASTRIGGERVALUES_HTTP = void 0;
  S.FAASTRIGGERVALUES_DATASOURCE = void 0;
  S.DbCassandraConsistencyLevelValues = void 0;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = void 0;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = void 0;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = void 0;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = void 0;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = void 0;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = void 0;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = void 0;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = void 0;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = void 0;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = void 0;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = void 0;
  S.DbSystemValues = void 0;
  S.DBSYSTEMVALUES_COCKROACHDB = void 0;
  S.DBSYSTEMVALUES_MEMCACHED = void 0;
  S.DBSYSTEMVALUES_ELASTICSEARCH = void 0;
  S.DBSYSTEMVALUES_GEODE = void 0;
  S.DBSYSTEMVALUES_NEO4J = void 0;
  S.DBSYSTEMVALUES_DYNAMODB = void 0;
  S.DBSYSTEMVALUES_COSMOSDB = void 0;
  S.DBSYSTEMVALUES_COUCHDB = void 0;
  S.DBSYSTEMVALUES_COUCHBASE = void 0;
  S.DBSYSTEMVALUES_REDIS = void 0;
  S.DBSYSTEMVALUES_MONGODB = void 0;
  S.DBSYSTEMVALUES_HBASE = void 0;
  S.DBSYSTEMVALUES_CASSANDRA = void 0;
  S.DBSYSTEMVALUES_COLDFUSION = void 0;
  S.DBSYSTEMVALUES_H2 = void 0;
  S.DBSYSTEMVALUES_VERTICA = void 0;
  S.DBSYSTEMVALUES_TERADATA = void 0;
  S.DBSYSTEMVALUES_SYBASE = void 0;
  S.DBSYSTEMVALUES_SQLITE = void 0;
  S.DBSYSTEMVALUES_POINTBASE = void 0;
  S.DBSYSTEMVALUES_PERVASIVE = void 0;
  S.DBSYSTEMVALUES_NETEZZA = void 0;
  S.DBSYSTEMVALUES_MARIADB = void 0;
  S.DBSYSTEMVALUES_INTERBASE = void 0;
  S.DBSYSTEMVALUES_INSTANTDB = void 0;
  S.DBSYSTEMVALUES_INFORMIX = void 0;
  S.MESSAGINGOPERATIONVALUES_RECEIVE = void 0;
  S.MessagingDestinationKindValues = void 0;
  S.MESSAGINGDESTINATIONKINDVALUES_TOPIC = void 0;
  S.MESSAGINGDESTINATIONKINDVALUES_QUEUE = void 0;
  S.HttpFlavorValues = void 0;
  S.HTTPFLAVORVALUES_QUIC = void 0;
  S.HTTPFLAVORVALUES_SPDY = void 0;
  S.HTTPFLAVORVALUES_HTTP_2_0 = void 0;
  S.HTTPFLAVORVALUES_HTTP_1_1 = void 0;
  S.HTTPFLAVORVALUES_HTTP_1_0 = void 0;
  S.NetHostConnectionSubtypeValues = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_NR = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = void 0;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = void 0;
  S.NetHostConnectionTypeValues = void 0;
  S.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = void 0;
  S.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = void 0;
  S.NETHOSTCONNECTIONTYPEVALUES_CELL = void 0;
  S.NETHOSTCONNECTIONTYPEVALUES_WIRED = void 0;
  S.NETHOSTCONNECTIONTYPEVALUES_WIFI = void 0;
  S.NetTransportValues = void 0;
  S.NETTRANSPORTVALUES_OTHER = void 0;
  S.NETTRANSPORTVALUES_INPROC = void 0;
  S.NETTRANSPORTVALUES_PIPE = void 0;
  S.NETTRANSPORTVALUES_UNIX = void 0;
  S.NETTRANSPORTVALUES_IP = void 0;
  S.NETTRANSPORTVALUES_IP_UDP = void 0;
  S.NETTRANSPORTVALUES_IP_TCP = void 0;
  S.FaasInvokedProviderValues = void 0;
  S.FAASINVOKEDPROVIDERVALUES_GCP = void 0;
  S.FAASINVOKEDPROVIDERVALUES_AZURE = void 0;
  S.FAASINVOKEDPROVIDERVALUES_AWS = void 0;
  S.MessageTypeValues = void 0;
  S.MESSAGETYPEVALUES_RECEIVED = void 0;
  S.MESSAGETYPEVALUES_SENT = void 0;
  S.RpcGrpcStatusCodeValues = void 0;
  S.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = void 0;
  S.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = void 0;
  S.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = void 0;
  S.RPCGRPCSTATUSCODEVALUES_INTERNAL = void 0;
  S.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = void 0;
  S.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = void 0;
  S.RPCGRPCSTATUSCODEVALUES_ABORTED = void 0;
  S.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = void 0;
  S.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = void 0;
  S.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = void 0;
  S.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = void 0;
  S.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = void 0;
  S.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = void 0;
  S.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = void 0;
  S.RPCGRPCSTATUSCODEVALUES_UNKNOWN = void 0;
  S.RPCGRPCSTATUSCODEVALUES_CANCELLED = void 0;
  S.RPCGRPCSTATUSCODEVALUES_OK = void 0;
  S.MessagingOperationValues = void 0;
  S.MESSAGINGOPERATIONVALUES_PROCESS = void 0;
  const e=sI();
  const t="aws.lambda.invoked_arn";
  const n="db.system";
  const r="db.connection_string";
  const o="db.user";
  const s="db.jdbc.driver_classname";
  const i="db.name";
  const a="db.statement";
  const c="db.operation";
  const l="db.mssql.instance_name";
  const f="db.cassandra.keyspace";
  const d="db.cassandra.page_size";
  const u="db.cassandra.consistency_level";
  const _="db.cassandra.table";
  const p="db.cassandra.idempotence";
  const E="db.cassandra.speculative_execution_count";
  const h="db.cassandra.coordinator.id";
  const T="db.cassandra.coordinator.dc";
  const m="db.hbase.namespace";
  const A="db.redis.database_index";
  const g="db.mongodb.collection";
  const R="db.sql.table";
  const O="exception.type";
  const I="exception.message";
  const b="exception.stacktrace";
  const L="exception.escaped";
  const U="faas.trigger";
  const q="faas.execution";
  const H="faas.document.collection";
  const $="faas.document.operation";
  const B="faas.document.time";
  const F="faas.document.name";
  const D="faas.time";
  const k="faas.cron";
  const Y="faas.coldstart";
  const oe="faas.invoked_name";
  const ae="faas.invoked_provider";
  const ne="faas.invoked_region";
  const P="net.transport";
  const M="net.peer.ip";
  const G="net.peer.port";
  const V="net.peer.name";
  const K="net.host.ip";
  const X="net.host.port";
  const v="net.host.name";
  const w="net.host.connection.type";
  const z="net.host.connection.subtype";
  const j="net.host.carrier.name";
  const ee="net.host.carrier.mcc";
  const te="net.host.carrier.mnc";
  const _e="net.host.carrier.icc";
  const se="peer.service";
  const ue="enduser.id";
  const Te="enduser.role";
  const ve="enduser.scope";
  const we="thread.id";
  const qe="thread.name";
  const Mt="code.function";
  const it="code.namespace";
  const at="code.filepath";
  const nt="code.lineno";
  const ss="http.method";
  const is="http.url";
  const as="http.target";
  const cs="http.host";
  const us="http.scheme";
  const ls="http.status_code";
  const ds="http.flavor";
  const fs="http.user_agent";
  const _s="http.request_content_length";
  const ps="http.request_content_length_uncompressed";
  const Es="http.response_content_length";
  const hs="http.response_content_length_uncompressed";
  const Ts="http.server_name";
  const Ss="http.route";
  const ms="http.client_ip";
  const As="aws.dynamodb.table_names";
  const gs="aws.dynamodb.consumed_capacity";
  const Rs="aws.dynamodb.item_collection_metrics";
  const Ns="aws.dynamodb.provisioned_read_capacity";
  const ys="aws.dynamodb.provisioned_write_capacity";
  const Os="aws.dynamodb.consistent_read";
  const bs="aws.dynamodb.projection";
  const Cs="aws.dynamodb.limit";
  const Is="aws.dynamodb.attributes_to_get";
  const Ps="aws.dynamodb.index_name";
  const Ms="aws.dynamodb.select";
  const vs="aws.dynamodb.global_secondary_indexes";
  const Ls="aws.dynamodb.local_secondary_indexes";
  const ws="aws.dynamodb.exclusive_start_table";
  const Ds="aws.dynamodb.table_count";
  const Us="aws.dynamodb.scan_forward";
  const ks="aws.dynamodb.segment";
  const Gs="aws.dynamodb.total_segments";
  const Vs="aws.dynamodb.count";
  const xs="aws.dynamodb.scanned_count";
  const $s="aws.dynamodb.attribute_definitions";
  const Bs="aws.dynamodb.global_secondary_index_updates";
  const Hs="messaging.system";
  const Fs="messaging.destination";
  const Ys="messaging.destination_kind";
  const js="messaging.temp_destination";
  const qs="messaging.protocol";
  const Ws="messaging.protocol_version";
  const Ks="messaging.url";
  const zs="messaging.message_id";
  const Zs="messaging.conversation_id";
  const Xs="messaging.message_payload_size_bytes";
  const Qs="messaging.message_payload_compressed_size_bytes";
  const Js="messaging.operation";
  const ei="messaging.consumer_id";
  const ti="messaging.rabbitmq.routing_key";
  const ni="messaging.kafka.message_key";
  const ri="messaging.kafka.consumer_group";
  const oi="messaging.kafka.client_id";
  const si="messaging.kafka.partition";
  const ii="messaging.kafka.tombstone";
  const ai="rpc.system";
  const ci="rpc.service";
  const ui="rpc.method";
  const li="rpc.grpc.status_code";
  const di="rpc.jsonrpc.version";
  const fi="rpc.jsonrpc.request_id";
  const _i="rpc.jsonrpc.error_code";
  const pi="rpc.jsonrpc.error_message";
  const Ei="message.type";
  const hi="message.id";
  const Ti="message.compressed_size";
  const Si="message.uncompressed_size";
  S.SEMATTRS_AWS_LAMBDA_INVOKED_ARN=t;
  S.SEMATTRS_DB_SYSTEM=n;
  S.SEMATTRS_DB_CONNECTION_STRING=r;
  S.SEMATTRS_DB_USER=o;
  S.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME=s;
  S.SEMATTRS_DB_NAME=i;
  S.SEMATTRS_DB_STATEMENT=a;
  S.SEMATTRS_DB_OPERATION=c;
  S.SEMATTRS_DB_MSSQL_INSTANCE_NAME=l;
  S.SEMATTRS_DB_CASSANDRA_KEYSPACE=f;
  S.SEMATTRS_DB_CASSANDRA_PAGE_SIZE=d;
  S.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL=u;
  S.SEMATTRS_DB_CASSANDRA_TABLE=_;
  S.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE=p;
  S.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT=E;
  S.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID=h;
  S.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC=T;
  S.SEMATTRS_DB_HBASE_NAMESPACE=m;
  S.SEMATTRS_DB_REDIS_DATABASE_INDEX=A;
  S.SEMATTRS_DB_MONGODB_COLLECTION=g;
  S.SEMATTRS_DB_SQL_TABLE=R;
  S.SEMATTRS_EXCEPTION_TYPE=O;
  S.SEMATTRS_EXCEPTION_MESSAGE=I;
  S.SEMATTRS_EXCEPTION_STACKTRACE=b;
  S.SEMATTRS_EXCEPTION_ESCAPED=L;
  S.SEMATTRS_FAAS_TRIGGER=U;
  S.SEMATTRS_FAAS_EXECUTION=q;
  S.SEMATTRS_FAAS_DOCUMENT_COLLECTION=H;
  S.SEMATTRS_FAAS_DOCUMENT_OPERATION=$;
  S.SEMATTRS_FAAS_DOCUMENT_TIME=B;
  S.SEMATTRS_FAAS_DOCUMENT_NAME=F;
  S.SEMATTRS_FAAS_TIME=D;
  S.SEMATTRS_FAAS_CRON=k;
  S.SEMATTRS_FAAS_COLDSTART=Y;
  S.SEMATTRS_FAAS_INVOKED_NAME=oe;
  S.SEMATTRS_FAAS_INVOKED_PROVIDER=ae;
  S.SEMATTRS_FAAS_INVOKED_REGION=ne;
  S.SEMATTRS_NET_TRANSPORT=P;
  S.SEMATTRS_NET_PEER_IP=M;
  S.SEMATTRS_NET_PEER_PORT=G;
  S.SEMATTRS_NET_PEER_NAME=V;
  S.SEMATTRS_NET_HOST_IP=K;
  S.SEMATTRS_NET_HOST_PORT=X;
  S.SEMATTRS_NET_HOST_NAME=v;
  S.SEMATTRS_NET_HOST_CONNECTION_TYPE=w;
  S.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE=z;
  S.SEMATTRS_NET_HOST_CARRIER_NAME=j;
  S.SEMATTRS_NET_HOST_CARRIER_MCC=ee;
  S.SEMATTRS_NET_HOST_CARRIER_MNC=te;
  S.SEMATTRS_NET_HOST_CARRIER_ICC=_e;
  S.SEMATTRS_PEER_SERVICE=se;
  S.SEMATTRS_ENDUSER_ID=ue;
  S.SEMATTRS_ENDUSER_ROLE=Te;
  S.SEMATTRS_ENDUSER_SCOPE=ve;
  S.SEMATTRS_THREAD_ID=we;
  S.SEMATTRS_THREAD_NAME=qe;
  S.SEMATTRS_CODE_FUNCTION=Mt;
  S.SEMATTRS_CODE_NAMESPACE=it;
  S.SEMATTRS_CODE_FILEPATH=at;
  S.SEMATTRS_CODE_LINENO=nt;
  S.SEMATTRS_HTTP_METHOD=ss;
  S.SEMATTRS_HTTP_URL=is;
  S.SEMATTRS_HTTP_TARGET=as;
  S.SEMATTRS_HTTP_HOST=cs;
  S.SEMATTRS_HTTP_SCHEME=us;
  S.SEMATTRS_HTTP_STATUS_CODE=ls;
  S.SEMATTRS_HTTP_FLAVOR=ds;
  S.SEMATTRS_HTTP_USER_AGENT=fs;
  S.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH=_s;
  S.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED=ps;
  S.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH=Es;
  S.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED=hs;
  S.SEMATTRS_HTTP_SERVER_NAME=Ts;
  S.SEMATTRS_HTTP_ROUTE=Ss;
  S.SEMATTRS_HTTP_CLIENT_IP=ms;
  S.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES=As;
  S.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY=gs;
  S.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS=Rs;
  S.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY=Ns;
  S.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY=ys;
  S.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ=Os;
  S.SEMATTRS_AWS_DYNAMODB_PROJECTION=bs;
  S.SEMATTRS_AWS_DYNAMODB_LIMIT=Cs;
  S.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET=Is;
  S.SEMATTRS_AWS_DYNAMODB_INDEX_NAME=Ps;
  S.SEMATTRS_AWS_DYNAMODB_SELECT=Ms;
  S.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES=vs;
  S.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES=Ls;
  S.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE=ws;
  S.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT=Ds;
  S.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD=Us;
  S.SEMATTRS_AWS_DYNAMODB_SEGMENT=ks;
  S.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS=Gs;
  S.SEMATTRS_AWS_DYNAMODB_COUNT=Vs;
  S.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT=xs;
  S.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS=$s;
  S.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES=Bs;
  S.SEMATTRS_MESSAGING_SYSTEM=Hs;
  S.SEMATTRS_MESSAGING_DESTINATION=Fs;
  S.SEMATTRS_MESSAGING_DESTINATION_KIND=Ys;
  S.SEMATTRS_MESSAGING_TEMP_DESTINATION=js;
  S.SEMATTRS_MESSAGING_PROTOCOL=qs;
  S.SEMATTRS_MESSAGING_PROTOCOL_VERSION=Ws;
  S.SEMATTRS_MESSAGING_URL=Ks;
  S.SEMATTRS_MESSAGING_MESSAGE_ID=zs;
  S.SEMATTRS_MESSAGING_CONVERSATION_ID=Zs;
  S.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES=Xs;
  S.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES=Qs;
  S.SEMATTRS_MESSAGING_OPERATION=Js;
  S.SEMATTRS_MESSAGING_CONSUMER_ID=ei;
  S.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY=ti;
  S.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY=ni;
  S.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP=ri;
  S.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID=oi;
  S.SEMATTRS_MESSAGING_KAFKA_PARTITION=si;
  S.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE=ii;
  S.SEMATTRS_RPC_SYSTEM=ai;
  S.SEMATTRS_RPC_SERVICE=ci;
  S.SEMATTRS_RPC_METHOD=ui;
  S.SEMATTRS_RPC_GRPC_STATUS_CODE=li;
  S.SEMATTRS_RPC_JSONRPC_VERSION=di;
  S.SEMATTRS_RPC_JSONRPC_REQUEST_ID=fi;
  S.SEMATTRS_RPC_JSONRPC_ERROR_CODE=_i;
  S.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE=pi;
  S.SEMATTRS_MESSAGE_TYPE=Ei;
  S.SEMATTRS_MESSAGE_ID=hi;
  S.SEMATTRS_MESSAGE_COMPRESSED_SIZE=Ti;
  S.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE=Si;
  S.SemanticAttributes=(0,e.createConstMap)([t,n,r,o,s,i,a,c,l,f,d,u,_,p,E,h,T,m,A,g,R,O,I,b,L,U,q,H,$,B,F,D,k,Y,oe,ae,ne,P,M,G,V,K,X,v,w,z,j,ee,te,_e,se,ue,Te,ve,we,qe,Mt,it,at,nt,ss,is,as,cs,us,ls,ds,fs,_s,ps,Es,hs,Ts,Ss,ms,As,gs,Rs,Ns,ys,Os,bs,Cs,Is,Ps,Ms,vs,Ls,ws,Ds,Us,ks,Gs,Vs,xs,$s,Bs,Hs,Fs,Ys,js,qs,Ws,Ks,zs,Zs,Xs,Qs,Js,ei,ti,ni,ri,oi,si,ii,ai,ci,ui,li,di,fi,_i,pi,Ei,hi,Ti,Si]);
  const mi="other_sql";
  const Ai="mssql";
  const gi="mysql";
  const Ri="oracle";
  const wh="db2";
  const Dh="postgresql";
  const Uh="redshift";
  const kh="hive";
  const Gh="cloudscape";
  const Vh="hsqldb";
  const xh="progress";
  const $h="maxdb";
  const Bh="hanadb";
  const Hh="ingres";
  const Fh="firstsql";
  const Yh="edb";
  const jh="cache";
  const qh="adabas";
  const Wh="firebird";
  const Kh="derby";
  const zh="filemaker";
  const Zh="informix";
  const Xh="instantdb";
  const Qh="interbase";
  const Jh="mariadb";
  const eT="netezza";
  const tT="pervasive";
  const nT="pointbase";
  const rT="sqlite";
  const oT="sybase";
  const sT="teradata";
  const iT="vertica";
  const aT="h2";
  const cT="coldfusion";
  const uT="cassandra";
  const lT="hbase";
  const dT="mongodb";
  const fT="redis";
  const _T="couchbase";
  const pT="couchdb";
  const ET="cosmosdb";
  const hT="dynamodb";
  const TT="neo4j";
  const ST="geode";
  const mT="elasticsearch";
  const AT="memcached";
  const gT="cockroachdb";
  S.DBSYSTEMVALUES_OTHER_SQL=mi;
  S.DBSYSTEMVALUES_MSSQL=Ai;
  S.DBSYSTEMVALUES_MYSQL=gi;
  S.DBSYSTEMVALUES_ORACLE=Ri;
  S.DBSYSTEMVALUES_DB2=wh;
  S.DBSYSTEMVALUES_POSTGRESQL=Dh;
  S.DBSYSTEMVALUES_REDSHIFT=Uh;
  S.DBSYSTEMVALUES_HIVE=kh;
  S.DBSYSTEMVALUES_CLOUDSCAPE=Gh;
  S.DBSYSTEMVALUES_HSQLDB=Vh;
  S.DBSYSTEMVALUES_PROGRESS=xh;
  S.DBSYSTEMVALUES_MAXDB=$h;
  S.DBSYSTEMVALUES_HANADB=Bh;
  S.DBSYSTEMVALUES_INGRES=Hh;
  S.DBSYSTEMVALUES_FIRSTSQL=Fh;
  S.DBSYSTEMVALUES_EDB=Yh;
  S.DBSYSTEMVALUES_CACHE=jh;
  S.DBSYSTEMVALUES_ADABAS=qh;
  S.DBSYSTEMVALUES_FIREBIRD=Wh;
  S.DBSYSTEMVALUES_DERBY=Kh;
  S.DBSYSTEMVALUES_FILEMAKER=zh;
  S.DBSYSTEMVALUES_INFORMIX=Zh;
  S.DBSYSTEMVALUES_INSTANTDB=Xh;
  S.DBSYSTEMVALUES_INTERBASE=Qh;
  S.DBSYSTEMVALUES_MARIADB=Jh;
  S.DBSYSTEMVALUES_NETEZZA=eT;
  S.DBSYSTEMVALUES_PERVASIVE=tT;
  S.DBSYSTEMVALUES_POINTBASE=nT;
  S.DBSYSTEMVALUES_SQLITE=rT;
  S.DBSYSTEMVALUES_SYBASE=oT;
  S.DBSYSTEMVALUES_TERADATA=sT;
  S.DBSYSTEMVALUES_VERTICA=iT;
  S.DBSYSTEMVALUES_H2=aT;
  S.DBSYSTEMVALUES_COLDFUSION=cT;
  S.DBSYSTEMVALUES_CASSANDRA=uT;
  S.DBSYSTEMVALUES_HBASE=lT;
  S.DBSYSTEMVALUES_MONGODB=dT;
  S.DBSYSTEMVALUES_REDIS=fT;
  S.DBSYSTEMVALUES_COUCHBASE=_T;
  S.DBSYSTEMVALUES_COUCHDB=pT;
  S.DBSYSTEMVALUES_COSMOSDB=ET;
  S.DBSYSTEMVALUES_DYNAMODB=hT;
  S.DBSYSTEMVALUES_NEO4J=TT;
  S.DBSYSTEMVALUES_GEODE=ST;
  S.DBSYSTEMVALUES_ELASTICSEARCH=mT;
  S.DBSYSTEMVALUES_MEMCACHED=AT;
  S.DBSYSTEMVALUES_COCKROACHDB=gT;
  S.DbSystemValues=(0,e.createConstMap)([mi,Ai,gi,Ri,wh,Dh,Uh,kh,Gh,Vh,xh,$h,Bh,Hh,Fh,Yh,jh,qh,Wh,Kh,zh,Zh,Xh,Qh,Jh,eT,tT,nT,rT,oT,sT,iT,aT,cT,uT,lT,dT,fT,_T,pT,ET,hT,TT,ST,mT,AT,gT]);
  const RT="all";
  const NT="each_quorum";
  const yT="quorum";
  const OT="local_quorum";
  const bT="one";
  const CT="two";
  const IT="three";
  const PT="local_one";
  const MT="any";
  const vT="serial";
  const LT="local_serial";
  S.DBCASSANDRACONSISTENCYLEVELVALUES_ALL=RT;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM=NT;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM=yT;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM=OT;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_ONE=bT;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_TWO=CT;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_THREE=IT;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE=PT;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_ANY=MT;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL=vT;
  S.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL=LT;
  S.DbCassandraConsistencyLevelValues=(0,e.createConstMap)([RT,NT,yT,OT,bT,CT,IT,PT,MT,vT,LT]);
  const wT="datasource";
  const DT="http";
  const UT="pubsub";
  const kT="timer";
  const GT="other";
  S.FAASTRIGGERVALUES_DATASOURCE=wT;
  S.FAASTRIGGERVALUES_HTTP=DT;
  S.FAASTRIGGERVALUES_PUBSUB=UT;
  S.FAASTRIGGERVALUES_TIMER=kT;
  S.FAASTRIGGERVALUES_OTHER=GT;
  S.FaasTriggerValues=(0,e.createConstMap)([wT,DT,UT,kT,GT]);
  const VT="insert";
  const xT="edit";
  const $T="delete";
  S.FAASDOCUMENTOPERATIONVALUES_INSERT=VT;
  S.FAASDOCUMENTOPERATIONVALUES_EDIT=xT;
  S.FAASDOCUMENTOPERATIONVALUES_DELETE=$T;
  S.FaasDocumentOperationValues=(0,e.createConstMap)([VT,xT,$T]);
  const BT="alibaba_cloud";
  const HT="aws";
  const FT="azure";
  const YT="gcp";
  S.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD=BT;
  S.FAASINVOKEDPROVIDERVALUES_AWS=HT;
  S.FAASINVOKEDPROVIDERVALUES_AZURE=FT;
  S.FAASINVOKEDPROVIDERVALUES_GCP=YT;
  S.FaasInvokedProviderValues=(0,e.createConstMap)([BT,HT,FT,YT]);
  const jT="ip_tcp";
  const qT="ip_udp";
  const WT="ip";
  const KT="unix";
  const zT="pipe";
  const ZT="inproc";
  const XT="other";
  S.NETTRANSPORTVALUES_IP_TCP=jT;
  S.NETTRANSPORTVALUES_IP_UDP=qT;
  S.NETTRANSPORTVALUES_IP=WT;
  S.NETTRANSPORTVALUES_UNIX=KT;
  S.NETTRANSPORTVALUES_PIPE=zT;
  S.NETTRANSPORTVALUES_INPROC=ZT;
  S.NETTRANSPORTVALUES_OTHER=XT;
  S.NetTransportValues=(0,e.createConstMap)([jT,qT,WT,KT,zT,ZT,XT]);
  const QT="wifi";
  const JT="wired";
  const eS="cell";
  const tS="unavailable";
  const nS="unknown";
  S.NETHOSTCONNECTIONTYPEVALUES_WIFI=QT;
  S.NETHOSTCONNECTIONTYPEVALUES_WIRED=JT;
  S.NETHOSTCONNECTIONTYPEVALUES_CELL=eS;
  S.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE=tS;
  S.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN=nS;
  S.NetHostConnectionTypeValues=(0,e.createConstMap)([QT,JT,eS,tS,nS]);
  const rS="gprs";
  const oS="edge";
  const sS="umts";
  const iS="cdma";
  const aS="evdo_0";
  const cS="evdo_a";
  const uS="cdma2000_1xrtt";
  const lS="hsdpa";
  const dS="hsupa";
  const fS="hspa";
  const _S="iden";
  const pS="evdo_b";
  const ES="lte";
  const hS="ehrpd";
  const TS="hspap";
  const SS="gsm";
  const mS="td_scdma";
  const AS="iwlan";
  const gS="nr";
  const RS="nrnsa";
  const NS="lte_ca";
  S.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS=rS;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE=oS;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS=sS;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA=iS;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0=aS;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A=cS;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT=uS;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA=lS;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA=dS;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA=fS;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN=_S;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B=pS;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_LTE=ES;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD=hS;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP=TS;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_GSM=SS;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA=mS;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN=AS;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_NR=gS;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA=RS;
  S.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA=NS;
  S.NetHostConnectionSubtypeValues=(0,e.createConstMap)([rS,oS,sS,iS,aS,cS,uS,lS,dS,fS,_S,pS,ES,hS,TS,SS,mS,AS,gS,RS,NS]);
  const yS="1.0";
  const OS="1.1";
  const bS="2.0";
  const CS="SPDY";
  const IS="QUIC";
  S.HTTPFLAVORVALUES_HTTP_1_0=yS;
  S.HTTPFLAVORVALUES_HTTP_1_1=OS;
  S.HTTPFLAVORVALUES_HTTP_2_0=bS;
  S.HTTPFLAVORVALUES_SPDY=CS;
  S.HTTPFLAVORVALUES_QUIC=IS;
  S.HttpFlavorValues={HTTP_1_0:yS,HTTP_1_1:OS,HTTP_2_0:bS,SPDY:CS,QUIC:IS};
  const PS="queue";
  const MS="topic";
  S.MESSAGINGDESTINATIONKINDVALUES_QUEUE=PS;
  S.MESSAGINGDESTINATIONKINDVALUES_TOPIC=MS;
  S.MessagingDestinationKindValues=(0,e.createConstMap)([PS,MS]);
  const vS="receive";
  const LS="process";
  S.MESSAGINGOPERATIONVALUES_RECEIVE=vS;
  S.MESSAGINGOPERATIONVALUES_PROCESS=LS;
  S.MessagingOperationValues=(0,e.createConstMap)([vS,LS]);
  const wS=0;
  const DS=1;
  const US=2;
  const kS=3;
  const GS=4;
  const VS=5;
  const xS=6;
  const $S=7;
  const BS=8;
  const HS=9;
  const FS=10;
  const YS=11;
  const jS=12;
  const qS=13;
  const WS=14;
  const KS=15;
  const zS=16;
  S.RPCGRPCSTATUSCODEVALUES_OK=wS;
  S.RPCGRPCSTATUSCODEVALUES_CANCELLED=DS;
  S.RPCGRPCSTATUSCODEVALUES_UNKNOWN=US;
  S.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT=kS;
  S.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED=GS;
  S.RPCGRPCSTATUSCODEVALUES_NOT_FOUND=VS;
  S.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS=xS;
  S.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED=$S;
  S.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED=BS;
  S.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION=HS;
  S.RPCGRPCSTATUSCODEVALUES_ABORTED=FS;
  S.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE=YS;
  S.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED=jS;
  S.RPCGRPCSTATUSCODEVALUES_INTERNAL=qS;
  S.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE=WS;
  S.RPCGRPCSTATUSCODEVALUES_DATA_LOSS=KS;
  S.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED=zS;
  S.RpcGrpcStatusCodeValues={OK:wS,CANCELLED:DS,UNKNOWN:US,INVALID_ARGUMENT:kS,DEADLINE_EXCEEDED:GS,NOT_FOUND:VS,ALREADY_EXISTS:xS,PERMISSION_DENIED:$S,RESOURCE_EXHAUSTED:BS,FAILED_PRECONDITION:HS,ABORTED:FS,OUT_OF_RANGE:YS,UNIMPLEMENTED:jS,INTERNAL:qS,UNAVAILABLE:WS,DATA_LOSS:KS,UNAUTHENTICATED:zS};
  const ZS="SENT";
  const XS="RECEIVED";
  S.MESSAGETYPEVALUES_SENT=ZS;
  S.MESSAGETYPEVALUES_RECEIVED=XS;
  S.MessageTypeValues=(0,e.createConstMap)([ZS,XS]);
  return S;
}let Zm;function UD(){
  if (!Zm) {
    Zm=1;

    (e => {
      const t=Ar&&Ar.__createBinding||(Object.create?((r, o, s, i = s) => {
        let a=Object.getOwnPropertyDescriptor(o,s);

        if ((!a || ("get"in a ? !o.__esModule : a.writable||a.configurable))) {
          (a = {enumerable:true,get() {return o[s]}});
        }

        Object.defineProperty(r,i,a);
      }):((r, o, s, i = s) => {
        r[i]=o[s];
      }));

      const n=Ar&&Ar.__exportStar||((r, o) => {for (const s in r) {
        if (s!=="default"&&!Object.prototype.hasOwnProperty.call(o,s)) {
          t(o,r,s);
        }
      }});

      Object.defineProperty(e,"__esModule",{value:true});
      n(DD(),e);
    })(Ar);
  }

  return Ar;
}
const gr={};
const N={};
let Xm;
function kD(){
  if (Xm) {
    return N;
  }
  Xm=1;
  Object.defineProperty(N,"__esModule",{value:true});
  N.SEMRESATTRS_K8S_STATEFULSET_NAME = void 0;
  N.SEMRESATTRS_K8S_STATEFULSET_UID = void 0;
  N.SEMRESATTRS_K8S_DEPLOYMENT_NAME = void 0;
  N.SEMRESATTRS_K8S_DEPLOYMENT_UID = void 0;
  N.SEMRESATTRS_K8S_REPLICASET_NAME = void 0;
  N.SEMRESATTRS_K8S_REPLICASET_UID = void 0;
  N.SEMRESATTRS_K8S_CONTAINER_NAME = void 0;
  N.SEMRESATTRS_K8S_POD_NAME = void 0;
  N.SEMRESATTRS_K8S_POD_UID = void 0;
  N.SEMRESATTRS_K8S_NAMESPACE_NAME = void 0;
  N.SEMRESATTRS_K8S_NODE_UID = void 0;
  N.SEMRESATTRS_K8S_NODE_NAME = void 0;
  N.SEMRESATTRS_K8S_CLUSTER_NAME = void 0;
  N.SEMRESATTRS_HOST_IMAGE_VERSION = void 0;
  N.SEMRESATTRS_HOST_IMAGE_ID = void 0;
  N.SEMRESATTRS_HOST_IMAGE_NAME = void 0;
  N.SEMRESATTRS_HOST_ARCH = void 0;
  N.SEMRESATTRS_HOST_TYPE = void 0;
  N.SEMRESATTRS_HOST_NAME = void 0;
  N.SEMRESATTRS_HOST_ID = void 0;
  N.SEMRESATTRS_FAAS_MAX_MEMORY = void 0;
  N.SEMRESATTRS_FAAS_INSTANCE = void 0;
  N.SEMRESATTRS_FAAS_VERSION = void 0;
  N.SEMRESATTRS_FAAS_ID = void 0;
  N.SEMRESATTRS_FAAS_NAME = void 0;
  N.SEMRESATTRS_DEVICE_MODEL_NAME = void 0;
  N.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = void 0;
  N.SEMRESATTRS_DEVICE_ID = void 0;
  N.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = void 0;
  N.SEMRESATTRS_CONTAINER_IMAGE_TAG = void 0;
  N.SEMRESATTRS_CONTAINER_IMAGE_NAME = void 0;
  N.SEMRESATTRS_CONTAINER_RUNTIME = void 0;
  N.SEMRESATTRS_CONTAINER_ID = void 0;
  N.SEMRESATTRS_CONTAINER_NAME = void 0;
  N.SEMRESATTRS_AWS_LOG_STREAM_ARNS = void 0;
  N.SEMRESATTRS_AWS_LOG_STREAM_NAMES = void 0;
  N.SEMRESATTRS_AWS_LOG_GROUP_ARNS = void 0;
  N.SEMRESATTRS_AWS_LOG_GROUP_NAMES = void 0;
  N.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = void 0;
  N.SEMRESATTRS_AWS_ECS_TASK_REVISION = void 0;
  N.SEMRESATTRS_AWS_ECS_TASK_FAMILY = void 0;
  N.SEMRESATTRS_AWS_ECS_TASK_ARN = void 0;
  N.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = void 0;
  N.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = void 0;
  N.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = void 0;
  N.SEMRESATTRS_CLOUD_PLATFORM = void 0;
  N.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = void 0;
  N.SEMRESATTRS_CLOUD_REGION = void 0;
  N.SEMRESATTRS_CLOUD_ACCOUNT_ID = void 0;
  N.SEMRESATTRS_CLOUD_PROVIDER = void 0;
  N.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = void 0;
  N.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = void 0;
  N.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = void 0;
  N.CLOUDPLATFORMVALUES_AZURE_AKS = void 0;
  N.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = void 0;
  N.CLOUDPLATFORMVALUES_AZURE_VM = void 0;
  N.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = void 0;
  N.CLOUDPLATFORMVALUES_AWS_LAMBDA = void 0;
  N.CLOUDPLATFORMVALUES_AWS_EKS = void 0;
  N.CLOUDPLATFORMVALUES_AWS_ECS = void 0;
  N.CLOUDPLATFORMVALUES_AWS_EC2 = void 0;
  N.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = void 0;
  N.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = void 0;
  N.CloudProviderValues = void 0;
  N.CLOUDPROVIDERVALUES_GCP = void 0;
  N.CLOUDPROVIDERVALUES_AZURE = void 0;
  N.CLOUDPROVIDERVALUES_AWS = void 0;
  N.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = void 0;
  N.SemanticResourceAttributes = void 0;
  N.SEMRESATTRS_WEBENGINE_DESCRIPTION = void 0;
  N.SEMRESATTRS_WEBENGINE_VERSION = void 0;
  N.SEMRESATTRS_WEBENGINE_NAME = void 0;
  N.SEMRESATTRS_TELEMETRY_AUTO_VERSION = void 0;
  N.SEMRESATTRS_TELEMETRY_SDK_VERSION = void 0;
  N.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = void 0;
  N.SEMRESATTRS_TELEMETRY_SDK_NAME = void 0;
  N.SEMRESATTRS_SERVICE_VERSION = void 0;
  N.SEMRESATTRS_SERVICE_INSTANCE_ID = void 0;
  N.SEMRESATTRS_SERVICE_NAMESPACE = void 0;
  N.SEMRESATTRS_SERVICE_NAME = void 0;
  N.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = void 0;
  N.SEMRESATTRS_PROCESS_RUNTIME_VERSION = void 0;
  N.SEMRESATTRS_PROCESS_RUNTIME_NAME = void 0;
  N.SEMRESATTRS_PROCESS_OWNER = void 0;
  N.SEMRESATTRS_PROCESS_COMMAND_ARGS = void 0;
  N.SEMRESATTRS_PROCESS_COMMAND_LINE = void 0;
  N.SEMRESATTRS_PROCESS_COMMAND = void 0;
  N.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = void 0;
  N.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = void 0;
  N.SEMRESATTRS_PROCESS_PID = void 0;
  N.SEMRESATTRS_OS_VERSION = void 0;
  N.SEMRESATTRS_OS_NAME = void 0;
  N.SEMRESATTRS_OS_DESCRIPTION = void 0;
  N.SEMRESATTRS_OS_TYPE = void 0;
  N.SEMRESATTRS_K8S_CRONJOB_NAME = void 0;
  N.SEMRESATTRS_K8S_CRONJOB_UID = void 0;
  N.SEMRESATTRS_K8S_JOB_NAME = void 0;
  N.SEMRESATTRS_K8S_JOB_UID = void 0;
  N.SEMRESATTRS_K8S_DAEMONSET_NAME = void 0;
  N.SEMRESATTRS_K8S_DAEMONSET_UID = void 0;
  N.TelemetrySdkLanguageValues = void 0;
  N.TELEMETRYSDKLANGUAGEVALUES_WEBJS = void 0;
  N.TELEMETRYSDKLANGUAGEVALUES_RUBY = void 0;
  N.TELEMETRYSDKLANGUAGEVALUES_PYTHON = void 0;
  N.TELEMETRYSDKLANGUAGEVALUES_PHP = void 0;
  N.TELEMETRYSDKLANGUAGEVALUES_NODEJS = void 0;
  N.TELEMETRYSDKLANGUAGEVALUES_JAVA = void 0;
  N.TELEMETRYSDKLANGUAGEVALUES_GO = void 0;
  N.TELEMETRYSDKLANGUAGEVALUES_ERLANG = void 0;
  N.TELEMETRYSDKLANGUAGEVALUES_DOTNET = void 0;
  N.TELEMETRYSDKLANGUAGEVALUES_CPP = void 0;
  N.OsTypeValues = void 0;
  N.OSTYPEVALUES_Z_OS = void 0;
  N.OSTYPEVALUES_SOLARIS = void 0;
  N.OSTYPEVALUES_AIX = void 0;
  N.OSTYPEVALUES_HPUX = void 0;
  N.OSTYPEVALUES_DRAGONFLYBSD = void 0;
  N.OSTYPEVALUES_OPENBSD = void 0;
  N.OSTYPEVALUES_NETBSD = void 0;
  N.OSTYPEVALUES_FREEBSD = void 0;
  N.OSTYPEVALUES_DARWIN = void 0;
  N.OSTYPEVALUES_LINUX = void 0;
  N.OSTYPEVALUES_WINDOWS = void 0;
  N.HostArchValues = void 0;
  N.HOSTARCHVALUES_X86 = void 0;
  N.HOSTARCHVALUES_PPC64 = void 0;
  N.HOSTARCHVALUES_PPC32 = void 0;
  N.HOSTARCHVALUES_IA64 = void 0;
  N.HOSTARCHVALUES_ARM64 = void 0;
  N.HOSTARCHVALUES_ARM32 = void 0;
  N.HOSTARCHVALUES_AMD64 = void 0;
  N.AwsEcsLaunchtypeValues = void 0;
  N.AWSECSLAUNCHTYPEVALUES_FARGATE = void 0;
  N.AWSECSLAUNCHTYPEVALUES_EC2 = void 0;
  N.CloudPlatformValues = void 0;
  N.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = void 0;
  N.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = void 0;
  N.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = void 0;
  N.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = void 0;
  const e=sI();
  const t="cloud.provider";
  const n="cloud.account.id";
  const r="cloud.region";
  const o="cloud.availability_zone";
  const s="cloud.platform";
  const i="aws.ecs.container.arn";
  const a="aws.ecs.cluster.arn";
  const c="aws.ecs.launchtype";
  const l="aws.ecs.task.arn";
  const f="aws.ecs.task.family";
  const d="aws.ecs.task.revision";
  const u="aws.eks.cluster.arn";
  const _="aws.log.group.names";
  const p="aws.log.group.arns";
  const E="aws.log.stream.names";
  const h="aws.log.stream.arns";
  const T="container.name";
  const m="container.id";
  const A="container.runtime";
  const g="container.image.name";
  const R="container.image.tag";
  const O="deployment.environment";
  const I="device.id";
  const b="device.model.identifier";
  const L="device.model.name";
  const U="faas.name";
  const q="faas.id";
  const H="faas.version";
  const $="faas.instance";
  const B="faas.max_memory";
  const F="host.id";
  const D="host.name";
  const k="host.type";
  const Y="host.arch";
  const oe="host.image.name";
  const ae="host.image.id";
  const ne="host.image.version";
  const P="k8s.cluster.name";
  const M="k8s.node.name";
  const G="k8s.node.uid";
  const V="k8s.namespace.name";
  const K="k8s.pod.uid";
  const X="k8s.pod.name";
  const v="k8s.container.name";
  const w="k8s.replicaset.uid";
  const z="k8s.replicaset.name";
  const j="k8s.deployment.uid";
  const ee="k8s.deployment.name";
  const te="k8s.statefulset.uid";
  const _e="k8s.statefulset.name";
  const se="k8s.daemonset.uid";
  const ue="k8s.daemonset.name";
  const Te="k8s.job.uid";
  const ve="k8s.job.name";
  const we="k8s.cronjob.uid";
  const qe="k8s.cronjob.name";
  const Mt="os.type";
  const it="os.description";
  const at="os.name";
  const nt="os.version";
  const ss="process.pid";
  const is="process.executable.name";
  const as="process.executable.path";
  const cs="process.command";
  const us="process.command_line";
  const ls="process.command_args";
  const ds="process.owner";
  const fs="process.runtime.name";
  const _s="process.runtime.version";
  const ps="process.runtime.description";
  const Es="service.name";
  const hs="service.namespace";
  const Ts="service.instance.id";
  const Ss="service.version";
  const ms="telemetry.sdk.name";
  const As="telemetry.sdk.language";
  const gs="telemetry.sdk.version";
  const Rs="telemetry.auto.version";
  const Ns="webengine.name";
  const ys="webengine.version";
  const Os="webengine.description";
  N.SEMRESATTRS_CLOUD_PROVIDER=t;
  N.SEMRESATTRS_CLOUD_ACCOUNT_ID=n;
  N.SEMRESATTRS_CLOUD_REGION=r;
  N.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE=o;
  N.SEMRESATTRS_CLOUD_PLATFORM=s;
  N.SEMRESATTRS_AWS_ECS_CONTAINER_ARN=i;
  N.SEMRESATTRS_AWS_ECS_CLUSTER_ARN=a;
  N.SEMRESATTRS_AWS_ECS_LAUNCHTYPE=c;
  N.SEMRESATTRS_AWS_ECS_TASK_ARN=l;
  N.SEMRESATTRS_AWS_ECS_TASK_FAMILY=f;
  N.SEMRESATTRS_AWS_ECS_TASK_REVISION=d;
  N.SEMRESATTRS_AWS_EKS_CLUSTER_ARN=u;
  N.SEMRESATTRS_AWS_LOG_GROUP_NAMES=_;
  N.SEMRESATTRS_AWS_LOG_GROUP_ARNS=p;
  N.SEMRESATTRS_AWS_LOG_STREAM_NAMES=E;
  N.SEMRESATTRS_AWS_LOG_STREAM_ARNS=h;
  N.SEMRESATTRS_CONTAINER_NAME=T;
  N.SEMRESATTRS_CONTAINER_ID=m;
  N.SEMRESATTRS_CONTAINER_RUNTIME=A;
  N.SEMRESATTRS_CONTAINER_IMAGE_NAME=g;
  N.SEMRESATTRS_CONTAINER_IMAGE_TAG=R;
  N.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT=O;
  N.SEMRESATTRS_DEVICE_ID=I;
  N.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER=b;
  N.SEMRESATTRS_DEVICE_MODEL_NAME=L;
  N.SEMRESATTRS_FAAS_NAME=U;
  N.SEMRESATTRS_FAAS_ID=q;
  N.SEMRESATTRS_FAAS_VERSION=H;
  N.SEMRESATTRS_FAAS_INSTANCE=$;
  N.SEMRESATTRS_FAAS_MAX_MEMORY=B;
  N.SEMRESATTRS_HOST_ID=F;
  N.SEMRESATTRS_HOST_NAME=D;
  N.SEMRESATTRS_HOST_TYPE=k;
  N.SEMRESATTRS_HOST_ARCH=Y;
  N.SEMRESATTRS_HOST_IMAGE_NAME=oe;
  N.SEMRESATTRS_HOST_IMAGE_ID=ae;
  N.SEMRESATTRS_HOST_IMAGE_VERSION=ne;
  N.SEMRESATTRS_K8S_CLUSTER_NAME=P;
  N.SEMRESATTRS_K8S_NODE_NAME=M;
  N.SEMRESATTRS_K8S_NODE_UID=G;
  N.SEMRESATTRS_K8S_NAMESPACE_NAME=V;
  N.SEMRESATTRS_K8S_POD_UID=K;
  N.SEMRESATTRS_K8S_POD_NAME=X;
  N.SEMRESATTRS_K8S_CONTAINER_NAME=v;
  N.SEMRESATTRS_K8S_REPLICASET_UID=w;
  N.SEMRESATTRS_K8S_REPLICASET_NAME=z;
  N.SEMRESATTRS_K8S_DEPLOYMENT_UID=j;
  N.SEMRESATTRS_K8S_DEPLOYMENT_NAME=ee;
  N.SEMRESATTRS_K8S_STATEFULSET_UID=te;
  N.SEMRESATTRS_K8S_STATEFULSET_NAME=_e;
  N.SEMRESATTRS_K8S_DAEMONSET_UID=se;
  N.SEMRESATTRS_K8S_DAEMONSET_NAME=ue;
  N.SEMRESATTRS_K8S_JOB_UID=Te;
  N.SEMRESATTRS_K8S_JOB_NAME=ve;
  N.SEMRESATTRS_K8S_CRONJOB_UID=we;
  N.SEMRESATTRS_K8S_CRONJOB_NAME=qe;
  N.SEMRESATTRS_OS_TYPE=Mt;
  N.SEMRESATTRS_OS_DESCRIPTION=it;
  N.SEMRESATTRS_OS_NAME=at;
  N.SEMRESATTRS_OS_VERSION=nt;
  N.SEMRESATTRS_PROCESS_PID=ss;
  N.SEMRESATTRS_PROCESS_EXECUTABLE_NAME=is;
  N.SEMRESATTRS_PROCESS_EXECUTABLE_PATH=as;
  N.SEMRESATTRS_PROCESS_COMMAND=cs;
  N.SEMRESATTRS_PROCESS_COMMAND_LINE=us;
  N.SEMRESATTRS_PROCESS_COMMAND_ARGS=ls;
  N.SEMRESATTRS_PROCESS_OWNER=ds;
  N.SEMRESATTRS_PROCESS_RUNTIME_NAME=fs;
  N.SEMRESATTRS_PROCESS_RUNTIME_VERSION=_s;
  N.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION=ps;
  N.SEMRESATTRS_SERVICE_NAME=Es;
  N.SEMRESATTRS_SERVICE_NAMESPACE=hs;
  N.SEMRESATTRS_SERVICE_INSTANCE_ID=Ts;
  N.SEMRESATTRS_SERVICE_VERSION=Ss;
  N.SEMRESATTRS_TELEMETRY_SDK_NAME=ms;
  N.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE=As;
  N.SEMRESATTRS_TELEMETRY_SDK_VERSION=gs;
  N.SEMRESATTRS_TELEMETRY_AUTO_VERSION=Rs;
  N.SEMRESATTRS_WEBENGINE_NAME=Ns;
  N.SEMRESATTRS_WEBENGINE_VERSION=ys;
  N.SEMRESATTRS_WEBENGINE_DESCRIPTION=Os;
  N.SemanticResourceAttributes=(0,e.createConstMap)([t,n,r,o,s,i,a,c,l,f,d,u,_,p,E,h,T,m,A,g,R,O,I,b,L,U,q,H,$,B,F,D,k,Y,oe,ae,ne,P,M,G,V,K,X,v,w,z,j,ee,te,_e,se,ue,Te,ve,we,qe,Mt,it,at,nt,ss,is,as,cs,us,ls,ds,fs,_s,ps,Es,hs,Ts,Ss,ms,As,gs,Rs,Ns,ys,Os]);
  const bs="alibaba_cloud";
  const Cs="aws";
  const Is="azure";
  const Ps="gcp";
  N.CLOUDPROVIDERVALUES_ALIBABA_CLOUD=bs;
  N.CLOUDPROVIDERVALUES_AWS=Cs;
  N.CLOUDPROVIDERVALUES_AZURE=Is;
  N.CLOUDPROVIDERVALUES_GCP=Ps;
  N.CloudProviderValues=(0,e.createConstMap)([bs,Cs,Is,Ps]);
  const Ms="alibaba_cloud_ecs";
  const vs="alibaba_cloud_fc";
  const Ls="aws_ec2";
  const ws="aws_ecs";
  const Ds="aws_eks";
  const Us="aws_lambda";
  const ks="aws_elastic_beanstalk";
  const Gs="azure_vm";
  const Vs="azure_container_instances";
  const xs="azure_aks";
  const $s="azure_functions";
  const Bs="azure_app_service";
  const Hs="gcp_compute_engine";
  const Fs="gcp_cloud_run";
  const Ys="gcp_kubernetes_engine";
  const js="gcp_cloud_functions";
  const qs="gcp_app_engine";
  N.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS=Ms;
  N.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC=vs;
  N.CLOUDPLATFORMVALUES_AWS_EC2=Ls;
  N.CLOUDPLATFORMVALUES_AWS_ECS=ws;
  N.CLOUDPLATFORMVALUES_AWS_EKS=Ds;
  N.CLOUDPLATFORMVALUES_AWS_LAMBDA=Us;
  N.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK=ks;
  N.CLOUDPLATFORMVALUES_AZURE_VM=Gs;
  N.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES=Vs;
  N.CLOUDPLATFORMVALUES_AZURE_AKS=xs;
  N.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS=$s;
  N.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE=Bs;
  N.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE=Hs;
  N.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN=Fs;
  N.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE=Ys;
  N.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS=js;
  N.CLOUDPLATFORMVALUES_GCP_APP_ENGINE=qs;
  N.CloudPlatformValues=(0,e.createConstMap)([Ms,vs,Ls,ws,Ds,Us,ks,Gs,Vs,xs,$s,Bs,Hs,Fs,Ys,js,qs]);
  const Ws="ec2";
  const Ks="fargate";
  N.AWSECSLAUNCHTYPEVALUES_EC2=Ws;
  N.AWSECSLAUNCHTYPEVALUES_FARGATE=Ks;
  N.AwsEcsLaunchtypeValues=(0,e.createConstMap)([Ws,Ks]);
  const zs="amd64";
  const Zs="arm32";
  const Xs="arm64";
  const Qs="ia64";
  const Js="ppc32";
  const ei="ppc64";
  const ti="x86";
  N.HOSTARCHVALUES_AMD64=zs;
  N.HOSTARCHVALUES_ARM32=Zs;
  N.HOSTARCHVALUES_ARM64=Xs;
  N.HOSTARCHVALUES_IA64=Qs;
  N.HOSTARCHVALUES_PPC32=Js;
  N.HOSTARCHVALUES_PPC64=ei;
  N.HOSTARCHVALUES_X86=ti;
  N.HostArchValues=(0,e.createConstMap)([zs,Zs,Xs,Qs,Js,ei,ti]);
  const ni="windows";
  const ri="linux";
  const oi="darwin";
  const si="freebsd";
  const ii="netbsd";
  const ai="openbsd";
  const ci="dragonflybsd";
  const ui="hpux";
  const li="aix";
  const di="solaris";
  const fi="z_os";
  N.OSTYPEVALUES_WINDOWS=ni;
  N.OSTYPEVALUES_LINUX=ri;
  N.OSTYPEVALUES_DARWIN=oi;
  N.OSTYPEVALUES_FREEBSD=si;
  N.OSTYPEVALUES_NETBSD=ii;
  N.OSTYPEVALUES_OPENBSD=ai;
  N.OSTYPEVALUES_DRAGONFLYBSD=ci;
  N.OSTYPEVALUES_HPUX=ui;
  N.OSTYPEVALUES_AIX=li;
  N.OSTYPEVALUES_SOLARIS=di;
  N.OSTYPEVALUES_Z_OS=fi;
  N.OsTypeValues=(0,e.createConstMap)([ni,ri,oi,si,ii,ai,ci,ui,li,di,fi]);
  const _i="cpp";
  const pi="dotnet";
  const Ei="erlang";
  const hi="go";
  const Ti="java";
  const Si="nodejs";
  const mi="php";
  const Ai="python";
  const gi="ruby";
  const Ri="webjs";
  N.TELEMETRYSDKLANGUAGEVALUES_CPP=_i;
  N.TELEMETRYSDKLANGUAGEVALUES_DOTNET=pi;
  N.TELEMETRYSDKLANGUAGEVALUES_ERLANG=Ei;
  N.TELEMETRYSDKLANGUAGEVALUES_GO=hi;
  N.TELEMETRYSDKLANGUAGEVALUES_JAVA=Ti;
  N.TELEMETRYSDKLANGUAGEVALUES_NODEJS=Si;
  N.TELEMETRYSDKLANGUAGEVALUES_PHP=mi;
  N.TELEMETRYSDKLANGUAGEVALUES_PYTHON=Ai;
  N.TELEMETRYSDKLANGUAGEVALUES_RUBY=gi;
  N.TELEMETRYSDKLANGUAGEVALUES_WEBJS=Ri;
  N.TelemetrySdkLanguageValues=(0,e.createConstMap)([_i,pi,Ei,hi,Ti,Si,mi,Ai,gi,Ri]);
  return N;
}let Qm;function GD(){
  if (!Qm) {
    Qm=1;

    (e => {
      const t=gr&&gr.__createBinding||(Object.create?((r, o, s, i = s) => {
        let a=Object.getOwnPropertyDescriptor(o,s);

        if ((!a || ("get"in a ? !o.__esModule : a.writable||a.configurable))) {
          (a = {enumerable:true,get() {return o[s]}});
        }

        Object.defineProperty(r,i,a);
      }):((r, o, s, i = s) => {
        r[i]=o[s];
      }));

      const n=gr&&gr.__exportStar||((r, o) => {for (const s in r) {
        if (s!=="default"&&!Object.prototype.hasOwnProperty.call(o,s)) {
          t(o,r,s);
        }
      }});

      Object.defineProperty(e,"__esModule",{value:true});
      n(kD(),e);
    })(gr);
  }

  return gr;
}
const y={};
let Jm;
function VD(){
  if (Jm) {
    return y;
  }
  Jm=1;
  Object.defineProperty(y,"__esModule",{value:true});
  y.ATTR_EXCEPTION_TYPE = void 0;
  y.ATTR_EXCEPTION_STACKTRACE = void 0;
  y.ATTR_EXCEPTION_MESSAGE = void 0;
  y.ATTR_EXCEPTION_ESCAPED = void 0;
  y.ERROR_TYPE_VALUE_OTHER = void 0;
  y.ATTR_ERROR_TYPE = void 0;
  y.DOTNET_GC_HEAP_GENERATION_VALUE_POH = void 0;
  y.DOTNET_GC_HEAP_GENERATION_VALUE_LOH = void 0;
  y.DOTNET_GC_HEAP_GENERATION_VALUE_GEN2 = void 0;
  y.DOTNET_GC_HEAP_GENERATION_VALUE_GEN1 = void 0;
  y.DOTNET_GC_HEAP_GENERATION_VALUE_GEN0 = void 0;
  y.ATTR_DOTNET_GC_HEAP_GENERATION = void 0;
  y.DB_SYSTEM_NAME_VALUE_POSTGRESQL = void 0;
  y.DB_SYSTEM_NAME_VALUE_MYSQL = void 0;
  y.DB_SYSTEM_NAME_VALUE_MICROSOFT_SQL_SERVER = void 0;
  y.DB_SYSTEM_NAME_VALUE_MARIADB = void 0;
  y.ATTR_DB_SYSTEM_NAME = void 0;
  y.ATTR_DB_STORED_PROCEDURE_NAME = void 0;
  y.ATTR_DB_RESPONSE_STATUS_CODE = void 0;
  y.ATTR_DB_QUERY_TEXT = void 0;
  y.ATTR_DB_QUERY_SUMMARY = void 0;
  y.ATTR_DB_OPERATION_NAME = void 0;
  y.ATTR_DB_OPERATION_BATCH_SIZE = void 0;
  y.ATTR_DB_NAMESPACE = void 0;
  y.ATTR_DB_COLLECTION_NAME = void 0;
  y.ATTR_CODE_STACKTRACE = void 0;
  y.ATTR_CODE_LINE_NUMBER = void 0;
  y.ATTR_CODE_FUNCTION_NAME = void 0;
  y.ATTR_CODE_FILE_PATH = void 0;
  y.ATTR_CODE_COLUMN_NUMBER = void 0;
  y.ATTR_CLIENT_PORT = void 0;
  y.ATTR_CLIENT_ADDRESS = void 0;
  y.ATTR_ASPNETCORE_USER_IS_AUTHENTICATED = void 0;
  y.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = void 0;
  y.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = void 0;
  y.ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = void 0;
  y.ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = void 0;
  y.ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = void 0;
  y.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = void 0;
  y.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = void 0;
  y.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = void 0;
  y.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = void 0;
  y.ATTR_ASPNETCORE_RATE_LIMITING_RESULT = void 0;
  y.ATTR_ASPNETCORE_RATE_LIMITING_POLICY = void 0;
  y.ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = void 0;
  y.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = void 0;
  y.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = void 0;
  y.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = void 0;
  y.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = void 0;
  y.ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = void 0;
  y.OTEL_STATUS_CODE_VALUE_ERROR = void 0;
  y.ATTR_OTEL_STATUS_CODE = void 0;
  y.ATTR_OTEL_SCOPE_VERSION = void 0;
  y.ATTR_OTEL_SCOPE_NAME = void 0;
  y.NETWORK_TYPE_VALUE_IPV6 = void 0;
  y.NETWORK_TYPE_VALUE_IPV4 = void 0;
  y.ATTR_NETWORK_TYPE = void 0;
  y.NETWORK_TRANSPORT_VALUE_UNIX = void 0;
  y.NETWORK_TRANSPORT_VALUE_UDP = void 0;
  y.NETWORK_TRANSPORT_VALUE_TCP = void 0;
  y.NETWORK_TRANSPORT_VALUE_QUIC = void 0;
  y.NETWORK_TRANSPORT_VALUE_PIPE = void 0;
  y.ATTR_NETWORK_TRANSPORT = void 0;
  y.ATTR_NETWORK_PROTOCOL_VERSION = void 0;
  y.ATTR_NETWORK_PROTOCOL_NAME = void 0;
  y.ATTR_NETWORK_PEER_PORT = void 0;
  y.ATTR_NETWORK_PEER_ADDRESS = void 0;
  y.ATTR_NETWORK_LOCAL_PORT = void 0;
  y.ATTR_NETWORK_LOCAL_ADDRESS = void 0;
  y.JVM_THREAD_STATE_VALUE_WAITING = void 0;
  y.JVM_THREAD_STATE_VALUE_TIMED_WAITING = void 0;
  y.JVM_THREAD_STATE_VALUE_TERMINATED = void 0;
  y.JVM_THREAD_STATE_VALUE_RUNNABLE = void 0;
  y.JVM_THREAD_STATE_VALUE_NEW = void 0;
  y.JVM_THREAD_STATE_VALUE_BLOCKED = void 0;
  y.ATTR_JVM_THREAD_STATE = void 0;
  y.ATTR_JVM_THREAD_DAEMON = void 0;
  y.JVM_MEMORY_TYPE_VALUE_NON_HEAP = void 0;
  y.JVM_MEMORY_TYPE_VALUE_HEAP = void 0;
  y.ATTR_JVM_MEMORY_TYPE = void 0;
  y.ATTR_JVM_MEMORY_POOL_NAME = void 0;
  y.ATTR_JVM_GC_NAME = void 0;
  y.ATTR_JVM_GC_ACTION = void 0;
  y.ATTR_HTTP_ROUTE = void 0;
  y.ATTR_HTTP_RESPONSE_STATUS_CODE = void 0;
  y.ATTR_HTTP_RESPONSE_HEADER = void 0;
  y.ATTR_HTTP_REQUEST_RESEND_COUNT = void 0;
  y.ATTR_HTTP_REQUEST_METHOD_ORIGINAL = void 0;
  y.HTTP_REQUEST_METHOD_VALUE_TRACE = void 0;
  y.HTTP_REQUEST_METHOD_VALUE_PUT = void 0;
  y.HTTP_REQUEST_METHOD_VALUE_POST = void 0;
  y.HTTP_REQUEST_METHOD_VALUE_PATCH = void 0;
  y.HTTP_REQUEST_METHOD_VALUE_OPTIONS = void 0;
  y.HTTP_REQUEST_METHOD_VALUE_HEAD = void 0;
  y.HTTP_REQUEST_METHOD_VALUE_GET = void 0;
  y.HTTP_REQUEST_METHOD_VALUE_DELETE = void 0;
  y.HTTP_REQUEST_METHOD_VALUE_CONNECT = void 0;
  y.HTTP_REQUEST_METHOD_VALUE_OTHER = void 0;
  y.ATTR_HTTP_REQUEST_METHOD = void 0;
  y.ATTR_HTTP_REQUEST_HEADER = void 0;
  y.ATTR_USER_AGENT_ORIGINAL = void 0;
  y.ATTR_URL_SCHEME = void 0;
  y.ATTR_URL_QUERY = void 0;
  y.ATTR_URL_PATH = void 0;
  y.ATTR_URL_FULL = void 0;
  y.ATTR_URL_FRAGMENT = void 0;
  y.ATTR_TELEMETRY_SDK_VERSION = void 0;
  y.ATTR_TELEMETRY_SDK_NAME = void 0;
  y.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = void 0;
  y.TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = void 0;
  y.TELEMETRY_SDK_LANGUAGE_VALUE_RUST = void 0;
  y.TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = void 0;
  y.TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = void 0;
  y.TELEMETRY_SDK_LANGUAGE_VALUE_PHP = void 0;
  y.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = void 0;
  y.TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = void 0;
  y.TELEMETRY_SDK_LANGUAGE_VALUE_GO = void 0;
  y.TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = void 0;
  y.TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = void 0;
  y.TELEMETRY_SDK_LANGUAGE_VALUE_CPP = void 0;
  y.ATTR_TELEMETRY_SDK_LANGUAGE = void 0;
  y.SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = void 0;
  y.SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = void 0;
  y.SIGNALR_TRANSPORT_VALUE_LONG_POLLING = void 0;
  y.ATTR_SIGNALR_TRANSPORT = void 0;
  y.SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = void 0;
  y.SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = void 0;
  y.SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = void 0;
  y.ATTR_SIGNALR_CONNECTION_STATUS = void 0;
  y.ATTR_SERVICE_VERSION = void 0;
  y.ATTR_SERVICE_NAME = void 0;
  y.ATTR_SERVER_PORT = void 0;
  y.ATTR_SERVER_ADDRESS = void 0;
  y.ATTR_OTEL_STATUS_DESCRIPTION = void 0;
  y.OTEL_STATUS_CODE_VALUE_OK = void 0;
  y.ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT="aspnetcore.diagnostics.exception.result";
  y.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED="aborted";
  y.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED="handled";
  y.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED="skipped";
  y.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED="unhandled";
  y.ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE="aspnetcore.diagnostics.handler.type";
  y.ATTR_ASPNETCORE_RATE_LIMITING_POLICY="aspnetcore.rate_limiting.policy";
  y.ATTR_ASPNETCORE_RATE_LIMITING_RESULT="aspnetcore.rate_limiting.result";
  y.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED="acquired";
  y.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER="endpoint_limiter";
  y.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER="global_limiter";
  y.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED="request_canceled";
  y.ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED="aspnetcore.request.is_unhandled";
  y.ATTR_ASPNETCORE_ROUTING_IS_FALLBACK="aspnetcore.routing.is_fallback";
  y.ATTR_ASPNETCORE_ROUTING_MATCH_STATUS="aspnetcore.routing.match_status";
  y.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE="failure";
  y.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS="success";
  y.ATTR_ASPNETCORE_USER_IS_AUTHENTICATED="aspnetcore.user.is_authenticated";
  y.ATTR_CLIENT_ADDRESS="client.address";
  y.ATTR_CLIENT_PORT="client.port";
  y.ATTR_CODE_COLUMN_NUMBER="code.column.number";
  y.ATTR_CODE_FILE_PATH="code.file.path";
  y.ATTR_CODE_FUNCTION_NAME="code.function.name";
  y.ATTR_CODE_LINE_NUMBER="code.line.number";
  y.ATTR_CODE_STACKTRACE="code.stacktrace";
  y.ATTR_DB_COLLECTION_NAME="db.collection.name";
  y.ATTR_DB_NAMESPACE="db.namespace";
  y.ATTR_DB_OPERATION_BATCH_SIZE="db.operation.batch.size";
  y.ATTR_DB_OPERATION_NAME="db.operation.name";
  y.ATTR_DB_QUERY_SUMMARY="db.query.summary";
  y.ATTR_DB_QUERY_TEXT="db.query.text";
  y.ATTR_DB_RESPONSE_STATUS_CODE="db.response.status_code";
  y.ATTR_DB_STORED_PROCEDURE_NAME="db.stored_procedure.name";
  y.ATTR_DB_SYSTEM_NAME="db.system.name";
  y.DB_SYSTEM_NAME_VALUE_MARIADB="mariadb";
  y.DB_SYSTEM_NAME_VALUE_MICROSOFT_SQL_SERVER="microsoft.sql_server";
  y.DB_SYSTEM_NAME_VALUE_MYSQL="mysql";
  y.DB_SYSTEM_NAME_VALUE_POSTGRESQL="postgresql";
  y.ATTR_DOTNET_GC_HEAP_GENERATION="dotnet.gc.heap.generation";
  y.DOTNET_GC_HEAP_GENERATION_VALUE_GEN0="gen0";
  y.DOTNET_GC_HEAP_GENERATION_VALUE_GEN1="gen1";
  y.DOTNET_GC_HEAP_GENERATION_VALUE_GEN2="gen2";
  y.DOTNET_GC_HEAP_GENERATION_VALUE_LOH="loh";
  y.DOTNET_GC_HEAP_GENERATION_VALUE_POH="poh";
  y.ATTR_ERROR_TYPE="error.type";
  y.ERROR_TYPE_VALUE_OTHER="_OTHER";
  y.ATTR_EXCEPTION_ESCAPED="exception.escaped";
  y.ATTR_EXCEPTION_MESSAGE="exception.message";
  y.ATTR_EXCEPTION_STACKTRACE="exception.stacktrace";
  y.ATTR_EXCEPTION_TYPE="exception.type";
  const e=n => `http.request.header.${n}`;
  y.ATTR_HTTP_REQUEST_HEADER=e;
  y.ATTR_HTTP_REQUEST_METHOD="http.request.method";
  y.HTTP_REQUEST_METHOD_VALUE_OTHER="_OTHER";
  y.HTTP_REQUEST_METHOD_VALUE_CONNECT="CONNECT";
  y.HTTP_REQUEST_METHOD_VALUE_DELETE="DELETE";
  y.HTTP_REQUEST_METHOD_VALUE_GET="GET";
  y.HTTP_REQUEST_METHOD_VALUE_HEAD="HEAD";
  y.HTTP_REQUEST_METHOD_VALUE_OPTIONS="OPTIONS";
  y.HTTP_REQUEST_METHOD_VALUE_PATCH="PATCH";
  y.HTTP_REQUEST_METHOD_VALUE_POST="POST";
  y.HTTP_REQUEST_METHOD_VALUE_PUT="PUT";
  y.HTTP_REQUEST_METHOD_VALUE_TRACE="TRACE";
  y.ATTR_HTTP_REQUEST_METHOD_ORIGINAL="http.request.method_original";
  y.ATTR_HTTP_REQUEST_RESEND_COUNT="http.request.resend_count";
  const t=n => `http.response.header.${n}`;
  y.ATTR_HTTP_RESPONSE_HEADER=t;
  y.ATTR_HTTP_RESPONSE_STATUS_CODE="http.response.status_code";
  y.ATTR_HTTP_ROUTE="http.route";
  y.ATTR_JVM_GC_ACTION="jvm.gc.action";
  y.ATTR_JVM_GC_NAME="jvm.gc.name";
  y.ATTR_JVM_MEMORY_POOL_NAME="jvm.memory.pool.name";
  y.ATTR_JVM_MEMORY_TYPE="jvm.memory.type";
  y.JVM_MEMORY_TYPE_VALUE_HEAP="heap";
  y.JVM_MEMORY_TYPE_VALUE_NON_HEAP="non_heap";
  y.ATTR_JVM_THREAD_DAEMON="jvm.thread.daemon";
  y.ATTR_JVM_THREAD_STATE="jvm.thread.state";
  y.JVM_THREAD_STATE_VALUE_BLOCKED="blocked";
  y.JVM_THREAD_STATE_VALUE_NEW="new";
  y.JVM_THREAD_STATE_VALUE_RUNNABLE="runnable";
  y.JVM_THREAD_STATE_VALUE_TERMINATED="terminated";
  y.JVM_THREAD_STATE_VALUE_TIMED_WAITING="timed_waiting";
  y.JVM_THREAD_STATE_VALUE_WAITING="waiting";
  y.ATTR_NETWORK_LOCAL_ADDRESS="network.local.address";
  y.ATTR_NETWORK_LOCAL_PORT="network.local.port";
  y.ATTR_NETWORK_PEER_ADDRESS="network.peer.address";
  y.ATTR_NETWORK_PEER_PORT="network.peer.port";
  y.ATTR_NETWORK_PROTOCOL_NAME="network.protocol.name";
  y.ATTR_NETWORK_PROTOCOL_VERSION="network.protocol.version";
  y.ATTR_NETWORK_TRANSPORT="network.transport";
  y.NETWORK_TRANSPORT_VALUE_PIPE="pipe";
  y.NETWORK_TRANSPORT_VALUE_QUIC="quic";
  y.NETWORK_TRANSPORT_VALUE_TCP="tcp";
  y.NETWORK_TRANSPORT_VALUE_UDP="udp";
  y.NETWORK_TRANSPORT_VALUE_UNIX="unix";
  y.ATTR_NETWORK_TYPE="network.type";
  y.NETWORK_TYPE_VALUE_IPV4="ipv4";
  y.NETWORK_TYPE_VALUE_IPV6="ipv6";
  y.ATTR_OTEL_SCOPE_NAME="otel.scope.name";
  y.ATTR_OTEL_SCOPE_VERSION="otel.scope.version";
  y.ATTR_OTEL_STATUS_CODE="otel.status_code";
  y.OTEL_STATUS_CODE_VALUE_ERROR="ERROR";
  y.OTEL_STATUS_CODE_VALUE_OK="OK";
  y.ATTR_OTEL_STATUS_DESCRIPTION="otel.status_description";
  y.ATTR_SERVER_ADDRESS="server.address";
  y.ATTR_SERVER_PORT="server.port";
  y.ATTR_SERVICE_NAME="service.name";
  y.ATTR_SERVICE_VERSION="service.version";
  y.ATTR_SIGNALR_CONNECTION_STATUS="signalr.connection.status";
  y.SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN="app_shutdown";
  y.SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE="normal_closure";
  y.SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT="timeout";
  y.ATTR_SIGNALR_TRANSPORT="signalr.transport";
  y.SIGNALR_TRANSPORT_VALUE_LONG_POLLING="long_polling";
  y.SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS="server_sent_events";
  y.SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS="web_sockets";
  y.ATTR_TELEMETRY_SDK_LANGUAGE="telemetry.sdk.language";
  y.TELEMETRY_SDK_LANGUAGE_VALUE_CPP="cpp";
  y.TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET="dotnet";
  y.TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG="erlang";
  y.TELEMETRY_SDK_LANGUAGE_VALUE_GO="go";
  y.TELEMETRY_SDK_LANGUAGE_VALUE_JAVA="java";
  y.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS="nodejs";
  y.TELEMETRY_SDK_LANGUAGE_VALUE_PHP="php";
  y.TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON="python";
  y.TELEMETRY_SDK_LANGUAGE_VALUE_RUBY="ruby";
  y.TELEMETRY_SDK_LANGUAGE_VALUE_RUST="rust";
  y.TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT="swift";
  y.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS="webjs";
  y.ATTR_TELEMETRY_SDK_NAME="telemetry.sdk.name";
  y.ATTR_TELEMETRY_SDK_VERSION="telemetry.sdk.version";
  y.ATTR_URL_FRAGMENT="url.fragment";
  y.ATTR_URL_FULL="url.full";
  y.ATTR_URL_PATH="url.path";
  y.ATTR_URL_QUERY="url.query";
  y.ATTR_URL_SCHEME="url.scheme";
  y.ATTR_USER_AGENT_ORIGINAL="user_agent.original";
  return y;
}
const Z={};
let eA;
function xD(){
  if (!eA) {
    eA=1;
    Object.defineProperty(Z,"__esModule",{value:true});
    Z.METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS=Z.METRIC_KESTREL_UPGRADED_CONNECTIONS=Z.METRIC_KESTREL_TLS_HANDSHAKE_DURATION=Z.METRIC_KESTREL_REJECTED_CONNECTIONS=Z.METRIC_KESTREL_QUEUED_REQUESTS=Z.METRIC_KESTREL_QUEUED_CONNECTIONS=Z.METRIC_KESTREL_CONNECTION_DURATION=Z.METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES=Z.METRIC_KESTREL_ACTIVE_CONNECTIONS=Z.METRIC_JVM_THREAD_COUNT=Z.METRIC_JVM_MEMORY_USED_AFTER_LAST_GC=Z.METRIC_JVM_MEMORY_USED=Z.METRIC_JVM_MEMORY_LIMIT=Z.METRIC_JVM_MEMORY_COMMITTED=Z.METRIC_JVM_GC_DURATION=Z.METRIC_JVM_CPU_TIME=Z.METRIC_JVM_CPU_RECENT_UTILIZATION=Z.METRIC_JVM_CPU_COUNT=Z.METRIC_JVM_CLASS_UNLOADED=Z.METRIC_JVM_CLASS_LOADED=Z.METRIC_JVM_CLASS_COUNT=Z.METRIC_HTTP_SERVER_REQUEST_DURATION=Z.METRIC_HTTP_CLIENT_REQUEST_DURATION=Z.METRIC_DOTNET_TIMER_COUNT=Z.METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT=Z.METRIC_DOTNET_THREAD_POOL_THREAD_COUNT=Z.METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH=Z.METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET=Z.METRIC_DOTNET_PROCESS_CPU_TIME=Z.METRIC_DOTNET_PROCESS_CPU_COUNT=Z.METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS=Z.METRIC_DOTNET_JIT_COMPILED_METHODS=Z.METRIC_DOTNET_JIT_COMPILED_IL_SIZE=Z.METRIC_DOTNET_JIT_COMPILATION_TIME=Z.METRIC_DOTNET_GC_PAUSE_TIME=Z.METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE=Z.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE=Z.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE=Z.METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED=Z.METRIC_DOTNET_GC_COLLECTIONS=Z.METRIC_DOTNET_EXCEPTIONS=Z.METRIC_DOTNET_ASSEMBLY_COUNT=Z.METRIC_DB_CLIENT_OPERATION_DURATION=Z.METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS=Z.METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS=Z.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION=Z.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE=Z.METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS=Z.METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES=Z.METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS=void 0;
    Z.METRIC_SIGNALR_SERVER_CONNECTION_DURATION=void 0;
    Z.METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS="aspnetcore.diagnostics.exceptions";
    Z.METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES="aspnetcore.rate_limiting.active_request_leases";
    Z.METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS="aspnetcore.rate_limiting.queued_requests";
    Z.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE="aspnetcore.rate_limiting.request.time_in_queue";
    Z.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION="aspnetcore.rate_limiting.request_lease.duration";
    Z.METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS="aspnetcore.rate_limiting.requests";
    Z.METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS="aspnetcore.routing.match_attempts";
    Z.METRIC_DB_CLIENT_OPERATION_DURATION="db.client.operation.duration";
    Z.METRIC_DOTNET_ASSEMBLY_COUNT="dotnet.assembly.count";
    Z.METRIC_DOTNET_EXCEPTIONS="dotnet.exceptions";
    Z.METRIC_DOTNET_GC_COLLECTIONS="dotnet.gc.collections";
    Z.METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED="dotnet.gc.heap.total_allocated";
    Z.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE="dotnet.gc.last_collection.heap.fragmentation.size";
    Z.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE="dotnet.gc.last_collection.heap.size";
    Z.METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE="dotnet.gc.last_collection.memory.committed_size";
    Z.METRIC_DOTNET_GC_PAUSE_TIME="dotnet.gc.pause.time";
    Z.METRIC_DOTNET_JIT_COMPILATION_TIME="dotnet.jit.compilation.time";
    Z.METRIC_DOTNET_JIT_COMPILED_IL_SIZE="dotnet.jit.compiled_il.size";
    Z.METRIC_DOTNET_JIT_COMPILED_METHODS="dotnet.jit.compiled_methods";
    Z.METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS="dotnet.monitor.lock_contentions";
    Z.METRIC_DOTNET_PROCESS_CPU_COUNT="dotnet.process.cpu.count";
    Z.METRIC_DOTNET_PROCESS_CPU_TIME="dotnet.process.cpu.time";
    Z.METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET="dotnet.process.memory.working_set";
    Z.METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH="dotnet.thread_pool.queue.length";
    Z.METRIC_DOTNET_THREAD_POOL_THREAD_COUNT="dotnet.thread_pool.thread.count";
    Z.METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT="dotnet.thread_pool.work_item.count";
    Z.METRIC_DOTNET_TIMER_COUNT="dotnet.timer.count";
    Z.METRIC_HTTP_CLIENT_REQUEST_DURATION="http.client.request.duration";
    Z.METRIC_HTTP_SERVER_REQUEST_DURATION="http.server.request.duration";
    Z.METRIC_JVM_CLASS_COUNT="jvm.class.count";
    Z.METRIC_JVM_CLASS_LOADED="jvm.class.loaded";
    Z.METRIC_JVM_CLASS_UNLOADED="jvm.class.unloaded";
    Z.METRIC_JVM_CPU_COUNT="jvm.cpu.count";
    Z.METRIC_JVM_CPU_RECENT_UTILIZATION="jvm.cpu.recent_utilization";
    Z.METRIC_JVM_CPU_TIME="jvm.cpu.time";
    Z.METRIC_JVM_GC_DURATION="jvm.gc.duration";
    Z.METRIC_JVM_MEMORY_COMMITTED="jvm.memory.committed";
    Z.METRIC_JVM_MEMORY_LIMIT="jvm.memory.limit";
    Z.METRIC_JVM_MEMORY_USED="jvm.memory.used";
    Z.METRIC_JVM_MEMORY_USED_AFTER_LAST_GC="jvm.memory.used_after_last_gc";
    Z.METRIC_JVM_THREAD_COUNT="jvm.thread.count";
    Z.METRIC_KESTREL_ACTIVE_CONNECTIONS="kestrel.active_connections";
    Z.METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES="kestrel.active_tls_handshakes";
    Z.METRIC_KESTREL_CONNECTION_DURATION="kestrel.connection.duration";
    Z.METRIC_KESTREL_QUEUED_CONNECTIONS="kestrel.queued_connections";
    Z.METRIC_KESTREL_QUEUED_REQUESTS="kestrel.queued_requests";
    Z.METRIC_KESTREL_REJECTED_CONNECTIONS="kestrel.rejected_connections";
    Z.METRIC_KESTREL_TLS_HANDSHAKE_DURATION="kestrel.tls_handshake.duration";
    Z.METRIC_KESTREL_UPGRADED_CONNECTIONS="kestrel.upgraded_connections";
    Z.METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS="signalr.server.active_connections";
    Z.METRIC_SIGNALR_SERVER_CONNECTION_DURATION="signalr.server.connection.duration";
  }

  return Z;
}
const Xi={};
let tA;
function $D(){
  if (!tA) {
    tA=1;
    Object.defineProperty(Xi,"__esModule",{value:true});
    Xi.EVENT_EXCEPTION=void 0;
    Xi.EVENT_EXCEPTION="exception";
  }

  return Xi;
}let nA;function pt(){
  if (!nA) {
    nA=1;

    (e => {
      const t=mr&&mr.__createBinding||(Object.create?((r, o, s, i = s) => {
        let a=Object.getOwnPropertyDescriptor(o,s);

        if ((!a || ("get"in a ? !o.__esModule : a.writable||a.configurable))) {
          (a = {enumerable:true,get() {return o[s]}});
        }

        Object.defineProperty(r,i,a);
      }):((r, o, s, i = s) => {
        r[i]=o[s];
      }));

      const n=mr&&mr.__exportStar||((r, o) => {for (const s in r) {
        if (s!=="default"&&!Object.prototype.hasOwnProperty.call(o,s)) {
          t(o,r,s);
        }
      }});

      Object.defineProperty(e,"__esModule",{value:true});
      n(UD(),e);
      n(GD(),e);
      n(VD(),e);
      n(xD(),e);
      n($D(),e);
    })(mr);
  }

  return mr;
}const Q=pt();
const BD="process.runtime.name";
const Xc={[Q.ATTR_TELEMETRY_SDK_NAME]:"opentelemetry",[BD]:"node",[Q.ATTR_TELEMETRY_SDK_LANGUAGE]:Q.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS,[Q.ATTR_TELEMETRY_SDK_VERSION]:wD};
const iI=9;
const HD=6;
const FD=10 ** HD;
const au=10 ** iI;
function Vn(e){
  const t=e/1000/* 1e3 */;
  const n=Math.trunc(t);
  const r=Math.round(e%1000/* 1e3 */*FD);
  return[n,r]
}function Ju(){let e=zr.timeOrigin;if(typeof e!="number"){const t=zr;e=t.timing&&t.timing.fetchStart}return e}function oE(e){
  const t=Vn(Ju());
  const n=Vn(typeof e=="number"?e:zr.now());
  return sE(t,n)
}function YD(e){if (el(e)) {
  return e;
}if (typeof e=="number") {
  return e<Ju()?oE(e):Vn(e);
}if (e instanceof Date) {
  return Vn(e.getTime());
}throw TypeError("Invalid input type")}function aI(e,t){
  let n=t[0]-e[0];
  let r=t[1]-e[1];

  if (r<0) {
    n-=1;
    r+=au;
  }

  return [n,r];
}function jD(e){
  const t=iI;
  const n=`${"0".repeat(t)}${e[1]}Z`;
  const r=n.substring(n.length-t-1);
  return new Date(e[0]*1000/* 1e3 */).toISOString().replace("000Z",r);
}function qD(e){return e[0]*au+e[1]}function WD(e){return e[0]*1000/* 1e3 */+e[1]/1000000/* 1e6 */;}function KD(e){return e[0]*1000000/* 1e6 */+e[1]/1000/* 1e3 */;}function el(e){return Array.isArray(e)&&e.length===2&&typeof e[0]=="number"&&typeof e[1]=="number"}function sp(e){return el(e)||typeof e=="number"||e instanceof Date}function sE(e,t){
  const n=[e[0]+t[0],e[1]+t[1]];

  if (n[1]>=au) {
    n[1]-=au;
    n[0]+=1;
  }

  return n;
}function zD(e){
  if (typeof e!="number") {
    e.unref();
  }
}const ip = {
  SUCCESS: 0,
  FAILED: 1,

  // reverse mapping
  0: "SUCCESS",

  1: "FAILED"
};class ZD{_propagators;_fields;constructor(t={}){
  this._propagators=t.propagators??[];

  this._fields=Array.from(new Set(this._propagators.map(n => typeof n.fields=="function"?n.fields():[]).reduce((n, r) => n.concat(r),[])));
}inject(t,n,r){for (const o of this._propagators) {
  try{o.inject(t,n,r)}catch(s){C.diag.warn(`Failed to inject with ${o.constructor.name}. Err: ${s.message}`)}
}}extract(t,n,r){return this._propagators.reduce((o,s)=>{try{return s.extract(o,n,r)}catch(i){C.diag.warn(`Failed to extract with ${s.constructor.name}. Err: ${i.message}`)}return o},t)}fields(){return this._fields.slice()}}
const ap="[_0-9a-z-*/]";
const XD=`[a-z]${ap}{0,255}`;
const QD=`[a-z0-9]${ap}{0,240}@[a-z]${ap}{0,13}`;
const JD=new RegExp(`^(?:${XD}|${QD})$`);
const e0=/^[ -~]{0,255}[!-~]$/;
const t0=/,|=/;
function n0(e){return JD.test(e)}function r0(e){return e0.test(e)&&!t0.test(e)}
const rA=32;
const o0=512;
const oA=",";
const sA="=";
class zo{_internalState=new Map;constructor(t){
  if (t) {
    this._parse(t);
  }
}set(t,n){
  const r=this._clone();

  if (r._internalState.has(t)) {
    r._internalState.delete(t);
  }

  r._internalState.set(t,n);
  return r;
}unset(t){
  const n=this._clone();
  n._internalState.delete(t);
  return n;
}get(t){return this._internalState.get(t)}serialize(){return this._keys().reduce((t, n) => {
  t.push(n+sA+this.get(n));
  return t;
},[]).join(oA);}_parse(t){
  if (t.length <= o0) {
    this._internalState=t.split(oA).reverse().reduce((n,r)=>{
      const o=r.trim();
      const s=o.indexOf(sA);
      if(s!==-1){
        const i=o.slice(0,s);
        const a=o.slice(s+1,r.length);

        if (n0(i)&&r0(a)) {
          n.set(i,a);
        }
      }return n
    },new Map);

    this._internalState.size>rA&&(this._internalState=new Map(Array.from(this._internalState.entries()).reverse().slice(0,rA)));
  }
}_keys(){return Array.from(this._internalState.keys()).reverse()}_clone(){
  const t=new zo;
  t._internalState=new Map(this._internalState);
  return t;
}}
const Qc="traceparent";
const Jc="tracestate";
const s0="00";
const i0="(?!ff)[\\da-f]{2}";
const a0="(?![0]{32})[\\da-f]{32}";
const c0="(?![0]{16})[\\da-f]{16}";
const u0="[\\da-f]{2}";
const l0=new RegExp(`^\\s?(${i0})-(${a0})-(${c0})-(${u0})(-.*)?\\s?$`);
function cI(e){const t=l0.exec(e);return!t||t[1]==="00"&&t[5]?null:{traceId:t[2],spanId:t[3],traceFlags:parseInt(t[4],16)}}class d0{inject(t,n,r){
  const o=C.trace.getSpanContext(t);if (!o||yn(t)||!C.isSpanContextValid(o)) {
      return;
    }const s=`${s0}-${o.traceId}-${o.spanId}-0${Number(o.traceFlags||C.TraceFlags.NONE).toString(16)}`;
  r.set(n,Qc,s);

  if (o.traceState) {
    r.set(n,Jc,o.traceState.serialize());
  }
}extract(t,n,r){const o=r.get(n,Qc);if (!o) {
  return t;
}const s=Array.isArray(o)?o[0]:o;if (typeof s!="string") {
  return t;
}const i=cI(s);if (!i) {
  return t;
}i.isRemote=true;const a=r.get(n,Jc);if(a){const c=Array.isArray(a)?a.join(","):a;i.traceState=new zo(typeof c=="string"?c:void 0)}return C.trace.setSpanContext(t,i)}fields(){return[Qc,Jc]}}const iE=C.createContextKey("OpenTelemetry SDK Context Key RPC_METADATA");const Jr = {
  HTTP: "http"
};function uI(e,t){return e.setValue(iE,t)}function f0(e){return e.deleteValue(iE)}function tl(e){return e.getValue(iE)}
const _0="[object Object]";
const p0="[object Null]";
const E0="[object Undefined]";
const h0=Function.prototype;
const lI=h0.toString;
const T0=lI.call(Object);
const S0=Object.getPrototypeOf;
const dI=Object.prototype;
const fI=dI.hasOwnProperty;
const Wr=Symbol?Symbol.toStringTag:void 0;
const _I=dI.toString;
function iA(e){if (!m0(e)||A0(e)!==_0) {
  return false;
}const t=S0(e);if (t===null) {
  return true;
}const n=fI.call(t,"constructor")&&t.constructor;return typeof n=="function"&&n instanceof n&&lI.call(n)===T0}function m0(e){return e!=null&&typeof e=="object"}function A0(e){return e==null?e===void 0?E0:p0:Wr&&Wr in Object(e)?g0(e):R0(e)}function g0(e){
  const t=fI.call(e,Wr);
  const n=e[Wr];
  let r=false;try{
      e[Wr]=void 0;
      r=true;
    }catch{}const o=_I.call(e);

  if (r) {
    if (t) {
      e[Wr]=n;
    } else {
      delete e[Wr];
    }
  }

  return o;
}function R0(e){return _I.call(e)}const N0=20;function pI(...e){
  let t=e.shift();const n=new WeakMap;

  while (e.length>0) {
    t=EI(t,e.shift(),0,n);
  }

  return t
}function rd(e){return cu(e)?e.slice():e}function EI(e,t,n=0,r){let o;if(!(n>N0)){
  n++;

  if (eu(e)||eu(t)||hI(t)) {
    o=rd(t);
  } else if(cu(e)){
    o=e.slice();

    if (cu(t)) {
      for (let s=0,i=t.length; s<i; s++) {
        o.push(rd(t[s]));
      }
    } else
      if(Qi(t)){const s=Object.keys(t);for(let i=0,a=s.length;i<a;i++){const c=s[i];o[c]=rd(t[c])}}
  }else if (Qi(e)) {
    if (Qi(t)) {if (!y0(e,t)) {
      return t;
    }o=Object.assign({},e);const s=Object.keys(t);for(let i=0,a=s.length;i<a;i++){
      const c=s[i];
      const l=t[c];
      if (eu(l)) {
        if (typeof l === "undefined") {
          delete o[c];
        } else {
          o[c]=l;
        }
      } else {
        const f=o[c];
        const d=l;
        if (aA(e,c,r)||aA(t,c,r)) {
          delete o[c];
        } else {if(Qi(f)&&Qi(d)){
          const u=r.get(f)||[];
          const _=r.get(d)||[];
          u.push({obj:e,key:c});
          _.push({obj:t,key:c});
          r.set(f,u);
          r.set(d,_);
        }o[c]=EI(o[c],l,n,r)}
      }
    }} else {
      o=t;
    }
  }

  return o
}}function aA(e,t,n){const r=n.get(e[t])||[];for(let o=0,s=r.length;o<s;o++){const i=r[o];if (i.key===t&&i.obj===e) {
  return true;
}}return false;}function cu(e){return Array.isArray(e)}function hI(e){return typeof e=="function"}function Qi(e){return!eu(e)&&!cu(e)&&!hI(e)&&typeof e=="object"}function eu(e){return typeof e=="string"||typeof e=="number"||typeof e=="boolean"||typeof e === "undefined"||e instanceof Date||e instanceof RegExp||e===null;}function y0(e,t){return!(!iA(e)||!iA(t))}class nl extends Error{constructor(t){
  super(t);
  Object.setPrototypeOf(this,nl.prototype);
}}function O0(e,t){let n;const r=new Promise((s, i) => {n=setTimeout(() => {i(new nl("Operation timed out."))},t)});return Promise.race([e,r]).then(o => {
  clearTimeout(n);
  return o;
},o=>{
  clearTimeout(n);
  throw o;
});}function TI(e,t){return typeof t=="string"?e===t:!!e.match(t)}function b0(e,t){if (!t) {
  return false;
}for (const n of t) {
  if (TI(e,n)) {
    return true;
  }
}return false;}class C0{_promise;_resolve;_reject;constructor(){this._promise=new Promise((t,n)=>{
  this._resolve=t;
  this._reject=n;
})}get promise(){return this._promise}resolve(t){this._resolve(t)}reject(t){this._reject(t)}}class I0{_callback;_that;_isCalled=false;_deferred=new C0;constructor(t,n){
  this._callback=t;
  this._that=n;
}get isCalled(){return this._isCalled}get promise(){return this._deferred.promise}call(...t){if(!this._isCalled){this._isCalled=true;try{Promise.resolve(this._callback.call(this._that,...t)).then(n => this._deferred.resolve(n),n => this._deferred.reject(n))}catch(n){this._deferred.reject(n)}}return this._deferred.promise}}const cA={ALL:C.DiagLogLevel.ALL,VERBOSE:C.DiagLogLevel.VERBOSE,DEBUG:C.DiagLogLevel.DEBUG,INFO:C.DiagLogLevel.INFO,WARN:C.DiagLogLevel.WARN,ERROR:C.DiagLogLevel.ERROR,NONE:C.DiagLogLevel.NONE};function P0(e){if (e==null) {
  return;
}const t=cA[e.toUpperCase()];return t??(C.diag.warn(`Unknown log level "${e}", expected one of ${Object.keys(cA)}, using default`),C.DiagLogLevel.INFO)}function M0(e,t){return new Promise(n=>{C.context.with(Qr(C.context.active()),()=>{e.export(t,r=>{n(r)})})})}
const v0={_export:M0};
const L0=Object.freeze(Object.defineProperty({__proto__:null,AnchoredClock:yD,BindOnceFuture:I0,CompositePropagator:ZD,get ExportResultCode() {return ip},get RPCType() {return Jr},SDK_INFO:Xc,TRACE_PARENT_HEADER:Qc,TRACE_STATE_HEADER:Jc,TimeoutError:nl,TraceState:zo,W3CBaggagePropagator:tI,W3CTraceContextPropagator:d0,_globalThis:LD,addHrTimes:sE,callWithTimeout:O0,deleteRPCMetadata:f0,diagLogLevelFromString:P0,getBooleanFromEnv:MD,getNumberFromEnv:bt,getRPCMetadata:tl,getStringFromEnv:rE,getStringListFromEnv:vD,getTimeOrigin:Ju,globalErrorHandler:nE,hrTime:oE,hrTimeDuration:aI,hrTimeToMicroseconds:KD,hrTimeToMilliseconds:WD,hrTimeToNanoseconds:qD,hrTimeToTimeStamp:jD,internal:v0,isAttributeValue:tE,isTimeInput:sp,isTimeInputHrTime:el,isTracingSuppressed:yn,isUrlIgnored:b0,loggingErrorHandler:rI,merge:pI,millisToHrTime:Vn,otperformance:zr,parseKeyPairsIntoRecord:ND,parseTraceParent:cI,sanitizeAttributes:Wa,setGlobalErrorHandler:PD,setRPCMetadata:uI,suppressTracing:Qr,timeInputToHrTime:YD,unrefTimer:zD,unsuppressTracing:hD,urlMatches:TI},Symbol.toStringTag,{value:"Module"}));
const dn=YC(L0);
const Ji={};
let uA;
function w0(){
  if (!uA) {
    uA=1;
    Object.defineProperty(Ji,"__esModule",{value:true});
    Ji.VERSION=void 0;
    Ji.VERSION="0.208.0";
  }

  return Ji;
}class SI{emit(t){}}const D0=new SI;class U0{getLogger(t,n,r){return new SI}}const mI=new U0;class k0{constructor(t,n,r,o){
  this._provider=t;
  this.name=n;
  this.version=r;
  this.options=o;
}emit(t){this._getLogger().emit(t)}_getLogger(){if (this._delegate) {
  return this._delegate;
}const t=this._provider._getDelegateLogger(this.name,this.version,this.options);return t?(this._delegate=t,this._delegate):D0}}class lA{getLogger(t,n,r){
  return this._getDelegateLogger(t,n,r) ?? new k0(this,t,n,r);
}_getDelegate(){
  return this._delegate ?? mI;
}_setDelegate(t){this._delegate=t}_getDelegateLogger(t,n,r){let o;return(o=this._delegate)===null||o===void 0?void 0:o.getLogger(t,n,r)}}
const G0=typeof globalThis=="object"?globalThis:global;
const bc=Symbol.for("io.opentelemetry.js.api.logs");
const ea=G0;
function V0(e,t,n){return r => r===e?t:n;}const dA=1;class aE{constructor(){this._proxyLoggerProvider=new lA}static getInstance(){
  if (!this._instance) {
    (this._instance = new aE);
  }

  return this._instance;
}setGlobalLoggerProvider(t){return ea[bc]?this.getLoggerProvider():(ea[bc]=V0(dA,t,mI),this._proxyLoggerProvider._setDelegate(t),t)}getLoggerProvider(){
  return ((t=ea[bc])===null||t===void 0 ? void 0 : t.call(ea,dA)) ?? this._proxyLoggerProvider;
}getLogger(t,n,r){return this.getLoggerProvider().getLogger(t,n,r)}disable(){
  delete ea[bc];
  this._proxyLoggerProvider=new lA;
}}const AI=aE.getInstance();function x0(e,t,n,r){for(let o=0,s=e.length;o<s;o++){
  const i=e[o];

  if (t) {
    i.setTracerProvider(t);
  }

  if (n) {
    i.setMeterProvider(n);
  }

  if (r&&i.setLoggerProvider) {
    i.setLoggerProvider(r);
  }

  if (!i.getConfig().enabled) {
    i.enable();
  }
}}function $0(e){e.forEach(t => t.disable())}function rl(e){
  const t=e.tracerProvider||C.trace.getTracerProvider();
  const n=e.meterProvider||C.metrics.getMeterProvider();
  const r=e.loggerProvider||AI.getLoggerProvider();
  const o=e.instrumentations?.flat()??[];
  x0(o,t,n,r);
  return ()=>{$0(o)};
}
const gI=/^(?:v)?(?<version>(?<major>0|[1-9]\d*)\.(?<minor>0|[1-9]\d*)\.(?<patch>0|[1-9]\d*))(?:-(?<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?<build>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
const B0=/^(?<op><|>|=|==|<=|>=|~|\^|~>)?\s*(?:v)?(?<version>(?<major>x|X|\*|0|[1-9]\d*)(?:\.(?<minor>x|X|\*|0|[1-9]\d*))?(?:\.(?<patch>x|X|\*|0|[1-9]\d*))?)(?:-(?<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?<build>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
const H0={">":[1],">=":[0,1],"=":[0],"<=":[-1,0],"<":[-1],"!=":[-1,1]};
function F0(e,t,n){
  if (!Y0(e)) {
    C.diag.error(`Invalid version: ${e}`);
    return false;
  }if (!t) {
    return true;
  }t=t.replace(/([<>=~^]+)\s+/g,"$1");const r=K0(e);if (!r) {
    return false;
  }
  const o=[];
  const s=RI(r,t,o,n);
  return s&&!n?.includePrerelease?q0(r,o):s
}function Y0(e){return typeof e=="string"&&gI.test(e)}function RI(e,t,n,r){if(t.includes("||")){const o=t.trim().split("||");for (const s of o) {
  if (od(e,s,n,r)) {
    return true;
  }
}return false;}else if (t.includes(" - ")) {
  t=EU(t,r);
} else if(t.includes(" ")){const o=t.trim().replace(/\s{2,}/g," ").split(" ");for (const s of o) {
  if (!od(e,s,n,r)) {
    return false;
  }
}return true;}return od(e,t,n,r)}function od(e,t,n,r){
  t=W0(t,r);

  if (t.includes(" ")) {
    return RI(e,t,n,r);
  }

  {
    const o=z0(t);
    n.push(o);
    return j0(e,o);
  }
}function j0(e,t){if (t.invalid) {
  return false;
}if (!t.version||cp(t.version)) {
  return true;
}let n=_A(e.versionSegments||[],t.versionSegments||[]);if(n===0){
  const r=e.prereleaseSegments||[];
  const o=t.prereleaseSegments||[];

  if (!r.length&&!o.length) {
    n=0;
  } else if (!r.length&&o.length) {
    n=1;
  } else if (r.length&&!o.length) {
    n=-1;
  } else {
    n=_A(r,o);
  }
}return H0[t.op]?.includes(n)}function q0(e,t){return e.prerelease?t.some(n => n.prerelease&&n.version===e.version):true;}function W0(e,t){
  e=e.trim();
  e=_U(e,t);
  e=fU(e);
  e=pU(e,t);
  e=e.trim();
  return e;
}function Rt(e){return!e||e.toLowerCase()==="x"||e==="*"}function K0(e){
  const t=e.match(gI);if(!t){C.diag.error(`Invalid version: ${e}`);return}
  const n=t.groups.version;
  const r=t.groups.prerelease;
  const o=t.groups.build;
  const s=n.split(".");
  const i=r?.split(".");
  return{op:void 0,version:n,versionSegments:s,versionSegmentCount:s.length,prerelease:r,prereleaseSegments:i,prereleaseSegmentCount:i?i.length:0,build:o}
}function z0(e){
  if (!e) {
    return{};
  }const t=e.match(B0);if (!t) {
      C.diag.error(`Invalid range: ${e}`);
      return {invalid:true};
    }let n=t.groups.op;
  const r=t.groups.version;
  const o=t.groups.prerelease;
  const s=t.groups.build;
  const i=r.split(".");
  const a=o?.split(".");

  if (n==="==") {
    (n = "=");
  }

  return {op:n||"=",version:r,versionSegments:i,versionSegmentCount:i.length,prerelease:o,prereleaseSegments:a,prereleaseSegmentCount:a?a.length:0,build:s};
}function cp(e){return e==="*"||e==="x"||e==="X"}function fA(e){const t=parseInt(e,10);return isNaN(t)?e:t}function Z0(e,t){if (typeof e==typeof t) {if (typeof e=="number") {
  return[e,t];
}if (typeof e=="string") {
  return[e,t];
}throw new Error("Version segments can only be strings or numbers")} else {
  return[String(e),String(t)]
}}function X0(e,t){if (cp(e)||cp(t)) {
  return 0;
}const[n,r]=Z0(fA(e),fA(t));return n>r?1:n<r?-1:0}function _A(e,t){for(let n=0;n<Math.max(e.length,t.length);n++){const r=X0(e[n]||"0",t[n]||"0");if (r!==0) {
  return r
}}return 0}
const NI="[a-zA-Z0-9-]";
const yI="0|[1-9]\\d*";
const Q0=`\\d*[a-zA-Z-]${NI}*`;
const J0="((?:<|>)?=?)";
const pA=`(?:${yI}|${Q0})`;
const eU=`(?:-(${pA}(?:\\.${pA})*))`;
const EA=`${NI}+`;
const tU=`(?:\\+(${EA}(?:\\.${EA})*))`;
const sd=`${yI}|x|X|\\*`;
const nc=`[v=\\s]*(${sd})(?:\\.(${sd})(?:\\.(${sd})(?:${eU})?${tU}?)?)?`;
const nU=`^${J0}\\s*${nc}$`;
const rU=new RegExp(nU);
const oU=`^\\s*(${nc})\\s+-\\s+(${nc})\\s*$`;
const sU=new RegExp(oU);
const iU="(?:~>?)";
const aU=`^${iU}${nc}$`;
const cU=new RegExp(aU);
const uU="(?:\\^)";
const lU=`^${uU}${nc}$`;
const dU=new RegExp(lU);
function fU(e){const t=cU;return e.replace(t,(n,r,o,s,i)=>{
  let a;

  if (Rt(r)) {
    a="";
  } else if (Rt(o)) {
    a=`>=${r}.0.0 <${+r+1}.0.0-0`;
  } else if (Rt(s)) {
    a=`>=${r}.${o}.0 <${r}.${+o+1}.0-0`;
  } else if (i) {
    a=`>=${r}.${o}.${s}-${i} <${r}.${+o+1}.0-0`;
  } else {
    a=`>=${r}.${o}.${s} <${r}.${+o+1}.0-0`;
  }

  return a;
});}function _U(e,t){
  const n=dU;
  const r=t?.includePrerelease?"-0":"";
  return e.replace(n,(o,s,i,a,c)=>{
    let l;

    if (Rt(s)) {
      l="";
    } else if (Rt(i)) {
      l=`>=${s}.0.0${r} <${+s+1}.0.0-0`;
    } else if (Rt(a)) {
      if (s==="0") {
        l=`>=${s}.${i}.0${r} <${s}.${+i+1}.0-0`;
      } else {
        l=`>=${s}.${i}.0${r} <${+s+1}.0.0-0`;
      }
    } else if (c) {
      if (s==="0") {
        if (i==="0") {
          l=`>=${s}.${i}.${a}-${c} <${s}.${i}.${+a+1}-0`;
        } else {
          l=`>=${s}.${i}.${a}-${c} <${s}.${+i+1}.0-0`;
        }
      } else {
        l=`>=${s}.${i}.${a}-${c} <${+s+1}.0.0-0`;
      }
    } else if (s==="0") {
      if (i==="0") {
        l=`>=${s}.${i}.${a}${r} <${s}.${i}.${+a+1}-0`;
      } else {
        l=`>=${s}.${i}.${a}${r} <${s}.${+i+1}.0-0`;
      }
    } else {
      l=`>=${s}.${i}.${a} <${+s+1}.0.0-0`;
    }

    return l;
  });
}function pU(e,t){const n=rU;return e.replace(n,(r,o,s,i,a,c)=>{
  const l=Rt(s);
  const f=l||Rt(i);
  const d=f||Rt(a);
  const u=d;

  if (o==="="&&u) {
    (o = "");
  }

  c=t?.includePrerelease?"-0":"";

  if (l) {
    if (o===">"||o==="<") {
      r="<0.0.0-0";
    } else {
      r="*";
    }
  } else if (o&&u) {
    f&&(i=0);
    a=0;
    o===">"?(o=">=",f?(s=+s+1,i=0,a=0):(i=+i+1,a=0)):o==="<="&&(o="<",f?s=+s+1:i=+i+1);
    o==="<"&&(c="-0");
    r=`${o+s}.${i}.${a}${c}`;
  } else if (f) {
    r=`>=${s}.0.0${c} <${+s+1}.0.0-0`;
  } else if (d) {
    (r = `>=${s}.${i}.0${c} <${s}.${+i+1}.0-0`);
  }

  return r;
});}function EU(e,t){const n=sU;return e.replace(n,(r, o, s, i, a, c, l, f, d, u, _, p) => {
  if (Rt(s)) {
    o="";
  } else if (Rt(i)) {
    o=`>=${s}.0.0${t?.includePrerelease?"-0":""}`;
  } else if (Rt(a)) {
    o=`>=${s}.${i}.0${t?.includePrerelease?"-0":""}`;
  } else if (c) {
    o=`>=${o}`;
  } else {
    o=`>=${o}${t?.includePrerelease?"-0":""}`;
  }

  if (Rt(d)) {
    f="";
  } else if (Rt(u)) {
    f=`<${+d+1}.0.0-0`;
  } else if (Rt(_)) {
    f=`<${d}.${+u+1}.0-0`;
  } else if (p) {
    f=`<=${d}.${u}.${_}-${p}`;
  } else if (t?.includePrerelease) {
    f=`<${d}.${u}.${+_+1}-0`;
  } else {
    f=`<=${f}`;
  }

  return `${o} ${f}`.trim();
});}let Ut=console.error.bind(console);function ta(e,t,n){const r=!!e[t]&&Object.prototype.propertyIsEnumerable.call(e,t);Object.defineProperty(e,t,{configurable:true,enumerable:r,writable:true,value:n})}

const uu=(e,t,n)=>{
  if(!e||!e[t]){Ut(`no original function ${String(t)} to wrap`);return}if(!n){
    Ut("no wrapper function");
    Ut(new Error().stack);
    return
  }const r=e[t];if(typeof r!="function"||typeof n!="function"){Ut("original object and wrapper must be functions");return}const o=n(r,t);
  ta(o,"__original",r);
  ta(o,"__unwrap",()=>{
    if (e[t]===o) {
      ta(e,t,r);
    }
  });
  ta(o,"__wrapped",true);
  ta(e,t,o);
  return o;
};

const hU=(e,t,n)=>{if (e) {
  if (!Array.isArray(e)) {
    (e = [e]);
  }
} else {
  Ut("must provide one or more modules to patch");
  Ut(new Error().stack);
  return
}if(!(t&&Array.isArray(t))){Ut("must provide one or more functions to wrap on modules");return}e.forEach(r=>{t.forEach(o=>{uu(r,o,n)})})};

const cE=(e,t)=>{if(!e||!e[t]){
  Ut("no function to unwrap.");
  Ut(new Error().stack);
  return
}const n=e[t];if (!n.__unwrap) {
  Ut(`no original to unwrap to -- has ${String(t)} already been unwrapped?`);
} else
  {n.__unwrap();return}};

const TU=(e,t)=>{if (e) {
  if (!Array.isArray(e)) {
    (e = [e]);
  }
} else {
  Ut("must provide one or more modules to patch");
  Ut(new Error().stack);
  return
}if(!(t&&Array.isArray(t))){Ut("must provide one or more functions to unwrap on modules");return}e.forEach(n=>{t.forEach(r=>{cE(n,r)})})};

class SU{instrumentationName;instrumentationVersion;_config={};_tracer;_meter;_logger;_diag;constructor(t,n,r){
  this.instrumentationName=t;
  this.instrumentationVersion=n;
  this.setConfig(r);
  this._diag=C.diag.createComponentLogger({namespace:t});
  this._tracer=C.trace.getTracer(t,n);
  this._meter=C.metrics.getMeter(t,n);
  this._logger=AI.getLogger(t,n);
  this._updateMetricInstruments();
}_wrap=uu;_unwrap=cE;_massWrap=hU;_massUnwrap=TU;get meter(){return this._meter}setMeterProvider(t){
  this._meter=t.getMeter(this.instrumentationName,this.instrumentationVersion);
  this._updateMetricInstruments();
}get logger(){return this._logger}setLoggerProvider(t){this._logger=t.getLogger(this.instrumentationName,this.instrumentationVersion)}getModuleDefinitions(){const t=this.init()??[];return Array.isArray(t)?t:[t]}_updateMetricInstruments(){}getConfig(){return this._config}setConfig(t){this._config={enabled:true,...t}}setTracerProvider(t){this._tracer=t.getTracer(this.instrumentationName,this.instrumentationVersion)}get tracer(){return this._tracer}_runSpanCustomizationHook(t,n,r,o){if (t) {
  try{t(r,o)}catch(s){this._diag.error("Error running span customization hook due to exception in handler",{triggerName:n},s)}
}}}
const Cc={exports:{}};
const Ic={exports:{}};
const Pc={exports:{}};
let id;
let hA;
function mU(){
  if (hA) {
    return id;
  }hA=1;
  const e=1000/* 1e3 */;
  const t=e*60;
  const n=t*60;
  const r=n*24;
  const o=r*7;
  const s=r*365.25;
  id=(f, d) => {d=d||{};const u=typeof f;if (u==="string"&&f.length>0) {
    return i(f);
  }if (u==="number"&&isFinite(f)) {
    return d.long?c(f):a(f);
  }throw new Error(`val is not a non-empty string or a valid number. val=${JSON.stringify(f)}`)};function i(f){
    f=String(f);

    if (!(f.length>100)) {const d=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(f);if(d){
      const u=parseFloat(d[1]);
      const _=(d[2]||"ms").toLowerCase();
      switch(_){case"years":case"year":case"yrs":case"yr":case "y":
        {
          return u*s;
        }case"weeks":case"week":case "w":
        {
          return u*o;
        }case"days":case"day":case "d":
        {
          return u*r;
        }case"hours":case"hour":case"hrs":case"hr":case "h":
        {
          return u*n;
        }case"minutes":case"minute":case"mins":case"min":case "m":
        {
          return u*t;
        }case"seconds":case"second":case"secs":case"sec":case "s":
        {
          return u*e;
        }case"milliseconds":case"millisecond":case"msecs":case"msec":case "ms":
        {
          return u;
        }default:
        {
          return
        }}
    }}
  }function a(f){const d=Math.abs(f);return d>=r?`${Math.round(f/r)}d`:d>=n?`${Math.round(f/n)}h`:d>=t?`${Math.round(f/t)}m`:d>=e?`${Math.round(f/e)}s`:`${f}ms`;}function c(f){const d=Math.abs(f);return d>=r?l(f,d,r,"day"):d>=n?l(f,d,n,"hour"):d>=t?l(f,d,t,"minute"):d>=e?l(f,d,e,"second"):`${f} ms`;}function l(f,d,u,_){const p=d>=u*1.5;return `${Math.round(f/u)} ${_}${p?"s":""}`;}return id
}
let ad;
let TA;
function OI(){
  if (TA) {
    return ad;
  }TA=1;function e(t){
    r.debug=r;
    r.default=r;
    r.coerce=l;
    r.disable=a;
    r.enable=s;
    r.enabled=c;
    r.humanize=mU();
    r.destroy=f;
    Object.keys(t).forEach(d=>{r[d]=t[d]});
    r.names=[];
    r.skips=[];
    r.formatters={};
    function n(d){let u=0;for (let _=0; _<d.length; _++) {
      u=(u<<5)-u+d.charCodeAt(_);
      u|=0;
    }return r.colors[Math.abs(u)%r.colors.length]}r.selectColor=n;function r(d){
  let u;
  let _=null;
  let p;
  let E;
  function h(...T){
    if (!h.enabled) {
      return;
    }
    const m=h;
    const A=Number(new Date);
    const g=A-(u||A);
    m.diff=g;
    m.prev=u;
    m.curr=A;
    u=A;
    T[0]=r.coerce(T[0]);

    if (typeof T[0]!="string") {
      T.unshift("%O");
    }

    let R=0;

    T[0]=T[0].replace(/%([a-zA-Z%])/g,(I,b)=>{if (I==="%%") {
      return"%";
    }R++;const L=r.formatters[b];if(typeof L=="function"){
      const U=T[R];
      I=L.call(m,U);
      T.splice(R,1);
      R--;
    }return I});

    r.formatArgs.call(m,T);
    (m.log||r.log).apply(m,T);
  }
  h.namespace=d;
  h.useColors=r.useColors();
  h.color=r.selectColor(d);
  h.extend=o;
  h.destroy=r.destroy;

  Object.defineProperty(h,"enabled",{enumerable:true,configurable:false,get:() => _!==null?_:(p!==r.namespaces&&(p=r.namespaces,E=r.enabled(d)),E),set:T=>{_=T}});

  if (typeof r.init=="function") {
    r.init(h);
  }

  return h;
}function o(d,u){
      const _=r(this.namespace+(typeof u === "undefined"?":":u)+d);
      _.log=this.log;
      return _;
    }function s(d){
      r.save(d);
      r.namespaces=d;
      r.names=[];
      r.skips=[];
      const u=(typeof d=="string"?d:"").trim().replace(/\s+/g,",").split(",").filter(Boolean);for (const _ of u) {
  if (_[0]==="-") {
    r.skips.push(_.slice(1));
  } else {
    r.names.push(_);
  }
}
    }function i(d,u){
  let _=0;
  let p=0;
  let E=-1;
  let h=0;

  while (_<d.length) {
    if (p<u.length&&(u[p]===d[_]||u[p]==="*")) {
      if (u[p]==="*") {
        E=p;
        h=_;
        p++;
      } else {
        _++;
        p++;
      }
    } else if (E!==-1) {
      p=E+1;
      h++;
      _=h;
    } else {
      return false;
    }
  }

  while (p<u.length&&u[p]==="*") {
          p++;
        }

  return p===u.length
}function a(){
      const d=[...r.names,...r.skips.map(u => `-${u}`)].join(",");
      r.enable("");
      return d;
    }function c(d){for (const u of r.skips) {
      if (i(d,u)) {
        return false;
      }
    }for (const u of r.names) {
      if (i(d,u)) {
        return true;
      }
    }return false;}function l(d){return d instanceof Error?d.stack||d.message:d}function f(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}
    r.enable(r.load());
    return r;
  }
  ad=e;
  return ad;
}let SA;function AU(){
  if (!SA) {
    SA=1;

    ((e, t) => {
      t.formatArgs=r;
      t.save=o;
      t.load=s;
      t.useColors=n;
      t.storage=i();
      t.destroy=(()=>{let c=false;return ()=>{
        if (!c) {
          c=true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };})();
      t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];
      function n(){if (typeof window !== "undefined"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)) {
        return true;
      }if (typeof navigator !== "undefined"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }let c;return typeof document !== "undefined"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window !== "undefined"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator !== "undefined"&&navigator.userAgent&&(c=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(c[1],10)>=31||typeof navigator !== "undefined"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);}function r(c){
        c[0]=`${(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+c[0]+(this.useColors?"%c ":" ")}+${e.exports.humanize(this.diff)}`;

        if (!this.useColors) {
          return;
        }

        const l=`color: ${this.color}`;c.splice(1,0,l,"color: inherit");
        let f=0;
        let d=0;
        c[0].replace(/%[a-zA-Z%]/g,u=>{
          if (u!=="%%") {
            f++;
            u==="%c"&&(d=f);
          }
        });
        c.splice(d,0,l);
      }t.log=console.debug||console.log||(()=>{});function o(c){try{
      if (c) {
        t.storage.setItem("debug",c);
      } else {
        t.storage.removeItem("debug");
      }
    }catch{}}function s(){
      let c;try{c=t.storage.getItem("debug")||t.storage.getItem("DEBUG")}catch{}

      if (!c&&typeof process !== "undefined"&&"env"in process) {
        (c = process.env.DEBUG);
      }

      return c;
    }function i(){try{return localStorage}catch{}}e.exports=OI()(t);const{formatters}=e.exports;formatters.j=c => {try{return JSON.stringify(c)}catch(l){return `[UnexpectedJSONParseError]: ${l.message}`;}}
    })(Pc, Pc.exports);
  }

  return Pc.exports;
}
const Mc={exports:{}};
let cd;
let mA;
function gU(){
  if (!mA) {
    mA=1;

    cd=(e,t=process.argv)=>{
      const n=e.startsWith("-")?"":e.length===1?"-":"--";
      const r=t.indexOf(n+e);
      const o=t.indexOf("--");
      return r!==-1&&(o===-1||r<o)
    };
  }

  return cd;
}
let ud;
let AA;
function RU(){
  if (AA) {
    return ud;
  }AA=1;
  const e=Pw;
  const t=$C;
  const n=gU();
  const {env}=process;
  let o;

  if (n("no-color")||n("no-colors")||n("color=false")||n("color=never")) {
    o=0;
  } else if ((n("color")||n("colors")||n("color=true") || n("color=always"))) {
    (o = 1);
  }

  function s(){if ("FORCE_COLOR"in env) {
      return env.FORCE_COLOR==="true"?1:env.FORCE_COLOR==="false"?0:env.FORCE_COLOR.length===0?1:Math.min(Number.parseInt(env.FORCE_COLOR,10),3);
    }}function i(l){return l===0?false:{level:l,hasBasic:true,has256:l>=2,has16m:l>=3};}function a(l,{streamIsTTY:f,sniffFlags:d=true}={}){
    const u=s();

    if (u!==void 0) {
      (o = u);
    }

    const _=d?o:u;if (_===0) {
        return 0;
      }if(d){if (n("color=16m")||n("color=full")||n("color=truecolor")) {
        return 3;
      }if (n("color=256")) {
        return 2
      }}if (l&&!f&&_===void 0) {
        return 0;
      }const p=_||0;if (env.TERM==="dumb") {
        return p;
      }if(process.platform==="win32"){const E=e.release().split(".");return Number(E[0])>=10&&Number(E[2])>=10586?Number(E[2])>=14931?3:2:1}if ("CI"in env) {
        return ["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","GITHUB_ACTIONS","BUILDKITE","DRONE"].some(E => E in env)||env.CI_NAME==="codeship"?1:p;
      }if ("TEAMCITY_VERSION"in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION)?1:0;
      }if (env.COLORTERM==="truecolor") {
        return 3;
      }if("TERM_PROGRAM"in env){const E=Number.parseInt((env.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(env.TERM_PROGRAM){case "iTerm.app":
        {
          return E>=3?3:2;
        }case "Apple_Terminal":
        {
          return 2
        }}}return /-256(color)?$/i.test(env.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)||"COLORTERM"in env?1:p;
  }function c(l,f={}){const d=a(l,{streamIsTTY:l&&l.isTTY,...f});return i(d)}
  ud={supportsColor:c,stdout:c({isTTY:t.isatty(1)}),stderr:c({isTTY:t.isatty(2)})};
  return ud;
}let gA;function NU(){
  if (!gA) {
    gA=1;

    ((e, t) => {
      const n=$C;
      const r=Xr;
      t.init=f;
      t.log=a;
      t.formatArgs=s;
      t.save=c;
      t.load=l;
      t.useColors=o;
      t.destroy=r.deprecate(()=>{},"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      t.colors=[6,2,3,4,5,1];
      try{
        const u=RU();

        if (u&&(u.stderr||u).level>=2) {
          (t.colors = [20,21,26,27,32,33,38,39,40,41,42,43,44,45,56,57,62,63,68,69,74,75,76,77,78,79,80,81,92,93,98,99,112,113,128,129,134,135,148,149,160,161,162,163,164,165,166,167,168,169,170,171,172,173,178,179,184,185,196,197,198,199,200,201,202,203,204,205,206,207,208,209,214,215,220,221]);
        }
      }catch{}t.inspectOpts=Object.keys(process.env).filter(u => /^debug_/i.test(u)).reduce((u,_)=>{
      const p=_.substring(6).toLowerCase().replace(/_([a-z])/g,(h, T) => T.toUpperCase());let E=process.env[_];

      if (/^(yes|on|true|enabled)$/i.test(E)) {
        E=true;
      } else if (/^(no|off|false|disabled)$/i.test(E)) {
        E=false;
      } else if (E==="null") {
        E=null;
      } else {
        E=Number(E);
      }

      u[p]=E;
      return u;
    },{});function o(){return"colors"in t.inspectOpts?!!t.inspectOpts.colors:n.isatty(process.stderr.fd)}function s(u){const{namespace,useColors}=this;if (useColors) {
        const E=this.color;
        const h=`\x1B[3${E<8?E:`8;5;${E}`}`;
        const T=`  ${h};1m${namespace} \x1B[0m`;

        u[0]=T+u[0].split(`
        `).join(`
        `+T);

        u.push(`${h}m+${e.exports.humanize(this.diff)}\x1B[0m`);
      } else {
        u[0]=`${i()+namespace} ${u[0]}`
      }}function i(){return t.inspectOpts.hideDate?"":`${new Date().toISOString()} `;}function a(...u){return process.stderr.write(r.formatWithOptions(t.inspectOpts,...u)+`
      `)}function c(u){
      if (u) {
        process.env.DEBUG=u;
      } else {
        delete process.env.DEBUG;
      }
    }function l(){return process.env.DEBUG}function f(u){u.inspectOpts={};const _=Object.keys(t.inspectOpts);for (let p=0; p<_.length; p++) {
        u.inspectOpts[_[p]]=t.inspectOpts[_[p]]
      }}e.exports=OI()(t);const{formatters}=e.exports;

      formatters.o=function(u){
        this.inspectOpts.colors=this.useColors;

        return r.inspect(u,this.inspectOpts).split(`
        `).map(_ => _.trim()).join(" ");
      };

      formatters.O=function(u){
        this.inspectOpts.colors=this.useColors;
        return r.inspect(u,this.inspectOpts);
      };
    })(Mc, Mc.exports);
  }

  return Mc.exports;
}let RA;function yU(){
  if (!RA) {
    RA=1;
    typeof process === "undefined"||process.type==="renderer"||process.browser===true||process.__nwjs?Ic.exports=AU():Ic.exports=NU();
  }

  return Ic.exports;
}
let ld;
let NA;
function bI(){
  if (NA) {
    return ld;
  }NA=1;const e=hc.sep;

  ld=t => {
    const n=t.split(e);
    const r=n.lastIndexOf("node_modules");
    if(r!==-1&&n[r+1]){
      const o=n[r+1][0]==="@";
      const s=o?`${n[r+1]}/${n[r+2]}`:n[r+1];
      const i=o?3:2;
      let a="";
      for (let c=r+i-1, l=0; l<=c; l++) {
        if (l===c) {
          a+=n[l];
        } else {
          a+=n[l]+e;
        }
      }
      let f="";
      for (let d=n.length-1, u=r+i; u<=d; u++) {
        if (u===d) {
          f+=n[u];
        } else {
          f+=n[u]+e;
        }
      }return{name:s,basedir:a,path:f}
    }
  };

  return ld;
}let yA;function OU(...args) {
  if (yA) {
    return Cc.exports;
  }yA=1;
  const e=hc;
  const t=xC;
  const n=yU()("require-in-the-middle");
  const r=bI();
  Cc.exports=c;
  Cc.exports.Hook=c;
  let o;
  let s;
  if (t.isBuiltin) {
    s=t.isBuiltin;
  } else if (t.builtinModules) {
    s=f => f.startsWith("node:")?true:(o===void 0&&(o=new Set(t.builtinModules)),o.has(f));
  } else {
    throw new Error("'require-in-the-middle' requires Node.js >=v9.3.0 or >=v8.10.0");
  }const i=/([/\\]index)?(\.js)?$/;class a{constructor(){
    this._localCache=new Map;
    this._kRitmExports=Symbol("RitmExports");
  }has(d,u){if (this._localCache.has(d)) {
    return true;
  }if (u) {
    return false;
  }{const _=require.cache[d];return!!(_&&this._kRitmExports in _)}}get(d,u){const _=this._localCache.get(d);if (_!==void 0) {
    return _;
  }if(!u){const p=require.cache[d];return p&&p[this._kRitmExports]}}set(d,u,_){
  if (_) {
    this._localCache.set(d,u);
  } else if (d in require.cache) {
    require.cache[d][this._kRitmExports]=u;
  } else {
    n('non-core module is unexpectedly not in require.cache: "%s"',d);
    this._localCache.set(d,u);
  }
}}function c(f,d,u){
  if (!(this instanceof c)) {
    return new c(f,d,u);
  }

  if (typeof f=="function") {
    u=f;
    f=null;
    d=null;
  } else if (typeof d=="function") {
    u=d;
    d=null;
  }

  if (typeof t._resolveFilename!="function") {
    console.error("Error: Expected Module._resolveFilename to be a function (was: %s) - aborting!",typeof t._resolveFilename);
    console.error("Please report this error as an issue related to Node.js %s at https://github.com/nodejs/require-in-the-middle/issues",process.version);
    return
  }

  this._cache=new a;
  this._unhooked=false;
  this._origRequire=t.prototype.require;
  const _=this;
  const p=new Set;
  const E=d?d.internals===true:false;
  const h=Array.isArray(f);
  n("registering require hook");
  this._require=t.prototype.require=function(m){return _._unhooked===true?(n("ignoring require call - module is soft-unhooked"),_._origRequire.apply(this,args)):T.call(this,args,false);};

  if (typeof process.getBuiltinModule=="function") {
    this._origGetBuiltinModule=process.getBuiltinModule;
    this._getBuiltinModule=process.getBuiltinModule=function(m){return _._unhooked===true?(n("ignoring process.getBuiltinModule call - module is soft-unhooked"),_._origGetBuiltinModule.apply(this,args)):T.call(this,args,true);};
  }

  function T(m,A){
    const g=m[0];
    const R=s(g);
    let O;if(R){
        O=g;

        if (g.startsWith("node:"))
          {
            const H=g.slice(5);

            if (s(H)) {
              (O = H);
            }
          }
      }else{if (A) {
        n("call to process.getBuiltinModule with unknown built-in id");
        return _._origGetBuiltinModule.apply(this,m);
      }try{O=t._resolveFilename(g,this)}catch(H){
        n('Module._resolveFilename("%s") threw %j, calling original Module.require',g,H.message);
        return _._origRequire.apply(this,m);
      }}
    let I;
    let b;
    n("processing %s module require('%s'): %s",R===true?"core":"non-core",g,O);

    if (_._cache.has(O,R)===true) {
      n("returning already patched cached module: %s",O);
      return _._cache.get(O,R);
    }

    const L=p.has(O);

    if (L===false) {
      p.add(O);
    }

    const U=A?_._origGetBuiltinModule.apply(this,m):_._origRequire.apply(this,m);if (L===true) {
        n("module is in the process of being patched already - ignoring: %s",O);
        return U;
      }
    p.delete(O);

    if (R===true) {if (h===true&&f.includes(O)===false) {
      n("ignoring core module not on whitelist: %s",O);
      return U;
    }I=O} else if(h===true&&f.includes(O)){
      const H=e.parse(O);
      I=H.name;
      b=H.dir;
    }else{
      const H=r(O);if (H===void 0) {
        n("could not parse filename: %s",O);
        return U;
      }
      I=H.name;
      b=H.basedir;
      const $=l(H);n("resolved filename to module: %s (id: %s, resolved: %s, basedir: %s)",I,g,$,b);let B=false;if(h){
      if (!g.startsWith(".")&&f.includes(g)) {
        I=g;
        B=true;
      }

      if (!f.includes(I)&&!f.includes($)) {
        return U;
      }

      if (f.includes($)&&$!==I) {
        I=$;
        B=true;
      }
    }if(!B){let F;try{F=require.resolve(I,{paths:[b]})}catch{
        n("could not resolve module: %s",I);
        _._cache.set(O,U,R);
        return U;
      }if (F!==O) {
        if (E===true) {
          I=I+e.sep+e.relative(b,O);
          n("preparing to process require of internal file: %s",I);
        } else {
          n("ignoring require of non-main module file: %s",F);
          _._cache.set(O,U,R);
          return U;
        }
      }}
    }

    _._cache.set(O,U,R);
    n("calling require hook: %s",I);
    const q=u(U,I,b);
    _._cache.set(O,q,R);
    n("returning module: %s",I);
    return q;
  }
}c.prototype.unhook=function(){
  this._unhooked=true;

  if (this._require===t.prototype.require) {
    t.prototype.require=this._origRequire;
    n("require unhook successful");
  } else {
    n("require unhook unsuccessful");
  }

  if (process.getBuiltinModule!==void 0) {
    if (this._getBuiltinModule===process.getBuiltinModule) {
      process.getBuiltinModule=this._origGetBuiltinModule;
      n("process.getBuiltinModule unhook successful");
    } else {
      n("process.getBuiltinModule unhook unsuccessful");
    }
  }
};function l(f){const d=e.sep!=="/"?f.path.split(e.sep).join("/"):f.path;return e.posix.join(f.name,d).replace(i,"")}return Cc.exports
}const CI=OU();const lu="/";class OA{hooks=[];children=new Map}class bU{_trie=new OA;_counter=0;insert(t){let n=this._trie;for(const r of t.moduleName.split(lu)){
  let o=n.children.get(r);

  if (!o) {
    o=new OA;
    n.children.set(r,o);
  }

  n=o;
}n.hooks.push({hook:t,insertedId:this._counter++})}search(t,{maintainInsertionOrder:n,fullOnly:r}={}){
  let o=this._trie;const s=[];let i=true;for(const a of t.split(lu)){
    const c=o.children.get(a);if(!c){i=false;break}

    if (!r) {
      s.push(...c.hooks);
    }

    o=c;
  }

  if (r&&i) {
    s.push(...o.hooks);
  }

  if (s.length===0) {
    return [];
  }

  if (s.length===1) {
    return [s[0].hook];
  }

  n&&s.sort((a, c) => a.insertedId-c.insertedId);
  return s.map(({hook}) => hook);
}}const CU=["afterEach","after","beforeEach","before","describe","it"].every(e => typeof global[e]=="function");class du{_moduleNameTrie=new bU;static _instance;constructor(){this._initialize()}_initialize(){new CI.Hook(null,{internals:true},(t,n,r)=>{
  const o=IU(n);
  const s=this._moduleNameTrie.search(o,{maintainInsertionOrder:true,fullOnly:r===void 0});
  for (const{onRequire} of s) {
    t=onRequire(t,n,r);
  }return t
})}register(t,n){
  const r={moduleName:t,onRequire:n};
  this._moduleNameTrie.insert(r);
  return r;
}static getInstance(){return CU?new du:this._instance=this._instance??new du}}function IU(e){return qr.sep!==lu?e.split(qr.sep).join(lu):e}
const Rr={exports:{}};
const qn={};
let bA;
function PU(){
  if (bA) {
    return qn;
  }bA=1;
  const e=[];
  const t=new WeakMap;
  const n=new WeakMap;
  const r=new Map;
  const o=[];

  const s={set(f,d,u){return t.get(f)[d](u)},get(f,d){if (d===Symbol.toStringTag) {
    return"Module";
  }const u=n.get(f)[d];if (typeof u=="function") {
    return u()
  }},defineProperty(f,d,u){if (!("value"in u)) {
    throw new Error("Getters/setters are not supported for exports property descriptors.");
  }return t.get(f)[d](u.value)}};

  function i(f,d,u,_,p){
    r.set(f,p);
    t.set(d,u);
    n.set(d,_);
    const E=new Proxy(d,s);

    e.forEach(h => h(f,E));

    o.push([f,E]);
  }let a=false;function c(){return a}function l(f){a=f}
  qn.register=i;
  qn.importHooks=e;
  qn.specifiers=r;
  qn.toHook=o;
  qn.getExperimentalPatchInternals=c;
  qn.setExperimentalPatchInternals=l;
  return qn;
}let CA;function MU(){
  if (CA) {
    return Rr.exports;
  }CA=1;
  const e=hc;
  const t=bI();
  const {fileURLToPath}=Zu;
  const {MessageChannel}=np;
  const {importHooks,specifiers,toHook,getExperimentalPatchInternals}=PU();
  function c(p){
    importHooks.push(p);

    toHook.forEach(([E,h]) => p(E,h));
  }function l(p){
  const E=importHooks.indexOf(p);

  if (E>-1) {
    importHooks.splice(E,1);
  }
}function f(p,E,h,T){
  const m=p(E,h,T);

  if (m&&m!==E) {
    (E.default = m);
  }
}let d;function u(){
    const{port1,port2}=new MessageChannel;
    let h=0;
    let T;

    d=R=>{
      h++;
      port1.postMessage(R);
    };

    port1.on("message",()=>{
      h--;

      if (T&&h<=0) {
        T();
      }
    }).unref();

    function m(){
      const R=setInterval(()=>{},1000/* 1e3 */);
      const O=new Promise(I=>{T=I}).then(()=>{clearInterval(R)});

      if (h===0) {
        T();
      }

      return O;
    }const A=port2;return{registerOptions:{data:{addHookMessagePort:A,include:[]},transferList:[A]},addHookMessagePort:A,waitForAllMessagesAcknowledged:m}
  }function _(p,E,h){
  if (!(this instanceof _)) {
    return new _(p,E,h);
  }

  if (typeof p=="function") {
    h=p;
    p=null;
    E=null;
  } else if (typeof E=="function") {
    h=E;
    E=null;
  }

  const T=E?E.internals===true:false;

  if (d&&Array.isArray(p)) {
    d(p);
  }

  this._iitmHook=(m,A)=>{
    const g=m;
    const R=m.startsWith("node:");
    let O;if (R) {
      m=m.replace(/^node:/,"");
    } else {
    if (m.startsWith("file://")) {
        try{m=fileURLToPath(m)}catch{}
      }const I=t(m);

    if (I) {
      m=I.name;
      O=I.basedir;
    }
  }if (p) {for (const I of p) {
      if(I===m){if(O){if (T) {
        m=m+e.sep+e.relative(O,fileURLToPath(g));
      } else if (!getExperimentalPatchInternals()&&!O.endsWith(specifiers.get(g))) {
        continue
      }}f(h,A,m,O)}
    }} else {
      f(h,A,m,O)
    }
  };

  c(this._iitmHook);
}
  _.prototype.unhook=function(){l(this._iitmHook)};
  Rr.exports=_;
  Rr.exports.Hook=_;
  Rr.exports.addHook=c;
  Rr.exports.removeHook=l;
  Rr.exports.createAddHookMessageChannel=u;
  return Rr.exports;
}const II=MU();function tr(e,t,n){
  let r;
  let o;
  try{o=e()}catch(s){r=s}finally{
    t(r,o);

    if (r&&!n) {
      throw r;
    }

    return o
  }
}async function vU(e,t,n){
  let r;
  let o;
  try{o=await e()}catch(s){r=s}finally{
    await t(r,o);

    if (r&&!n) {
      throw r;
    }

    return o
  }
}function ol(e){return typeof e=="function"&&typeof e.__original=="function"&&typeof e.__unwrap=="function"&&e.__wrapped===true;}class Ot extends SU{_modules;_hooks=[];_requireInTheMiddleSingleton=du.getInstance();_enabled=false;constructor(t,n,r){
  super(t,n,r);let o=this.init();

  if (o&&!Array.isArray(o)) {
    (o = [o]);
  }

  this._modules=o||[];

  if (this._config.enabled) {
    this.enable();
  }
}_wrap=(t,n,r)=>{
  if (ol(t[n])) {
    this._unwrap(t,n);
  }

  if (Xr.types.isProxy(t)) {
    const o=uu(Object.assign({},t),n,r);
    Object.defineProperty(t,n,{value:o});
    return o;
  } else {
    return uu(t,n,r)
  }
};_unwrap=(t, n) => Xr.types.isProxy(t)?Object.defineProperty(t,n,{value:t[n]}):cE(t,n);_massWrap=(t,n,r)=>{if (t) {
  if (!Array.isArray(t)) {
    (t = [t]);
  }
} else
  {C.diag.error("must provide one or more modules to patch");return}if(!(n&&Array.isArray(n))){C.diag.error("must provide one or more functions to wrap on modules");return}t.forEach(o=>{n.forEach(s=>{this._wrap(o,s,r)})})};_massUnwrap=(t,n)=>{if (t) {
  if (!Array.isArray(t)) {
    (t = [t]);
  }
} else
  {C.diag.error("must provide one or more modules to patch");return}if(!(n&&Array.isArray(n))){C.diag.error("must provide one or more functions to wrap on modules");return}t.forEach(r=>{n.forEach(o=>{this._unwrap(r,o)})})};_warnOnPreloadedModules(){this._modules.forEach(t=>{const{name}=t;try{
  const r=require.resolve(name);

  if (require.cache[r]) {
    this._diag.warn(`Module ${name} has been loaded before ${this.instrumentationName} so it might not work, please initialize it before requiring ${name}`);
  }
}catch{}})}_extractPackageVersion(t){try{
  const n=Mw.readFileSync(qr.join(t,"package.json"),{encoding:"utf8"});
  const r=JSON.parse(n).version;
  return typeof r=="string"?r:void 0
}catch{C.diag.warn("Failed extracting version",t)}}_onRequire(t,n,r,o){
  if (!o) {
    return typeof t.patch=="function"&&(t.moduleExports=n,this._enabled)?(this._diag.debug("Applying instrumentation patch for nodejs core module on require hook",{module:t.name}),t.patch(n)):n;
  }const s=this._extractPackageVersion(o);
  t.moduleVersion=s;

  if (t.name===r) {
    return IA(t.supportedVersions,s,t.includePrerelease)&&typeof t.patch=="function"&&(t.moduleExports=n,this._enabled)?(this._diag.debug("Applying instrumentation patch for module on require hook",{module:t.name,version:t.moduleVersion,baseDir:o}),t.patch(n,t.moduleVersion)):n;
  }

  const i=t.files??[];
  const a=qr.normalize(r);
  return i.filter(l => l.name===a).filter(l => IA(l.supportedVersions,s,t.includePrerelease)).reduce((l, f) => {
    f.moduleExports=l;
    return this._enabled?(this._diag.debug("Applying instrumentation patch for nodejs module file on require hook",{module:t.name,version:t.moduleVersion,fileName:f.name,baseDir:o}),f.patch(l,t.moduleVersion)):l;
  },n);
}enable(){if(!this._enabled){
  this._enabled=true;

  if (this._hooks.length>0) {for(const t of this._modules){
    if (typeof t.patch=="function"&&t.moduleExports) {
      this._diag.debug("Applying instrumentation patch for nodejs module on instrumentation enabled",{module:t.name,version:t.moduleVersion});
      t.patch(t.moduleExports,t.moduleVersion);
    }

    for (const n of t.files) {
      if (n.moduleExports) {
        this._diag.debug("Applying instrumentation patch for nodejs module file on instrumentation enabled",{module:t.name,version:t.moduleVersion,fileName:n.name});
        n.patch(n.moduleExports,t.moduleVersion);
      }
    }
  }return}

  this._warnOnPreloadedModules();for(const t of this._modules){
    const n=(i,a,c)=>{if(!c&&qr.isAbsolute(a)){
      const l=qr.parse(a);
      a=l.name;
      c=l.dir;
    }return this._onRequire(t,i,a,c)};

    const r=(i, a, c) => this._onRequire(t,i,a,c);

    const o=qr.isAbsolute(t.name)?new CI.Hook([t.name],{internals:true},r):this._requireInTheMiddleSingleton.register(t.name,r);
    this._hooks.push(o);const s=new II.Hook([t.name],{internals:false},n);this._hooks.push(s)
  }
}}disable(){if(this._enabled){this._enabled=false;for(const t of this._modules){
  if (typeof t.unpatch=="function"&&t.moduleExports) {
    this._diag.debug("Removing instrumentation patch for nodejs module on instrumentation disabled",{module:t.name,version:t.moduleVersion});
    t.unpatch(t.moduleExports,t.moduleVersion);
  }

  for (const n of t.files) {
    if (n.moduleExports) {
      this._diag.debug("Removing instrumentation patch for nodejs module file on instrumentation disabled",{module:t.name,version:t.moduleVersion,fileName:n.name});
      n.unpatch(n.moduleExports,t.moduleVersion);
    }
  }
}}}isEnabled(){return this._enabled}}function IA(e,t,n){return typeof t === "undefined"?e.includes("*"):e.some(r => F0(t,r,{includePrerelease:n}));}class ft{name;supportedVersions;patch;unpatch;files;constructor(t,n,r,o,s){
  this.name=t;
  this.supportedVersions=n;
  this.patch=r;
  this.unpatch=o;
  this.files=s||[];
}}class Hn{supportedVersions;patch;unpatch;name;constructor(t,n,r,o){
  this.supportedVersions=n;
  this.patch=r;
  this.unpatch=o;
  this.name=hc.normalize(t);
}}const vo = {
  STABLE: 1,
  OLD: 2,
  DUPLICATE: 3,

  // reverse mapping
  1: "STABLE",

  2: "OLD",
  3: "DUPLICATE"
};function LU(e,t){let n=vo.OLD;const r=t?.split(",").map(o => o.trim()).filter(o => o!=="");for (const o of r??[]) {
  if (o.toLowerCase()===`${e}/dup`)
    {n=vo.DUPLICATE;break} else {
    if (o.toLowerCase()===e) {
      (n = vo.STABLE);
    }
  }
}return n}
const wU=Object.freeze(Object.defineProperty({__proto__:null,InstrumentationBase:Ot,InstrumentationNodeModuleDefinition:ft,InstrumentationNodeModuleFile:Hn,get SemconvStability() {return vo},isWrapped:ol,registerInstrumentations:rl,safeExecuteInTheMiddle:tr,safeExecuteInTheMiddleAsync:vU,semconvStabilityFromStr:LU},Symbol.toStringTag,{value:"Module"}));
const Le=YC(wU);
const dd={};
const ie={};
let PA;
function DU(){
  if (!PA) {
    PA=1;
    Object.defineProperty(ie,"__esModule",{value:true});
    ie.HTTP_FLAVOR_VALUE_HTTP_1_1=ie.NET_TRANSPORT_VALUE_IP_UDP=ie.NET_TRANSPORT_VALUE_IP_TCP=ie.ATTR_NET_TRANSPORT=ie.ATTR_NET_PEER_PORT=ie.ATTR_NET_PEER_NAME=ie.ATTR_NET_PEER_IP=ie.ATTR_NET_HOST_PORT=ie.ATTR_NET_HOST_NAME=ie.ATTR_NET_HOST_IP=ie.ATTR_HTTP_USER_AGENT=ie.ATTR_HTTP_URL=ie.ATTR_HTTP_TARGET=ie.ATTR_HTTP_STATUS_CODE=ie.ATTR_HTTP_SERVER_NAME=ie.ATTR_HTTP_SCHEME=ie.ATTR_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED=ie.ATTR_HTTP_RESPONSE_CONTENT_LENGTH=ie.ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED=ie.ATTR_HTTP_REQUEST_CONTENT_LENGTH=ie.ATTR_HTTP_METHOD=ie.ATTR_HTTP_HOST=ie.ATTR_HTTP_FLAVOR=ie.ATTR_HTTP_CLIENT_IP=ie.USER_AGENT_SYNTHETIC_TYPE_VALUE_TEST=ie.USER_AGENT_SYNTHETIC_TYPE_VALUE_BOT=ie.ATTR_USER_AGENT_SYNTHETIC_TYPE=void 0;
    ie.ATTR_USER_AGENT_SYNTHETIC_TYPE="user_agent.synthetic.type";
    ie.USER_AGENT_SYNTHETIC_TYPE_VALUE_BOT="bot";
    ie.USER_AGENT_SYNTHETIC_TYPE_VALUE_TEST="test";
    ie.ATTR_HTTP_CLIENT_IP="http.client_ip";
    ie.ATTR_HTTP_FLAVOR="http.flavor";
    ie.ATTR_HTTP_HOST="http.host";
    ie.ATTR_HTTP_METHOD="http.method";
    ie.ATTR_HTTP_REQUEST_CONTENT_LENGTH="http.request_content_length";
    ie.ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED="http.request_content_length_uncompressed";
    ie.ATTR_HTTP_RESPONSE_CONTENT_LENGTH="http.response_content_length";
    ie.ATTR_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED="http.response_content_length_uncompressed";
    ie.ATTR_HTTP_SCHEME="http.scheme";
    ie.ATTR_HTTP_SERVER_NAME="http.server_name";
    ie.ATTR_HTTP_STATUS_CODE="http.status_code";
    ie.ATTR_HTTP_TARGET="http.target";
    ie.ATTR_HTTP_URL="http.url";
    ie.ATTR_HTTP_USER_AGENT="http.user_agent";
    ie.ATTR_NET_HOST_IP="net.host.ip";
    ie.ATTR_NET_HOST_NAME="net.host.name";
    ie.ATTR_NET_HOST_PORT="net.host.port";
    ie.ATTR_NET_PEER_IP="net.peer.ip";
    ie.ATTR_NET_PEER_NAME="net.peer.name";
    ie.ATTR_NET_PEER_PORT="net.peer.port";
    ie.ATTR_NET_TRANSPORT="net.transport";
    ie.NET_TRANSPORT_VALUE_IP_TCP="ip_tcp";
    ie.NET_TRANSPORT_VALUE_IP_UDP="ip_udp";
    ie.HTTP_FLAVOR_VALUE_HTTP_1_1="1.1";
  }

  return ie;
}
const fd={};
let MA;
function UU(){
  if (!MA) {
    MA=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.AttributeNames=void 0;

      (t => {
        t.HTTP_ERROR_NAME="http.error_name";
        t.HTTP_ERROR_MESSAGE="http.error_message";
        t.HTTP_STATUS_TEXT="http.status_text";
      })(e.AttributeNames||(e.AttributeNames={}));
    })(fd);
  }

  return fd;
}
const Jt={};
let vA;
function LA(){
  if (!vA) {
    vA=1;
    Object.defineProperty(Jt,"__esModule",{value:true});
    Jt.DEFAULT_QUERY_STRINGS_TO_REDACT=Jt.STR_REDACTED=Jt.SYNTHETIC_BOT_NAMES=Jt.SYNTHETIC_TEST_NAMES=void 0;
    Jt.SYNTHETIC_TEST_NAMES=["alwayson"];
    Jt.SYNTHETIC_BOT_NAMES=["googlebot","bingbot"];
    Jt.STR_REDACTED="REDACTED";
    Jt.DEFAULT_QUERY_STRINGS_TO_REDACT=["sig","Signature","AWSAccessKeyId","X-Goog-Signature"];
  }

  return Jt;
}
let _d;
let wA;
function kU(){
  if (wA) {
    return _d;
  }wA=1;const e=Xr;function t(n,r){
    Error.captureStackTrace(this,t);
    this.name=this.constructor.name;
    this.message=n;
    this.input=r;
  }
  e.inherits(t,Error);
  _d=t;
  return _d;
}
let pd;
let DA;
function GU(){
  if (DA) {
    return pd;
  }DA=1;function e(o){return o===34||o===40||o===41||o===44||o===47||o>=58&&o<=64||o>=91&&o<=93||o===123||o===125}function t(o){return o===33||o>=35&&o<=39||o===42||o===43||o===45||o===46||o>=48&&o<=57||o>=65&&o<=90||o>=94&&o<=122||o===124||o===126}function n(o){return o>=32&&o<=126}function r(o){return o>=128&&o<=255}
  pd={isDelimiter:e,isTokenChar:t,isExtended:r,isPrint:n};
  return pd;
}
let Ed;
let UA;
function VU(){
  if (UA) {
    return Ed;
  }UA=1;
  const e=Xr;
  const t=kU();
  const n=GU();
  const r=n.isDelimiter;
  const o=n.isTokenChar;
  const s=n.isExtended;
  const i=n.isPrint;
  function a(f){return f.replace(/\\(.)/g,"$1");}function c(f,d){return e.format("Unexpected character '%s' at index %d",f.charAt(d),d)}function l(f){
  let d=false;
  let u=false;
  let _=false;
  let p={};
  const E=[];
  let h=-1;
  let T=-1;
  let m;
  let A;
  for (var g=0; g<f.length; g++) {
    A=f.charCodeAt(g);

    if (m===void 0) {if (g!==0&&h===-1&&(A===32||A===9)) {
      continue;
    }if (o(A)) {
      if (h===-1) {
        (h = g);
      }
    } else if (A===61&&h!==-1) {
      m=f.slice(h,g).toLowerCase();
      h=-1;
    } else {
      throw new t(c(f,g),f)
    }} else if (u&&(A===9||i(A)||s(A))) {
      u=false;
    } else if(o(A)){
      if (T!==-1) {
        throw new t(c(f,g),f);
      }

      if (h===-1) {
        (h = g);
      }
    }else if (r(A)||s(A)) {
      if (_) {
        if (A===34) {
          _=false;
          T=g;
        } else if (A===92) {
          h===-1&&(h=g);
          u=d=true;
        } else if (h===-1) {
          (h = g);
        }
      } else if (A===34&&f.charCodeAt(g-1)===61) {
        _=true;
      } else if ((A===44||A===59)&&(h!==-1||T!==-1)) {
        if (h!==-1) {
          T===-1&&(T=g);
          p[m]=d?a(f.slice(h,T)):f.slice(h,T);
        } else {
          p[m]="";
        }

        if (A===44) {
          E.push(p);
          p={};
        }

        m=void 0;
        h=T=-1;
      } else {
        throw new t(c(f,g),f);
      }
    } else if (A===32||A===9) {if (T!==-1) {
      continue;
    }if (_) {
      if (h===-1) {
        (h = g);
      }
    } else if (h!==-1) {
      T=g;
    } else {
      throw new t(c(f,g),f)
    }} else {
      throw new t(c(f,g),f);
    }
  }if (m===void 0||_||h===-1&&T===-1||A===32||A===9) {
        throw new t("Unexpected end of input",f);
      }

  if (h!==-1) {
    T===-1&&(T=g);
    p[m]=d?a(f.slice(h,T)):f.slice(h,T);
  } else {
    p[m]="";
  }

  E.push(p);
  return E;
}
  Ed=l;
  return Ed;
}let kA;function xU(){
  if (!kA) {
    kA=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.headerCapture = void 0;
      e.getIncomingStableRequestMetricAttributesOnResponse = void 0;
      e.getIncomingRequestMetricAttributesOnResponse = void 0;
      e.getIncomingRequestAttributesOnResponse = void 0;
      e.getIncomingRequestMetricAttributes = void 0;
      e.getIncomingRequestAttributes = void 0;
      e.getRemoteClientAddress = void 0;
      e.getOutgoingStableRequestMetricAttributesOnResponse = void 0;
      e.getOutgoingRequestMetricAttributesOnResponse = void 0;
      e.getOutgoingRequestAttributesOnResponse = void 0;
      e.setAttributesFromHttpKind = void 0;
      e.getOutgoingRequestMetricAttributes = void 0;
      e.getOutgoingRequestAttributes = void 0;
      e.extractHostnameAndPort = void 0;
      e.isValidOptionsType = void 0;
      e.getRequestInfo = void 0;
      e.isCompressed = void 0;
      e.setResponseContentLengthAttribute = void 0;
      e.setRequestContentLengthAttribute = void 0;
      e.setSpanWithError = void 0;
      e.satisfiesPattern = void 0;
      e.parseResponseStatus = void 0;
      e.getAbsoluteUrl = void 0;
      const t=Pe();
      const n=pt();
      const r=DU();
      const o=dn;
      const s=Le;
      const i=Zu;
      const a=UU();
      const c=LA();
      const l=LA();
      const f=VU();

      const d=(v,w,z="http:",j=Array.from(l.DEFAULT_QUERY_STRINGS_TO_REDACT))=>{
        const ee=v||{};
        const te=ee.protocol||z;
        const _e=(ee.port||"").toString();
        let se=ee.path||"/";
        let ue=ee.host||ee.hostname||w.host||"localhost";

        if (!ue.includes(":")&&_e&&_e!=="80"&&_e!=="443") {
          (ue += `:${_e}`);
        }

        if (se.includes("?")) {
          const ve=i.parse(se);
          const we=ve.pathname||"";
          const qe=ve.query||"";
          const Mt=new URLSearchParams(qe);
          const it=j||[];
          for (const nt of it) {
            if (Mt.has(nt)&&Mt.get(nt)!=="") {
              Mt.set(nt,l.STR_REDACTED);
            }
          }const at=Mt.toString();se=`${we}?${at}`
        }

        const Te=ee.auth?`${l.STR_REDACTED}:${l.STR_REDACTED}@`:"";return`${te}//${Te}${ue}${se}`
      };

      e.getAbsoluteUrl=d;const u=(v,w)=>{const z=v===t.SpanKind.CLIENT?400:500;return w&&w>=100&&w<z?t.SpanStatusCode.UNSET:t.SpanStatusCode.ERROR};e.parseResponseStatus=u;const _=(v,w)=>{if (typeof w=="string") {
        return w===v;
      }if (w instanceof RegExp) {
        return w.test(v);
      }if (typeof w=="function") {
        return w(v);
      }throw new TypeError("Pattern is in unsupported datatype")};e.satisfiesPattern=_;const p=(v,w,z)=>{
      const j=w.message;

      if (z&s.SemconvStability.OLD) {
        v.setAttribute(a.AttributeNames.HTTP_ERROR_NAME,w.name);
        v.setAttribute(a.AttributeNames.HTTP_ERROR_MESSAGE,j);
      }

      if (z&s.SemconvStability.STABLE) {
        v.setAttribute(n.ATTR_ERROR_TYPE,w.name);
      }

      v.setStatus({code:t.SpanStatusCode.ERROR,message:j});
      v.recordException(w);
    };e.setSpanWithError=p;const E=(v,w)=>{
      const z=T(v.headers);

      if (z!==null) {
        if ((0,e.isCompressed)(v.headers)) {
          w[r.ATTR_HTTP_REQUEST_CONTENT_LENGTH]=z;
        } else {
          w[r.ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED]=z;
        }
      }
    };e.setRequestContentLengthAttribute=E;const h=(v,w)=>{
      const z=T(v.headers);

      if (z!==null) {
        if ((0,e.isCompressed)(v.headers)) {
          w[r.ATTR_HTTP_RESPONSE_CONTENT_LENGTH]=z;
        } else {
          w[r.ATTR_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED]=z;
        }
      }
    };e.setResponseContentLengthAttribute=h;function T(v){const w=v["content-length"];if (w===void 0) {
        return null;
      }const z=parseInt(w,10);return isNaN(z)?null:z}const m=v=>{const w=v["content-encoding"];return!!w&&w!=="identity"};e.isCompressed=m;function A(v){
      const {hostname,pathname,port,username,password,search,protocol,hash,href,origin,host}=new URL(v);
      const qe={protocol:protocol,hostname:hostname&&hostname[0]==="["?hostname.slice(1,-1):hostname,hash:hash,search:search,pathname:pathname,path:`${pathname||""}${search||""}`,href:href,origin:origin,host:host};

      if (port!=="") {
        (qe.port = Number(port));
      }

      if ((username || password)) {
        (qe.auth = `${decodeURIComponent(username)}:${decodeURIComponent(password)}`);
      }

      return qe;
    }const g=(v,w,z)=>{
        let j;
        let ee;
        let te;
        let _e=false;
        if(typeof w=="string"){
          try{
            const ue=A(w);
            te=ue;
            j=ue.pathname||"/";
          }catch(ue){
            _e=true;
            v.verbose("Unable to parse URL provided to HTTP request, using fallback to determine path. Original error:",ue);
            te={path:w};
            j=te.path||"/";
          }
          ee=`${te.protocol||"http:"}//${te.host}`;

          if (z!==void 0) {
            Object.assign(te,z);
          }
        }else if (w instanceof i.URL) {
          te={protocol:w.protocol,hostname:typeof w.hostname=="string"&&w.hostname.startsWith("[")?w.hostname.slice(1,-1):w.hostname,path:`${w.pathname||""}${w.search||""}`};

          if (w.port!=="") {
            (te.port = Number(w.port));
          }

          if ((w.username || w.password)) {
            (te.auth = `${w.username}:${w.password}`);
          }

          j=w.pathname;
          ee=w.origin;

          if (z!==void 0) {
            Object.assign(te,z);
          }
        } else {
          te=Object.assign({protocol:w.host?"http:":void 0},w);const ue=te.host||(te.port!=null?`${te.hostname}${te.port}`:te.hostname);
          ee=`${te.protocol||"http:"}//${ue}`;
          j=w.pathname;

          if (!j&&te.path) {
            try{j=new URL(te.path,ee).pathname||"/"}catch{j="/"}
          }
        }const se=te.method?te.method.toUpperCase():"GET";return{origin:ee,pathname:j,method:se,optionsParsed:te,invalidUrl:_e}
      };e.getRequestInfo=g;const R=v=>{if (!v) {
        return false;
      }const w=typeof v;return w==="string"||w==="object"&&!Array.isArray(v)};e.isValidOptionsType=R;const O=v=>{
      if (v.hostname&&v.port) {
        return{hostname:v.hostname,port:v.port};
      }
      const w=v.host?.match(/^([^:/ ]+)(:\d{1,5})?/)||null;
      const z=v.hostname||(w===null?"localhost":w[1]);
      let j=v.port;

      if (!j) {
        if (w&&w[2]) {
          j=w[2].substring(1);
        } else {
          j=v.protocol==="https:"?"443":"80";
        }
      }

      return {hostname:z,port:j};
    };e.extractHostnameAndPort=O;const I=(v,w,z,j)=>{
      const ee=w.hostname;
      const te=w.port;
      const _e=v.method??"GET";
      const se=K(_e);
      const ue=v.headers||{};
      const Te=ue["user-agent"];
      const ve=(0,e.getAbsoluteUrl)(v,ue,`${w.component}:`,w.redactedQueryParams);
      const we={[r.ATTR_HTTP_URL]:ve,[r.ATTR_HTTP_METHOD]:_e,[r.ATTR_HTTP_TARGET]:v.path||"/",[r.ATTR_NET_PEER_NAME]:ee,[r.ATTR_HTTP_HOST]:ue.host??`${ee}:${te}`};
      const qe={[n.ATTR_HTTP_REQUEST_METHOD]:se,[n.ATTR_SERVER_ADDRESS]:ee,[n.ATTR_SERVER_PORT]:Number(te),[n.ATTR_URL_FULL]:ve,[n.ATTR_USER_AGENT_ORIGINAL]:Te};

      if (_e!==se) {
        (qe[n.ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = _e);
      }

      if (j&&Te) {
        (qe[r.ATTR_USER_AGENT_SYNTHETIC_TYPE] = U(Te));
      }

      if (Te!==void 0) {
        (we[r.ATTR_HTTP_USER_AGENT] = Te);
      }

      switch (z) {
      case s.SemconvStability.STABLE:
        {
          return Object.assign(qe,w.hookAttributes);
        }
      case s.SemconvStability.OLD:
        {
          return Object.assign(we,w.hookAttributes)
        }
      }

      return Object.assign(we,qe,w.hookAttributes)
    };e.getOutgoingRequestAttributes=I;const b=v=>{
        const w={};
        w[r.ATTR_HTTP_METHOD]=v[r.ATTR_HTTP_METHOD];
        w[r.ATTR_NET_PEER_NAME]=v[r.ATTR_NET_PEER_NAME];
        return w;
      };e.getOutgoingRequestMetricAttributes=b;const L=(v,w)=>{
      if (v) {
        w[r.ATTR_HTTP_FLAVOR]=v;
        v.toUpperCase()!=="QUIC"?w[r.ATTR_NET_TRANSPORT]=r.NET_TRANSPORT_VALUE_IP_TCP:w[r.ATTR_NET_TRANSPORT]=r.NET_TRANSPORT_VALUE_IP_UDP;
      }
    };e.setAttributesFromHttpKind=L;

      const U=v=>{const w=String(v).toLowerCase();for (const z of c.SYNTHETIC_TEST_NAMES) {
        if (w.includes(z)) {
          return r.USER_AGENT_SYNTHETIC_TYPE_VALUE_TEST;
        }
      }for (const z of c.SYNTHETIC_BOT_NAMES) {
        if (w.includes(z)) {
          return r.USER_AGENT_SYNTHETIC_TYPE_VALUE_BOT
        }
      }};

      const q=(v,w)=>{
        const {statusCode,statusMessage,httpVersion,socket}=v;
        const _e={};
        const se={};

        if (statusCode!=null) {
          (se[n.ATTR_HTTP_RESPONSE_STATUS_CODE] = statusCode);
        }

        if (socket) {
          const{remoteAddress,remotePort}=socket;
          _e[r.ATTR_NET_PEER_IP]=remoteAddress;
          _e[r.ATTR_NET_PEER_PORT]=remotePort;
          se[n.ATTR_NETWORK_PEER_ADDRESS]=remoteAddress;
          se[n.ATTR_NETWORK_PEER_PORT]=remotePort;
          se[n.ATTR_NETWORK_PROTOCOL_VERSION]=v.httpVersion;
        }

        (0,e.setResponseContentLengthAttribute)(v,_e);

        if (statusCode) {
          _e[r.ATTR_HTTP_STATUS_CODE]=statusCode;
          _e[a.AttributeNames.HTTP_STATUS_TEXT]=(statusMessage||"").toUpperCase();
        }

        (0,e.setAttributesFromHttpKind)(httpVersion,_e);

        switch (w) {
        case s.SemconvStability.STABLE:
          {
            return se;
          }
        case s.SemconvStability.OLD:
          {
            return _e
          }
        }

        return Object.assign(_e,se)
      };

      e.getOutgoingRequestAttributesOnResponse=q;const H=v=>{
        const w={};
        w[r.ATTR_NET_PEER_PORT]=v[r.ATTR_NET_PEER_PORT];
        w[r.ATTR_HTTP_STATUS_CODE]=v[r.ATTR_HTTP_STATUS_CODE];
        w[r.ATTR_HTTP_FLAVOR]=v[r.ATTR_HTTP_FLAVOR];
        return w;
      };e.getOutgoingRequestMetricAttributesOnResponse=H;const $=v=>{
      const w={};

      if (v[n.ATTR_NETWORK_PROTOCOL_VERSION]) {
        (w[n.ATTR_NETWORK_PROTOCOL_VERSION] = v[n.ATTR_NETWORK_PROTOCOL_VERSION]);
      }

      if (v[n.ATTR_HTTP_RESPONSE_STATUS_CODE]) {
        (w[n.ATTR_HTTP_RESPONSE_STATUS_CODE] = v[n.ATTR_HTTP_RESPONSE_STATUS_CODE]);
      }

      return w;
    };e.getOutgoingStableRequestMetricAttributesOnResponse=$;function B(v,w){const z=v.split(":");if (z.length===1) {
      if (w==="http") {
        return {host:z[0],port:"80"};
      }

      if (w==="https") {
        return {host:z[0],port:"443"};
      }

      return {host:z[0]};
    }if (z.length===2) {
        return{host:z[0],port:z[1]};
      }if(z[0].startsWith("[")){if(z[z.length-1].endsWith("]")){if (w==="http") {
        return{host:v,port:"80"};
      }if (w==="https") {
        return{host:v,port:"443"}
      }}else if (z[z.length-2].endsWith("]")) {
        return{host:z.slice(0,-1).join(":"),port:z[z.length-1]}
      }}return{host:v}}function F(v,w){const z=v.headers.forwarded;if(z){for (const te of X(z)) {
        if (te.host) {
          return B(te.host,te.proto)
        }
      }}const j=v.headers["x-forwarded-host"];if (typeof j=="string") {
      if (typeof v.headers["x-forwarded-proto"]=="string") {
        return B(j,v.headers["x-forwarded-proto"]);
      }

      if (Array.isArray(v.headers["x-forwarded-proto"])) {
        return B(j,v.headers["x-forwarded-proto"][0]);
      }

      return B(j);
    }if (Array.isArray(j)&&typeof j[0]=="string"&&j[0].length>0) {
      if (typeof v.headers["x-forwarded-proto"]=="string") {
        return B(j[0],v.headers["x-forwarded-proto"]);
      }

      if (Array.isArray(v.headers["x-forwarded-proto"])) {
        return B(j[0],v.headers["x-forwarded-proto"][0]);
      }

      return B(j[0]);
    }const ee=v.headers.host;return typeof ee=="string"&&ee.length>0?B(ee,w):null}function D(v){const w=v.headers.forwarded;if(w){for (const ee of X(w)) {
        if (ee.for) {
          return k(ee.for)
        }
      }}const z=v.headers["x-forwarded-for"];if(z){
      let ee;

      if (typeof z=="string") {
        ee=z;
      } else if (Array.isArray(z)) {
        (ee = z[0]);
      }

      if (typeof ee=="string") {
        ee=ee.split(",")[0].trim();
        return k(ee);
      }
    }const j=v.socket.remoteAddress;return j||null}e.getRemoteClientAddress=D;function k(v){try{const{hostname}=new URL(`http://${v}`);return hostname.startsWith("[")&&hostname.endsWith("]")?hostname.slice(1,-1):hostname;}catch{return v}}function Y(v,w,z){try{if (w.headers.host) {
        return new URL(w.url??"/",`${v}://${w.headers.host}`);
      }{const j=new URL(w.url??"/",`${v}://localhost`);return {pathname:j.pathname,search:j.search,toString() {return j.pathname+j.search}};}}catch(j){
        z.verbose("Unable to get URL from request",j);
        return {};
      }}const oe=(v,w,z)=>{
      const j=v.headers;
      const ee=j["user-agent"];
      const te=j["x-forwarded-for"];
      const _e=v.httpVersion;
      const se=j.host;
      const ue=se?.replace(/^(.*)(:[0-9]{1,5})/,"$1")||"localhost";
      const Te=v.method;
      const ve=K(Te);
      const we=F(v,w.component);
      const qe=w.serverName;
      const Mt=D(v);
      const it={[n.ATTR_HTTP_REQUEST_METHOD]:ve,[n.ATTR_URL_SCHEME]:w.component,[n.ATTR_SERVER_ADDRESS]:we?.host,[n.ATTR_NETWORK_PEER_ADDRESS]:v.socket.remoteAddress,[n.ATTR_NETWORK_PEER_PORT]:v.socket.remotePort,[n.ATTR_NETWORK_PROTOCOL_VERSION]:v.httpVersion,[n.ATTR_USER_AGENT_ORIGINAL]:ee};
      const at=Y(w.component,v,z);

      if (at?.pathname!=null) {
        (it[n.ATTR_URL_PATH] = at.pathname);
      }

      if (at.search) {
        (it[n.ATTR_URL_QUERY] = at.search.slice(1));
      }

      if (Mt!=null) {
        (it[n.ATTR_CLIENT_ADDRESS] = Mt);
      }

      if (we?.port!=null) {
        (it[n.ATTR_SERVER_PORT] = Number(we.port));
      }

      if (Te!==ve) {
        (it[n.ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = Te);
      }

      if (w.enableSyntheticSourceDetection&&ee) {
        (it[r.ATTR_USER_AGENT_SYNTHETIC_TYPE] = U(ee));
      }

      const nt={[r.ATTR_HTTP_URL]:at.toString(),[r.ATTR_HTTP_HOST]:se,[r.ATTR_NET_HOST_NAME]:ue,[r.ATTR_HTTP_METHOD]:Te,[r.ATTR_HTTP_SCHEME]:w.component};

      if (typeof te=="string") {
        (nt[r.ATTR_HTTP_CLIENT_IP] = te.split(",")[0]);
      }

      if (typeof qe=="string") {
        (nt[r.ATTR_HTTP_SERVER_NAME] = qe);
      }

      if (at?.pathname) {
        (nt[r.ATTR_HTTP_TARGET] = at?.pathname+at?.search||"/");
      }

      if (ee!==void 0) {
        (nt[r.ATTR_HTTP_USER_AGENT] = ee);
      }

      (0,e.setRequestContentLengthAttribute)(v,nt);
      (0,e.setAttributesFromHttpKind)(_e,nt);

      switch (w.semconvStability) {
      case s.SemconvStability.STABLE:
        {
          return Object.assign(it,w.hookAttributes);
        }
      case s.SemconvStability.OLD:
        {
          return Object.assign(nt,w.hookAttributes)
        }
      }

      return Object.assign(nt,it,w.hookAttributes)
    };e.getIncomingRequestAttributes=oe;const ae=v=>{
        const w={};
        w[r.ATTR_HTTP_SCHEME]=v[r.ATTR_HTTP_SCHEME];
        w[r.ATTR_HTTP_METHOD]=v[r.ATTR_HTTP_METHOD];
        w[r.ATTR_NET_HOST_NAME]=v[r.ATTR_NET_HOST_NAME];
        w[r.ATTR_HTTP_FLAVOR]=v[r.ATTR_HTTP_FLAVOR];
        return w;
      };e.getIncomingRequestMetricAttributes=ae;const ne=(v,w,z)=>{
      const {socket}=v;
      const {statusCode,statusMessage}=w;
      const _e={[n.ATTR_HTTP_RESPONSE_STATUS_CODE]:statusCode};
      const se=(0,o.getRPCMetadata)(t.context.active());
      const ue={};
      if(socket){
        const{localAddress,localPort,remoteAddress,remotePort}=socket;
        ue[r.ATTR_NET_HOST_IP]=localAddress;
        ue[r.ATTR_NET_HOST_PORT]=localPort;
        ue[r.ATTR_NET_PEER_IP]=remoteAddress;
        ue[r.ATTR_NET_PEER_PORT]=remotePort;
      }
      ue[r.ATTR_HTTP_STATUS_CODE]=statusCode;
      ue[a.AttributeNames.HTTP_STATUS_TEXT]=(statusMessage||"").toUpperCase();

      if (se?.type===o.RPCType.HTTP&&se.route!==void 0) {
        ue[n.ATTR_HTTP_ROUTE]=se.route;
        _e[n.ATTR_HTTP_ROUTE]=se.route;
      }

      switch (z) {
      case s.SemconvStability.STABLE:
        {
          return _e;
        }
      case s.SemconvStability.OLD:
        {
          return ue
        }
      }

      return Object.assign(ue,_e)
    };e.getIncomingRequestAttributesOnResponse=ne;const P=v=>{
      const w={};
      w[r.ATTR_HTTP_STATUS_CODE]=v[r.ATTR_HTTP_STATUS_CODE];
      w[r.ATTR_NET_HOST_PORT]=v[r.ATTR_NET_HOST_PORT];

      if (v[n.ATTR_HTTP_ROUTE]!==void 0) {
        (w[n.ATTR_HTTP_ROUTE] = v[n.ATTR_HTTP_ROUTE]);
      }

      return w;
    };e.getIncomingRequestMetricAttributesOnResponse=P;const M=v=>{
      const w={};

      if (v[n.ATTR_HTTP_ROUTE]!==void 0) {
        (w[n.ATTR_HTTP_ROUTE] = v[n.ATTR_HTTP_ROUTE]);
      }

      if (v[n.ATTR_HTTP_RESPONSE_STATUS_CODE]) {
        (w[n.ATTR_HTTP_RESPONSE_STATUS_CODE] = v[n.ATTR_HTTP_RESPONSE_STATUS_CODE]);
      }

      return w;
    };e.getIncomingStableRequestMetricAttributesOnResponse=M;function G(v,w){const z=new Map;for(let j=0,ee=w.length;j<ee;j++){const te=w[j].toLowerCase();z.set(te,te.replace(/-/g,"_"))}return (j,ee)=>{for(const te of z.keys()){
      const _e=ee(te);if (_e===void 0) {
            continue;
          }
      const se=z.get(te);
      const ue=`http.${v}.header.${se}`;

      if (typeof _e=="string") {
        j.setAttribute(ue,[_e]);
      } else if (Array.isArray(_e)) {
        j.setAttribute(ue,_e);
      } else {
        j.setAttribute(ue,[_e]);
      }
    }};}e.headerCapture=G;const V=new Set(["GET","HEAD","POST","PUT","DELETE","CONNECT","OPTIONS","TRACE","PATCH"]);function K(v){if (v==null) {
        return"GET";
      }const w=v.toUpperCase();return V.has(w)?w:"_OTHER"}function X(v){try{return f(v)}catch{return[]}}
    })(dd);
  }

  return dd;
}let GA;function $U(){
  if (GA) {
    return zi;
  }
  GA=1;
  Object.defineProperty(zi,"__esModule",{value:true});
  zi.HttpInstrumentation=void 0;
  const e=Pe();
  const t=dn;
  const n=Zu;
  const r=w0();
  const o=Le;
  const s=zu;
  const i=pt();
  const a=xU();
  class c extends o.InstrumentationBase{_spanNotEnded=new WeakSet;_headerCapture;_semconvStability=o.SemconvStability.OLD;constructor(f={}){
    super("@opentelemetry/instrumentation-http",r.VERSION,f);
    this._headerCapture=this._createHeaderCapture();
    this._semconvStability=(0,o.semconvStabilityFromStr)("http",process.env.OTEL_SEMCONV_STABILITY_OPT_IN);
  }_updateMetricInstruments(){
    this._oldHttpServerDurationHistogram=this.meter.createHistogram("http.server.duration",{description:"Measures the duration of inbound HTTP requests.",unit:"ms",valueType:e.ValueType.DOUBLE});
    this._oldHttpClientDurationHistogram=this.meter.createHistogram("http.client.duration",{description:"Measures the duration of outbound HTTP requests.",unit:"ms",valueType:e.ValueType.DOUBLE});
    this._stableHttpServerDurationHistogram=this.meter.createHistogram(i.METRIC_HTTP_SERVER_REQUEST_DURATION,{description:"Duration of HTTP server requests.",unit:"s",valueType:e.ValueType.DOUBLE,advice:{explicitBucketBoundaries:[0.005/* .005 */,0.01/* .01 */,0.025/* .025 */,0.05/* .05 */,0.075/* .075 */,0.1/* .1 */,0.25/* .25 */,0.5/* .5 */,0.75/* .75 */,1,2.5,5,7.5,10]}});
    this._stableHttpClientDurationHistogram=this.meter.createHistogram(i.METRIC_HTTP_CLIENT_REQUEST_DURATION,{description:"Duration of HTTP client requests.",unit:"s",valueType:e.ValueType.DOUBLE,advice:{explicitBucketBoundaries:[0.005/* .005 */,0.01/* .01 */,0.025/* .025 */,0.05/* .05 */,0.075/* .075 */,0.1/* .1 */,0.25/* .25 */,0.5/* .5 */,0.75/* .75 */,1,2.5,5,7.5,10]}});
  }_recordServerDuration(f,d,u){
    if (this._semconvStability&o.SemconvStability.OLD) {
      this._oldHttpServerDurationHistogram.record(f,d);
    }

    if (this._semconvStability&o.SemconvStability.STABLE) {
      this._stableHttpServerDurationHistogram.record(f/1000/* 1e3 */,u);
    }
  }_recordClientDuration(f,d,u){
    if (this._semconvStability&o.SemconvStability.OLD) {
      this._oldHttpClientDurationHistogram.record(f,d);
    }

    if (this._semconvStability&o.SemconvStability.STABLE) {
      this._stableHttpClientDurationHistogram.record(f/1000/* 1e3 */,u);
    }
  }setConfig(f={}){
    super.setConfig(f);
    this._headerCapture=this._createHeaderCapture();
  }init(){return[this._getHttpsInstrumentation(),this._getHttpInstrumentation()]}_getHttpInstrumentation(){return new o.InstrumentationNodeModuleDefinition("http",["*"],f=>{
    const d=f[Symbol.toStringTag]==="Module";if(!this.getConfig().disableOutgoingRequestInstrumentation){
      const u=this._wrap(f,"request",this._getPatchOutgoingRequestFunction("http"));
      const _=this._wrap(f,"get",this._getPatchOutgoingGetFunction(u));

      if (d) {
        f.default.request=u;
        f.default.get=_;
      }
    }

    if (!this.getConfig().disableIncomingRequestInstrumentation) {
      this._wrap(f.Server.prototype,"emit",this._getPatchIncomingRequestFunction("http"));
    }

    return f;
  },f=>{
    if (f!==void 0) {
      this.getConfig().disableOutgoingRequestInstrumentation||(this._unwrap(f,"request"),this._unwrap(f,"get"));
      this.getConfig().disableIncomingRequestInstrumentation||this._unwrap(f.Server.prototype,"emit");
    }
  });}_getHttpsInstrumentation(){return new o.InstrumentationNodeModuleDefinition("https",["*"],f=>{
    const d=f[Symbol.toStringTag]==="Module";if(!this.getConfig().disableOutgoingRequestInstrumentation){
      const u=this._wrap(f,"request",this._getPatchHttpsOutgoingRequestFunction("https"));
      const _=this._wrap(f,"get",this._getPatchHttpsOutgoingGetFunction(u));

      if (d) {
        f.default.request=u;
        f.default.get=_;
      }
    }

    if (!this.getConfig().disableIncomingRequestInstrumentation) {
      this._wrap(f.Server.prototype,"emit",this._getPatchIncomingRequestFunction("https"));
    }

    return f;
  },f=>{
    if (f!==void 0) {
      this.getConfig().disableOutgoingRequestInstrumentation||(this._unwrap(f,"request"),this._unwrap(f,"get"));
      this.getConfig().disableIncomingRequestInstrumentation||this._unwrap(f.Server.prototype,"emit");
    }
  });}_getPatchIncomingRequestFunction(f){return d => this._incomingRequestFunction(f,d);}_getPatchOutgoingRequestFunction(f){return d => this._outgoingRequestFunction(f,d);}_getPatchOutgoingGetFunction(f){return d => (_, ...p) => {
    const E=f(_,...p);
    E.end();
    return E;
  };}_getPatchHttpsOutgoingRequestFunction(f){return d=>{const u=this;return (p, ...E) => {
    if (f==="https"&&typeof p=="object"&&p?.constructor?.name!=="URL") {
      p=Object.assign({},p);
      u._setDefaultOptions(p);
    }

    return u._getPatchOutgoingRequestFunction(f)(d)(p,...E);
  };};}_setDefaultOptions(f){
    f.protocol=f.protocol||"https:";
    f.port=f.port||443;
  }_getPatchHttpsOutgoingGetFunction(f){return d=>{const u=this;return (p, ...E) => u._getPatchOutgoingGetFunction(f)(d)(p,...E);};}_traceClientRequest(f,d,u,_,p){
    if (this.getConfig().requestHook) {
      this._callRequestHook(d,f);
    }

    let E=false;

    f.prependListener("response",h=>{
      this._diag.debug("outgoingRequest on response()");

      if (f.listenerCount("response")<=1) {
        h.resume();
      }

      const T=(0,a.getOutgoingRequestAttributesOnResponse)(h,this._semconvStability);
      d.setAttributes(T);
      _=Object.assign(_,(0,a.getOutgoingRequestMetricAttributesOnResponse)(T));
      p=Object.assign(p,(0,a.getOutgoingStableRequestMetricAttributesOnResponse)(T));

      if (this.getConfig().responseHook) {
        this._callResponseHook(d,h);
      }

      this._headerCapture.client.captureRequestHeaders(d,A => f.getHeader(A));

      this._headerCapture.client.captureResponseHeaders(d,A => h.headers[A]);

      e.context.bind(e.context.active(),h);
      const m=()=>{
        this._diag.debug("outgoingRequest on end()");

        if (E) {
          return;
        }

        E=true;let A;

        if (h.aborted&&!h.complete) {
          A={code:e.SpanStatusCode.ERROR};
        } else {
          A={code:(0,a.parseResponseStatus)(e.SpanKind.CLIENT,h.statusCode)};
        }

        d.setStatus(A);

        if (this.getConfig().applyCustomAttributesOnSpan) {
          (0,o.safeExecuteInTheMiddle)(() => this.getConfig().applyCustomAttributesOnSpan(d,f,h),()=>{},true);
        }

        this._closeHttpSpan(d,e.SpanKind.CLIENT,u,_,p);
      };
      h.on("end",m);

      h.on(s.errorMonitor,A=>{
        this._diag.debug("outgoingRequest on error()",A);

        if (!E) {
          E=true;
          this._onOutgoingRequestError(d,_,p,u,A);
        }
      });
    });

    f.on("close",()=>{
      this._diag.debug("outgoingRequest on request close()");

      if (!(f.aborted||E)) {
        E=true;
        this._closeHttpSpan(d,e.SpanKind.CLIENT,u,_,p);
      }
    });

    f.on(s.errorMonitor,h=>{
      this._diag.debug("outgoingRequest on request error()",h);

      if (!E) {
        E=true;
        this._onOutgoingRequestError(d,_,p,u,h);
      }
    });

    this._diag.debug("http.ClientRequest return request");
    return f;
  }_incomingRequestFunction(f,d){const u=this;return function(p,...E){
    if (p!=="request") {
      return d.apply(this,[p,...E]);
    }
    const h=E[0];
    const T=E[1];
    const m=h.method||"GET";
    u._diag.debug(`${f} instrumentation incomingRequest`);

    if ((0,o.safeExecuteInTheMiddle)(() => u.getConfig().ignoreIncomingRequestHook?.(h),H=>{
      if (H!=null) {
        u._diag.error("caught ignoreIncomingRequestHook error: ",H);
      }
    },true)) {
      return e.context.with((0,t.suppressTracing)(e.context.active()),() => {
        e.context.bind(e.context.active(),h);
        e.context.bind(e.context.active(),T);
        return d.apply(this,[p,...E]);
      });
    }

    const A=h.headers;
    const g=(0,a.getIncomingRequestAttributes)(h,{component:f,serverName:u.getConfig().serverName,hookAttributes:u._callStartSpanHook(h,u.getConfig().startIncomingSpanHook),semconvStability:u._semconvStability,enableSyntheticSourceDetection:u.getConfig().enableSyntheticSourceDetection||false},u._diag);
    const R={kind:e.SpanKind.SERVER,attributes:g};
    const O=(0,t.hrTime)();
    const I=(0,a.getIncomingRequestMetricAttributes)(g);
    const b={[i.ATTR_HTTP_REQUEST_METHOD]:g[i.ATTR_HTTP_REQUEST_METHOD],[i.ATTR_URL_SCHEME]:g[i.ATTR_URL_SCHEME]};

    if (g[i.ATTR_NETWORK_PROTOCOL_VERSION]) {
      (b[i.ATTR_NETWORK_PROTOCOL_VERSION] = g[i.ATTR_NETWORK_PROTOCOL_VERSION]);
    }

    const L=e.propagation.extract(e.ROOT_CONTEXT,A);
    const U=u._startHttpSpan(m,R,L);
    const q={type:t.RPCType.HTTP,span:U};
    return e.context.with((0,t.setRPCMetadata)(e.trace.setSpan(L,U),q),()=>{
      e.context.bind(e.context.active(),h);
      e.context.bind(e.context.active(),T);

      if (u.getConfig().requestHook) {
        u._callRequestHook(U,h);
      }

      if (u.getConfig().responseHook) {
        u._callResponseHook(U,T);
      }

      u._headerCapture.server.captureRequestHeaders(U,$ => h.headers[$]);

      let H=false;
      T.on("close",()=>{
        if (!H) {
          u._onServerResponseFinish(h,T,U,I,b,O);
        }
      });

      T.on(s.errorMonitor,$=>{
        H=true;
        u._onServerResponseError(U,I,b,O,$);
      });

      return (0,o.safeExecuteInTheMiddle)(() => d.apply(this,[p,...E]),$=>{if ($) {
        u._onServerResponseError(U,I,b,O,$);
        throw $;
      }});
    });
  };}_outgoingRequestFunction(f,d){const u=this;return function(p,...E){
    if (!(0,a.isValidOptionsType)(p)) {
      return d.apply(this,[p,...E]);
    }
    const h=typeof E[0]=="object"&&(typeof p=="string"||p instanceof n.URL)?E.shift():void 0;
    const {method,invalidUrl,optionsParsed}=(0,a.getRequestInfo)(u._diag,p,h);
    if ((0,o.safeExecuteInTheMiddle)(() => u.getConfig().ignoreOutgoingRequestHook?.(optionsParsed),B=>{
      if (B!=null) {
        u._diag.error("caught ignoreOutgoingRequestHook error: ",B);
      }
    },true)) {
      return d.apply(this,[optionsParsed,...E]);
    }
    const {hostname,port}=(0,a.extractHostnameAndPort)(optionsParsed);
    const O=(0,a.getOutgoingRequestAttributes)(optionsParsed,{component:f,port:port,hostname:hostname,hookAttributes:u._callStartSpanHook(optionsParsed,u.getConfig().startOutgoingSpanHook),redactedQueryParams:u.getConfig().redactedQueryParams},u._semconvStability,u.getConfig().enableSyntheticSourceDetection||false);
    const I=(0,t.hrTime)();
    const b=(0,a.getOutgoingRequestMetricAttributes)(O);
    const L={[i.ATTR_HTTP_REQUEST_METHOD]:O[i.ATTR_HTTP_REQUEST_METHOD],[i.ATTR_SERVER_ADDRESS]:O[i.ATTR_SERVER_ADDRESS],[i.ATTR_SERVER_PORT]:O[i.ATTR_SERVER_PORT]};

    if (O[i.ATTR_HTTP_RESPONSE_STATUS_CODE]) {
      (L[i.ATTR_HTTP_RESPONSE_STATUS_CODE] = O[i.ATTR_HTTP_RESPONSE_STATUS_CODE]);
    }

    if (O[i.ATTR_NETWORK_PROTOCOL_VERSION]) {
      (L[i.ATTR_NETWORK_PROTOCOL_VERSION] = O[i.ATTR_NETWORK_PROTOCOL_VERSION]);
    }

    const U={kind:e.SpanKind.CLIENT,attributes:O};
    const q=u._startHttpSpan(method,U);
    const H=e.context.active();
    const $=e.trace.setSpan(H,q);

    if (optionsParsed.headers) {
      optionsParsed.headers=Object.assign({},optionsParsed.headers);
    } else {
      optionsParsed.headers={};
    }

    e.propagation.inject($,optionsParsed.headers);

    return e.context.with($,()=>{
      const B=E[E.length-1];

      if (typeof B=="function") {
        (E[E.length-1] = e.context.bind(H,B));
      }

      const F=(0,o.safeExecuteInTheMiddle)(() => invalidUrl?d.apply(this,[p,...E]):d.apply(this,[optionsParsed,...E]),D=>{if (D) {
          u._onOutgoingRequestError(q,b,L,I,D);
          throw D;
        }});
      u._diag.debug(`${f} instrumentation outgoingRequest`);
      e.context.bind(H,F);
      return u._traceClientRequest(F,q,I,b,L);
    });
  };}_onServerResponseFinish(f,d,u,_,p,E){
    const h=(0,a.getIncomingRequestAttributesOnResponse)(f,d,this._semconvStability);
    _=Object.assign(_,(0,a.getIncomingRequestMetricAttributesOnResponse)(h));
    p=Object.assign(p,(0,a.getIncomingStableRequestMetricAttributesOnResponse)(h));

    this._headerCapture.server.captureResponseHeaders(u,m => d.getHeader(m));

    u.setAttributes(h).setStatus({code:(0,a.parseResponseStatus)(e.SpanKind.SERVER,d.statusCode)});
    const T=h[i.ATTR_HTTP_ROUTE];

    if (T) {
      u.updateName(`${f.method||"GET"} ${T}`);
    }

    if (this.getConfig().applyCustomAttributesOnSpan) {
      (0,o.safeExecuteInTheMiddle)(() => this.getConfig().applyCustomAttributesOnSpan(u,f,d),()=>{},true);
    }

    this._closeHttpSpan(u,e.SpanKind.SERVER,E,_,p);
  }_onOutgoingRequestError(f,d,u,_,p){
    (0,a.setSpanWithError)(f,p,this._semconvStability);
    u[i.ATTR_ERROR_TYPE]=p.name;
    this._closeHttpSpan(f,e.SpanKind.CLIENT,_,d,u);
  }_onServerResponseError(f,d,u,_,p){
    (0,a.setSpanWithError)(f,p,this._semconvStability);
    u[i.ATTR_ERROR_TYPE]=p.name;
    this._closeHttpSpan(f,e.SpanKind.SERVER,_,d,u);
  }_startHttpSpan(f,d,u=e.context.active()){
    const _=d.kind===e.SpanKind.CLIENT?this.getConfig().requireParentforOutgoingSpans:this.getConfig().requireParentforIncomingSpans;let p;const E=e.trace.getSpan(u);

    if (_===true&&(!E||!e.trace.isSpanContextValid(E.spanContext()))) {
      p=e.trace.wrapSpanContext(e.INVALID_SPAN_CONTEXT);
    } else if (_===true&&E?.spanContext().isRemote) {
      p=E;
    } else {
      p=this.tracer.startSpan(f,d,u);
    }

    this._spanNotEnded.add(p);
    return p;
  }_closeHttpSpan(f,d,u,_,p){
    if (!this._spanNotEnded.has(f)) {
      return;
    }
    f.end();
    this._spanNotEnded.delete(f);
    const E=(0,t.hrTimeToMilliseconds)((0,t.hrTimeDuration)(u,(0,t.hrTime)()));

    if (d===e.SpanKind.SERVER) {
      this._recordServerDuration(E,_,p);
    } else if (d===e.SpanKind.CLIENT) {
      this._recordClientDuration(E,_,p);
    }
  }_callResponseHook(f,d){(0,o.safeExecuteInTheMiddle)(() => this.getConfig().responseHook(f,d),()=>{},true)}_callRequestHook(f,d){(0,o.safeExecuteInTheMiddle)(() => this.getConfig().requestHook(f,d),()=>{},true)}_callStartSpanHook(f,d){if (typeof d=="function") {
    return (0,o.safeExecuteInTheMiddle)(() => d(f),()=>{},true);
  }}_createHeaderCapture(){const f=this.getConfig();return{client:{captureRequestHeaders:(0,a.headerCapture)("request",f.headersToSpanAttributes?.client?.requestHeaders??[]),captureResponseHeaders:(0,a.headerCapture)("response",f.headersToSpanAttributes?.client?.responseHeaders??[])},server:{captureRequestHeaders:(0,a.headerCapture)("request",f.headersToSpanAttributes?.server?.requestHeaders??[]),captureResponseHeaders:(0,a.headerCapture)("response",f.headersToSpanAttributes?.server?.responseHeaders??[])}}}}
  zi.HttpInstrumentation=c;
  return zi;
}let VA;function BU(){
  if (!VA) {
    VA=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.HttpInstrumentation=void 0;
      const t=$U();Object.defineProperty(e,"HttpInstrumentation",{enumerable:true,get() {return t.HttpInstrumentation}})
    })(td);
  }

  return td;
}const HU=BU();
const le=typeof __SENTRY_DEBUG__ === "undefined"||__SENTRY_DEBUG__;
const ye=globalThis;
const Ze="10.29.0";
function Yn(){
  Sc(ye);
  return ye;
}function Sc(e){
  const t=e.__SENTRY__=e.__SENTRY__||{};
  t.version=t.version||Ze;
  t[Ze]=t[Ze]||{};
  return t[Ze];
}function Zo(e,t,n=ye){
  const r=n.__SENTRY__=n.__SENTRY__||{};
  const o=r[Ze]=r[Ze]||{};
  return o[e]||(o[e]=t())
}
const PI=["debug","info","warn","error","log","assert","trace"];
const FU="Sentry Logger ";
const fu={};
function an(e){
  if (!("console"in ye)) {
    return e();
  }
  const t=ye.console;
  const n={};
  const r=Object.keys(fu);
  r.forEach(o=>{
    const s=fu[o];
    n[o]=t[o];
    t[o]=s;
  });try{return e()}finally{r.forEach(o=>{t[o]=n[o]})}
}function YU(){lE().enabled=true}function jU(){lE().enabled=false}function MI(){return lE().enabled}function qU(...e){uE("log",...e)}function WU(...e){uE("warn",...e)}function KU(...e){uE("error",...e)}function uE(e,...t){
  if (le&&MI()) {
    an(()=>{ye.console[e](`${FU}[${e}]:`,...t)});
  }
}function lE(){return le?Zo("loggerSettings",() => ({
  enabled:false
})):{enabled:false};}
const x={enable:YU,disable:jU,isEnabled:MI,log:qU,warn:WU,error:KU};
const vI=50;
const LI="?";
const xA=/\(error: (.*)\)/;
const $A=/captureMessage|captureException/;
function wI(...e){const t=e.sort((n, r) => n[0]-r[0]).map(n => n[1]);return (n,r=0,o=0)=>{
  const s=[];

  const i=n.split(`
  `);

  for(let a=r;a<i.length;a++){
    let c=i[a];

    if (c.length>1024) {
      (c = c.slice(0,1024));
    }

    const l=xA.test(c)?c.replace(xA,"$1"):c;if(!l.match(/\S*Error: /)){for(const f of t){const d=f(l);if(d){s.push(d);break}}if (s.length>=vI+o) {
      break
    }}
  }return ZU(s.slice(o))
};}function zU(e){return Array.isArray(e)?wI(...e):e}function ZU(e){
  if (!e.length) {
    return[];
  }const t=Array.from(e);

  if (/sentryWrapped/.test(vc(t).function||"")) {
    t.pop();
  }

  t.reverse();

  if ($A.test(vc(t).function||"")) {
    t.pop();
    $A.test(vc(t).function||"")&&t.pop();
  }

  return t.slice(0,vI).map(n => ({
    ...n,
    filename:n.filename||vc(t).filename,
    function:n.function||LI
  }));
}function vc(e){return e[e.length-1]||{}}const hd="<anonymous>";function DI(e){try{return!e||typeof e!="function"?hd:e.name||hd}catch{return hd}}function UI(e){return"__v_isVNode"in e&&e.__v_isVNode?"[VueVNode]":"[VueViewModel]"}
const tu={};
const BA={};
function dE(e,t){
  tu[e]=tu[e]||[];
  tu[e].push(t);
}function fE(e,t){if(!BA[e]){BA[e]=true;try{t()}catch(n){
  if (le) {
    x.error(`Error while instrumenting ${e}`,n);
  }
}}}function _E(e,t){const n=e&&tu[e];if (n) {
  for (const r of n) {
    try{r(t)}catch(o){
      if (le) {
        x.error(`Error while triggering instrumentation handler.
        Type: ${e}
        Name: ${DI(r)}
        Error:`,o);
      }
    }
  }
}}let Td=null;function XU(e){
  const t="error";
  dE(t,e);
  fE(t,QU);
}function QU(...args) {
  Td=ye.onerror;

  ye.onerror=function(e,t,n,r,o){
    _E("error",{column:r,error:o,line:n,msg:e,url:t});
    return Td?Td.apply(this,args):false;
  };

  ye.onerror.__SENTRY_INSTRUMENTED__=true;
}let Sd=null;function JU(e){
  const t="unhandledrejection";
  dE(t,e);
  fE(t,ek);
}function ek(...args) {
  Sd=ye.onunhandledrejection;

  ye.onunhandledrejection=function(e){
    _E("unhandledrejection",e);
    return Sd?Sd.apply(this,args):true;
  };

  ye.onunhandledrejection.__SENTRY_INSTRUMENTED__=true;
}const kI=Object.prototype.toString;function _u(e){switch(kI.call(e)){case"[object Error]":case"[object Exception]":case"[object DOMException]":case "[object WebAssembly.Exception]":
  {
    return true;
  }default:
  {
    return eo(e,Error)
  }}}function sl(e,t){return kI.call(e)===`[object ${t}]`}function tk(e){return sl(e,"ErrorEvent")}function pu(e){return sl(e,"String")}function pE(e){return typeof e=="object"&&e!==null&&"__sentry_template_string__"in e&&"__sentry_template_values__"in e}function GI(e){return e===null||pE(e)||typeof e!="object"&&typeof e!="function"}function rc(e){return sl(e,"Object")}function nk(e){return typeof Event !== "undefined"&&eo(e,Event);}function rk(e){return typeof Element !== "undefined"&&eo(e,Element);}function ok(e){return sl(e,"RegExp")}function nr(e){return!!(e?.then&&typeof e.then=="function")}function sk(e){return rc(e)&&"nativeEvent"in e&&"preventDefault"in e&&"stopPropagation"in e}function eo(e,t){try{return e instanceof t}catch{return false;}}function VI(e){return!!(typeof e=="object"&&e!==null&&(e.__isVue||e._isVue||e.__v_isVNode))}
const ik=ye;
const ak=80;
function ck(e,t={}){if (!e) {
  return"<unknown>";
}try{
  let n=e;
  const r=5;
  const o=[];
  let s=0;
  let i=0;
  const a=" > ";
  const c=a.length;
  let l;
  const f=Array.isArray(t)?t:t.keyAttrs;
  const d=!Array.isArray(t)&&t.maxStringLength||ak;

  while (n&&s++<r&&(l=uk(n,f),!(l==="html"||s>1&&i+o.length*c+l.length>=d))) {
    o.push(l);
    i+=l.length;
    n=n.parentNode;
  }

  return o.reverse().join(a)
}catch{return"<unknown>"}}function uk(e,t){
  const n=e;
  const r=[];
  if (!n?.tagName) {
    return"";
  }if(ik.HTMLElement&&n instanceof HTMLElement&&n.dataset){if (n.dataset.sentryComponent) {
    return n.dataset.sentryComponent;
  }if (n.dataset.sentryElement) {
    return n.dataset.sentryElement
  }}r.push(n.tagName.toLowerCase());const o=t?.length?t.filter(i => n.getAttribute(i)).map(i => [i,n.getAttribute(i)]):null;if (o?.length) {
    o.forEach(i=>{r.push(`[${i[0]}="${i[1]}"]`)});
  } else {
  if (n.id) {
    r.push(`#${n.id}`);
  }

  const i=n.className;if(i&&pu(i)){const a=i.split(/\s+/);for (const c of a) {
      r.push(`.${c}`)
    }}
}const s=["aria-label","type","name","title","alt"];for(const i of s){
  const a=n.getAttribute(i);

  if (a) {
    r.push(`[${i}="${a}"]`);
  }
}return r.join("")
}function lk(e,t,n){
  if (!(t in e)) {
    return;
  }const r=e[t];if (typeof r!="function") {
    return;
  }const o=n(r);

  if (typeof o=="function") {
    dk(o,r);
  }

  try{e[t]=o}catch{
    if (le) {
      x.log(`Failed to replace method "${t}" in object`,e);
    }
  }
}function cn(e,t,n){try{Object.defineProperty(e,t,{value:n,writable:true,configurable:true})}catch{
  if (le) {
    x.log(`Failed to add non-enumerable property "${t}" to object`,e);
  }
}}function dk(e,t){try{
  const n=t.prototype||{};
  e.prototype = n;
  t.prototype = n;
  cn(e,"__sentry_original__",t);
}catch{}}function fk(e){return e.__sentry_original__}function xI(e){if (_u(e)) {
  return{message:e.message,name:e.name,stack:e.stack,...FA(e)};
}if (nk(e)) {
  const t={type:e.type,target:HA(e.target),currentTarget:HA(e.currentTarget),...FA(e)};

  if (typeof CustomEvent !== "undefined"&&eo(e,CustomEvent)) {
    (t.detail = e.detail);
  }

  return t;
} else {
  return e
}}function HA(e){try{return rk(e)?ck(e):Object.prototype.toString.call(e)}catch{return"<unknown>"}}function FA(e){if (typeof e=="object"&&e!==null) {const t={};for (const n in e) {
  if (Object.prototype.hasOwnProperty.call(e,n)) {
    (t[n] = e[n]);
  }
}return t} else {
  return{}
}}function _k(e){
  const t=Object.keys(xI(e));
  t.sort();
  return t[0]?t.join(", "):"[object has no keys]";
}function Eu(e,t=0){return typeof e!="string"||t===0||e.length<=t?e:`${e.slice(0,t)}...`}function pk(e,t){
  let n=e;const r=n.length;if (r<=150) {
      return n;
    }

  if (t>r) {
    (t = r);
  }

  let o=Math.max(t-60,0);

  if (o<5) {
    (o = 0);
  }

  let s=Math.min(o+140,r);

  if (s>r-5) {
    (s = r);
  }

  if (s===r) {
    (o = Math.max(s-140,0));
  }

  n=n.slice(o,s);

  if (o>0) {
    (n = `'{snip} ${n}`);
  }

  if (s<r) {
    (n += " {snip}");
  }

  return n;
}function Ek(e,t){
  if (!Array.isArray(e)) {
    return"";
  }const n=[];

  for (const o of e) {
    try{
      if (VI(o)) {
        n.push(UI(o));
      } else {
        n.push(String(o));
      }
    }catch{n.push("[value cannot be serialized]")}
  }

  return n.join(t)
}function Lo(e,t,n=false){return pu(e)?ok(t)?t.test(e):pu(t)?n?e===t:e.includes(t):false:false;}function mc(e,t=[],n=false){return t.some(r => Lo(e,r,n));}function hk(){const e=ye;return e.crypto||e.msCrypto}let md;function Tk(){return Math.random()*16}function Ft(e=hk()){
  try{if (e?.randomUUID) {
    return e.randomUUID().replace(/-/g,"");
  }}catch{}

  if (!md) {
    (md = `10000000100040008000${100000000000/* 1e11 */}`);
  }

  return md.replace(/[018]/g,t => (t^(Tk()&15)>>t/4).toString(16));
}function $I(e){return e.exception?.values?.[0]}function yo(e){const{message,event_id}=e;if (message) {
  return message;
}const r=$I(e);return r?r.type&&r.value?`${r.type}: ${r.value}`:r.type||r.value||event_id||"<unknown>":event_id||"<unknown>";}function Sk(e,t,n){
  const r=e.exception=e.exception||{};
  const o=r.values=r.values||[];
  const s=o[0]=o[0]||{};

  if (!s.value) {
    (s.value = "");
  }

  if (!s.type) {
    (s.type = "Error");
  }
}function EE(e,t){
  const n=$I(e);if (!n) {
    return;
  }
  const r={type:"generic",handled:true};
  const o=n.mechanism;
  n.mechanism={...r,...o,...t};

  if (t&&"data"in t)
    {const s={...o?.data,...t.data};n.mechanism.data=s}
}const mk=/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;function Ad(e){return parseInt(e||"",10)}function Ak(e){
  const t=e.match(mk)||[];
  const n=Ad(t[1]);
  const r=Ad(t[2]);
  const o=Ad(t[3]);
  return{buildmetadata:t[5],major:isNaN(n)?void 0:n,minor:isNaN(r)?void 0:r,patch:isNaN(o)?void 0:o,prerelease:t[4]}
}function YA(e){if (gk(e)) {
  return true;
}try{cn(e,"__sentry_captured__",true)}catch{}return false;}function gk(e){try{return e.__sentry_captured__}catch{}}const BI=1000/* 1e3 */;function Ac(){return Date.now()/BI}function Rk(){const{performance}=ye;if (!performance?.now||!performance.timeOrigin) {
  return Ac;
}const t=performance.timeOrigin;return () => (t+performance.now())/BI;}let jA;function oc(){return(jA??(jA=Rk()))()}function Nk(e){
  const t=oc();

  const n={sid:Ft(),init:true,timestamp:t,started:t,duration:0,status:"ok",errors:0,ignoreDuration:false,toJSON:() => Ok(n)};

  if (e) {
    ko(n,e);
  }

  return n;
}function ko(e,t={}){
  if (t.user) {
    !e.ipAddress&&t.user.ip_address&&(e.ipAddress=t.user.ip_address);
    !e.did&&!t.did&&(e.did=t.user.id||t.user.email||t.user.username);
  }

  e.timestamp=t.timestamp||oc();

  if (t.abnormal_mechanism) {
    (e.abnormal_mechanism = t.abnormal_mechanism);
  }

  if (t.ignoreDuration) {
    (e.ignoreDuration = t.ignoreDuration);
  }

  if (t.sid) {
    (e.sid = t.sid.length===32?t.sid:Ft());
  }

  if (t.init!==void 0) {
    (e.init = t.init);
  }

  if (!e.did&&t.did) {
    (e.did = `${t.did}`);
  }

  if (typeof t.started=="number") {
    (e.started = t.started);
  }

  if (e.ignoreDuration) {
    e.duration=void 0;
  } else if (typeof t.duration=="number") {
    e.duration=t.duration;
  } else
    {const n=e.timestamp-e.started;e.duration=n>=0?n:0}

  if (t.release) {
    (e.release = t.release);
  }

  if (t.environment) {
    (e.environment = t.environment);
  }

  if (!e.ipAddress&&t.ipAddress) {
    (e.ipAddress = t.ipAddress);
  }

  if (!e.userAgent&&t.userAgent) {
    (e.userAgent = t.userAgent);
  }

  if (typeof t.errors=="number") {
    (e.errors = t.errors);
  }

  if (t.status) {
    (e.status = t.status);
  }
}function yk(e,t){
  let n={};

  if (e.status==="ok") {
    (n = {status:"exited"});
  }

  ko(e,n);
}function Ok(e){return {sid:`${e.sid}`,init:e.init,started:new Date(e.started*1000/* 1e3 */).toISOString(),timestamp:new Date(e.timestamp*1000/* 1e3 */).toISOString(),status:e.status,errors:e.errors,did:typeof e.did=="number"||typeof e.did=="string"?`${e.did}`:void 0,duration:e.duration,abnormal_mechanism:e.abnormal_mechanism,attrs:{release:e.release,environment:e.environment,ip_address:e.ipAddress,user_agent:e.userAgent}};}function gc(e,t,n=2){if (!t||typeof t!="object"||n<=0) {
  return t;
}if (e&&Object.keys(t).length===0) {
  return e;
}const r={...e};for (const o in t) {
  if (Object.prototype.hasOwnProperty.call(t,o)) {
    (r[o] = gc(r[o],t[o],n-1));
  }
}return r}function to(){return Ft()}function lo(){return Ft().substring(16)}const up="_sentrySpan";function sc(e,t){
  if (t) {
    cn(e,up,t);
  } else {
    delete e[up];
  }
}function hu(e){return e[up]}const bk=100;class gn{constructor(){
  this._notifyingListeners=false;
  this._scopeListeners=[];
  this._eventProcessors=[];
  this._breadcrumbs=[];
  this._attachments=[];
  this._user={};
  this._tags={};
  this._attributes={};
  this._extra={};
  this._contexts={};
  this._sdkProcessingMetadata={};
  this._propagationContext={traceId:to(),sampleRand:Math.random()};
}clone(){
  const t=new gn;
  t._breadcrumbs=[...this._breadcrumbs];
  t._tags={...this._tags};
  t._attributes={...this._attributes};
  t._extra={...this._extra};
  t._contexts={...this._contexts};

  if (this._contexts.flags) {
    (t._contexts.flags = {values:[...this._contexts.flags.values]});
  }

  t._user=this._user;
  t._level=this._level;
  t._session=this._session;
  t._transactionName=this._transactionName;
  t._fingerprint=this._fingerprint;
  t._eventProcessors=[...this._eventProcessors];
  t._attachments=[...this._attachments];
  t._sdkProcessingMetadata={...this._sdkProcessingMetadata};
  t._propagationContext={...this._propagationContext};
  t._client=this._client;
  t._lastEventId=this._lastEventId;
  sc(t,hu(this));
  return t;
}setClient(t){this._client=t}setLastEventId(t){this._lastEventId=t}getClient(){return this._client}lastEventId(){return this._lastEventId}addScopeListener(t){this._scopeListeners.push(t)}addEventProcessor(t){
  this._eventProcessors.push(t);
  return this;
}setUser(t){
  this._user=t||{email:void 0,id:void 0,ip_address:void 0,username:void 0};

  if (this._session) {
    ko(this._session,{user:t});
  }

  this._notifyScopeListeners();
  return this;
}getUser(){return this._user}setTags(t){
  this._tags={...this._tags,...t};
  this._notifyScopeListeners();
  return this;
}setTag(t,n){return this.setTags({[t]:n})}setAttributes(t){
  this._attributes={...this._attributes,...t};
  this._notifyScopeListeners();
  return this;
}setAttribute(t,n){return this.setAttributes({[t]:n})}removeAttribute(t){
  if (t in this._attributes) {
    delete this._attributes[t];
    this._notifyScopeListeners();
  }

  return this;
}setExtras(t){
  this._extra={...this._extra,...t};
  this._notifyScopeListeners();
  return this;
}setExtra(t,n){
  this._extra={...this._extra,[t]:n};
  this._notifyScopeListeners();
  return this;
}setFingerprint(t){
  this._fingerprint=t;
  this._notifyScopeListeners();
  return this;
}setLevel(t){
  this._level=t;
  this._notifyScopeListeners();
  return this;
}setTransactionName(t){
  this._transactionName=t;
  this._notifyScopeListeners();
  return this;
}setContext(t,n){
  if (n===null) {
    delete this._contexts[t];
  } else {
    this._contexts[t]=n;
  }

  this._notifyScopeListeners();
  return this;
}setSession(t){
  if (t) {
    this._session=t;
  } else {
    delete this._session;
  }

  this._notifyScopeListeners();
  return this;
}getSession(){return this._session}update(t){
  if (!t) {
    return this;
  }
  const n=typeof t=="function"?t(this):t;
  const r=n instanceof gn?n.getScopeData():rc(n)?t:void 0;
  const {tags,attributes,extra,user,contexts,level,fingerprint=[],propagationContext}=r||{};
  this._tags={...this._tags,...tags};
  this._attributes={...this._attributes,...attributes};
  this._extra={...this._extra,...extra};
  this._contexts={...this._contexts,...contexts};

  if (user&&Object.keys(user).length) {
    (this._user = user);
  }

  if (level) {
    (this._level = level);
  }

  if (fingerprint.length) {
    (this._fingerprint = fingerprint);
  }

  if (propagationContext) {
    (this._propagationContext = propagationContext);
  }

  return this;
}clear(){
  this._breadcrumbs=[];
  this._tags={};
  this._attributes={};
  this._extra={};
  this._user={};
  this._contexts={};
  this._level=void 0;
  this._transactionName=void 0;
  this._fingerprint=void 0;
  this._session=void 0;
  sc(this,void 0);
  this._attachments=[];
  this.setPropagationContext({traceId:to(),sampleRand:Math.random()});
  this._notifyScopeListeners();
  return this;
}addBreadcrumb(t,n){
  const r=typeof n=="number"?n:bk;if (r<=0) {
      return this;
    }const o={timestamp:Ac(),...t,message:t.message?Eu(t.message,2048):t.message};
  this._breadcrumbs.push(o);

  if (this._breadcrumbs.length>r) {
    this._breadcrumbs=this._breadcrumbs.slice(-r);
    this._client?.recordDroppedEvent("buffer_overflow","log_item");
  }

  this._notifyScopeListeners();
  return this;
}getLastBreadcrumb(){return this._breadcrumbs[this._breadcrumbs.length-1]}clearBreadcrumbs(){
  this._breadcrumbs=[];
  this._notifyScopeListeners();
  return this;
}addAttachment(t){
  this._attachments.push(t);
  return this;
}clearAttachments(){
  this._attachments=[];
  return this;
}getScopeData(){return{breadcrumbs:this._breadcrumbs,attachments:this._attachments,contexts:this._contexts,tags:this._tags,attributes:this._attributes,extra:this._extra,user:this._user,level:this._level,fingerprint:this._fingerprint||[],eventProcessors:this._eventProcessors,propagationContext:this._propagationContext,sdkProcessingMetadata:this._sdkProcessingMetadata,transactionName:this._transactionName,span:hu(this)}}setSDKProcessingMetadata(t){
  this._sdkProcessingMetadata=gc(this._sdkProcessingMetadata,t,2);
  return this;
}setPropagationContext(t){
  this._propagationContext=t;
  return this;
}getPropagationContext(){return this._propagationContext}captureException(t,n){
  const r=n?.event_id||Ft();if (!this._client) {
  if (le) {
    x.warn("No client configured on scope - will not capture exception!");
  }

  return r;
}const o=new Error("Sentry syntheticException");
  this._client.captureException(t,{originalException:t,syntheticException:o,...n,event_id:r},this);
  return r;
}captureMessage(t,n,r){
  const o=r?.event_id||Ft();if (!this._client) {
  if (le) {
    x.warn("No client configured on scope - will not capture message!");
  }

  return o;
}const s=r?.syntheticException??new Error(t);
  this._client.captureMessage(t,n,{originalException:t,syntheticException:s,...r,event_id:o},this);
  return o;
}captureEvent(t,n){const r=n?.event_id||Ft();return this._client?(this._client.captureEvent(t,{...n,event_id:r},this),r):(le&&x.warn("No client configured on scope - will not capture event!"),r)}_notifyScopeListeners(){
  if (!this._notifyingListeners) {
    this._notifyingListeners=true;
    this._scopeListeners.forEach(t=>{t(this)});
    this._notifyingListeners=false;
  }
}}function hE(){return Zo("defaultCurrentScope",() => new gn);}function Xo(){return Zo("defaultIsolationScope",() => new gn);}class Ck{constructor(t,n){
  let r;

  if (t) {
    r=t;
  } else {
    r=new gn;
  }

  let o;

  if (n) {
    o=n;
  } else {
    o=new gn;
  }

  this._stack=[{scope:r}];
  this._isolationScope=o;
}withScope(t){const n=this._pushScope();let r;try{r=t(n)}catch(o){
  this._popScope();
  throw o;
}return nr(r)?r.then(o => {
  this._popScope();
  return o;
},o=>{
  this._popScope();
  throw o;
}):(this._popScope(),r);}getClient(){return this.getStackTop().client}getScope(){return this.getStackTop().scope}getIsolationScope(){return this._isolationScope}getStackTop(){return this._stack[this._stack.length-1]}_pushScope(){
  const t=this.getScope().clone();
  this._stack.push({client:this.getClient(),scope:t});
  return t;
}_popScope(){return this._stack.length<=1?false:!!this._stack.pop();}}function Go(){
  const e=Yn();
  const t=Sc(e);
  return t.stack=t.stack||new Ck(hE(),Xo())
}function Ik(e){return Go().withScope(e)}function Pk(e,t){const n=Go();return n.withScope(() => {
  n.getStackTop().scope=e;
  return t(e);
});}function qA(e){return Go().withScope(() => e(Go().getIsolationScope()));}function Mk(){return {withIsolationScope:qA,withScope:Ik,withSetScope:Pk,withSetIsolationScope:(e, t) => qA(t),getCurrentScope:() => Go().getScope(),getIsolationScope:() => Go().getIsolationScope()};}function vk(e){
  const t=Yn();
  const n=Sc(t);
  n.acs=e
}function fo(e){const t=Sc(e);return t.acs?t.acs:Mk()}function Ke(){const e=Yn();return fo(e).getCurrentScope()}function je(){const e=Yn();return fo(e).getIsolationScope()}function Lk(){return Zo("globalScope",() => new gn);}function no(...e){
  const t=Yn();
  const n=fo(t);
  if(e.length===2){const[r,o]=e;return r?n.withSetScope(r,o):n.withScope(o)}return n.withScope(e[0])
}function wk(...e){
  const t=Yn();
  const n=fo(t);
  if(e.length===2){const[r,o]=e;return r?n.withSetIsolationScope(r,o):n.withIsolationScope(o)}return n.withIsolationScope(e[0])
}function he(){return Ke().getClient()}function TE(e){
  const t=e.getPropagationContext();
  const {traceId,parentSpanId,propagationSpanId}=t;
  const s={trace_id:traceId,span_id:propagationSpanId||lo()};

  if (parentSpanId) {
    (s.parent_span_id = parentSpanId);
  }

  return s;
}
const Kt="sentry.source";
const Vo="sentry.sample_rate";
const Dk="sentry.previous_trace_sample_rate";
const Ee="sentry.op";
const Ge="sentry.origin";
const Uk="sentry.measurement_unit";
const kk="sentry.measurement_value";
const xo="sentry.custom_span_name";
const SE="sentry.profile_id";
const mE="sentry.exclusive_time";
const Gk="cache.hit";
const Vk="cache.key";
const xk="cache.item_size";
const $k=0;
const Tu=1;
const Ae=2;
function lp(e){if (e<400&&e>=100) {
  return{code:Tu};
}if (e>=400&&e<500) {
  switch(e){case 401:
    {
      return{code:Ae,message:"unauthenticated"};
    }case 403:
    {
      return{code:Ae,message:"permission_denied"};
    }case 404:
    {
      return{code:Ae,message:"not_found"};
    }case 409:
    {
      return{code:Ae,message:"already_exists"};
    }case 413:
    {
      return{code:Ae,message:"failed_precondition"};
    }case 429:
    {
      return{code:Ae,message:"resource_exhausted"};
    }case 499:
    {
      return{code:Ae,message:"cancelled"};
    }default:
    {
      return{code:Ae,message:"invalid_argument"}
    }}
}if (e>=500&&e<600) {
  switch(e){case 501:
    {
      return{code:Ae,message:"unimplemented"};
    }case 503:
    {
      return{code:Ae,message:"unavailable"};
    }case 504:
    {
      return{code:Ae,message:"deadline_exceeded"};
    }default:
    {
      return{code:Ae,message:"internal_error"}
    }}
}return{code:Ae,message:"internal_error"}}
const HI="_sentryScope";
const FI="_sentryIsolationScope";
function Bk(e){try{const t=ye.WeakRef;if (typeof t=="function") {
  return new t(e)
}}catch{}return e}function Hk(e){if(e){if (typeof e=="object"&&"deref"in e&&typeof e.deref=="function") {
  try{return e.deref()}catch{return}
}return e}}function YI(e,t,n){
  if (e) {
    cn(e,FI,Bk(n));
    cn(e,HI,t);
  }
}function $o(e){const t=e;return{scope:t[HI],isolationScope:Hk(t[FI])}}
const AE="sentry-";
const Fk=/^sentry-/;
const Yk=8192;
function Rc(e){const t=Su(e);if (!t) {
  return;
}const n=Object.entries(t).reduce((r,[o,s])=>{if(o.match(Fk)){const i=o.slice(AE.length);r[i]=s}return r},{});if (Object.keys(n).length>0) {
  return n
}}function gE(e){if (!e) {
  return;
}const t=Object.entries(e).reduce((n, [r,o]) => {
  if (o) {
    (n[`${AE}${r}`] = o);
  }

  return n;
},{});return jI(t)}function Su(e){if (!(!e||!pu(e)&&!Array.isArray(e))) {
  return Array.isArray(e)?e.reduce((t,n)=>{
    const r=WA(n);
    Object.entries(r).forEach(([o,s])=>{t[o]=s});
    return t;
  },{}):WA(e);
}}function WA(e){return e.split(",").map(t=>{
  const n=t.indexOf("=");if (n===-1) {
    return[];
  }
  const r=t.slice(0,n);
  const o=t.slice(n+1);
  return[r,o].map(s=>{try{return decodeURIComponent(s.trim())}catch{return}})
}).reduce((t, [n,r]) => {
  if (n&&r) {
    (t[n] = r);
  }

  return t;
},{});}function jI(e){if (Object.keys(e).length!==0) {
  return Object.entries(e).reduce((t,[n,r],o)=>{
    const s=`${encodeURIComponent(n)}=${encodeURIComponent(r)}`;
    const i=o===0?s:`${t},${s}`;
    return i.length>Yk?(le&&x.warn(`Not adding key: ${n} with val: ${r} to baggage header due to exceeding baggage size limits.`),t):i
  },"");
}}
const jk=/^o(\d+)\./;
const qk=/^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function Wk(e){return e==="http"||e==="https"}function _o(e,t=false){const{host,path,pass,port,projectId,protocol,publicKey}=e;return `${protocol}://${publicKey}${t&&pass?`:${pass}`:""}@${host}${port?`:${port}`:""}/${path&&`${path}/`}${projectId}`;}function Kk(e){
  const t=qk.exec(e);if(!t){an(()=>{console.error(`Invalid Sentry Dsn: ${e}`)});return}const[n,r,o="",s="",i="",a=""]=t.slice(1);
  let c="";
  let l=a;
  const f=l.split("/");

  if (f.length>1) {
    c=f.slice(0,-1).join("/");
    l=f.pop();
  }

  if (l)
    {
      const d=l.match(/^\d+/);

      if (d) {
        (l = d[0]);
      }
    }

  return qI({host:s,pass:o,path:c,projectId:l,port:i,protocol:n,publicKey:r})
}function qI(e){return{protocol:e.protocol,publicKey:e.publicKey||"",pass:e.pass||"",host:e.host,port:e.port||"",path:e.path||"",projectId:e.projectId}}function zk(e){if (!le) {
  return true;
}const{port,projectId,protocol}=e;return ["protocol","publicKey","host","projectId"].find(i => e[i]?false:(x.error(`Invalid Sentry Dsn: ${i} missing`),true))?false:projectId.match(/^\d+$/)?Wk(protocol)?port&&isNaN(parseInt(port,10))?(x.error(`Invalid Sentry Dsn: Invalid port ${port}`),false):true:(x.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`),false):(x.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`),false);}function Zk(e){return e.match(jk)?.[1]}function WI(e){
  const t=e.getOptions();
  const {host}=e.getDsn()||{};
  let r;

  if (t.orgId) {
    r=String(t.orgId);
  } else if (host) {
    (r = Zk(host));
  }

  return r;
}function Xk(e){const t=typeof e=="string"?Kk(e):qI(e);if (!(!t||!zk(t))) {
  return t
}}function ro(e){if (typeof e=="boolean") {
  return Number(e);
}const t=typeof e=="string"?parseFloat(e):e;if (!(typeof t!="number"||isNaN(t)||t<0||t>1)) {
  return t
}}const KI=new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");function Qk(e){
  if (!e) {
    return;
  }const t=e.match(KI);if (!t) {
      return;
    }let n;

  if (t[3]==="1") {
    n=true;
  } else if (t[3]==="0") {
    (n = false);
  }

  return {traceId:t[1],parentSampled:n,parentSpanId:t[2]};
}function zI(e,t){
  const n=Qk(e);
  const r=Rc(t);
  if (!n?.traceId) {
    return{traceId:to(),sampleRand:Math.random()};
  }const o=Jk(n,r);

  if (r) {
    (r.sample_rand = o.toString());
  }

  const{traceId,parentSpanId,parentSampled}=n;return {traceId:traceId,parentSpanId:parentSpanId,sampled:parentSampled,dsc:r||{},sampleRand:o};
}function il(e=to(),t=lo(),n){
  let r="";

  if (n!==void 0) {
    (r = n?"-1":"-0");
  }

  return `${e}-${t}${r}`;
}function ZI(e=to(),t=lo(),n){return`00-${e}-${t}-${n?"01":"00"}`}function Jk(e,t){
  const n=ro(t?.sample_rand);if (n!==void 0) {
    return n;
  }const r=ro(t?.sample_rate);

  if (r&&e?.parentSampled!==void 0) {
    if (e.parentSampled) {
      return Math.random()*r;
    }

    return r+Math.random()*(1-r);
  }

  return Math.random();
}function e1(e,t){const n=WI(e);return t&&n&&t!==n?(x.log(`Won't continue trace because org IDs don't match (incoming baggage: ${t}, SDK options: ${n})`),false):(e.getOptions().strictTraceContinuation||false)&&(t&&!n||!t&&n)?(x.log(`Starting a new trace because strict trace continuation is enabled but one org ID is missing (incoming baggage: ${t}, Sentry client: ${n})`),false):true;}
const XI=0;
const RE=1;
let KA=false;function t1(e){
  const {spanId,traceId}=e.spanContext();
  const {data,op: op_1,parent_span_id,status,origin,links}=Re(e);
  return {parent_span_id:parent_span_id,span_id:spanId,trace_id:traceId,data:data,op:op_1,status:status,origin:origin,links:links};
}function al(e){
  const {spanId,traceId,isRemote}=e.spanContext();
  const o=isRemote?spanId:Re(e).parent_span_id;
  const s=$o(e).scope;
  const i=isRemote?s?.getPropagationContext().propagationSpanId||lo():spanId;
  return {parent_span_id:o,span_id:i,trace_id:traceId};
}function n1(e){
  const {traceId,spanId}=e.spanContext();
  const r=po(e);
  return il(traceId,spanId,r);
}function r1(e){
  const {traceId,spanId}=e.spanContext();
  const r=po(e);
  return ZI(traceId,spanId,r);
}function cl(e){if (e&&e.length>0) {
  return e.map(({context:{spanId:t,traceId:n,traceFlags:r,...o},attributes}) => ({
    span_id:t,
    trace_id:n,
    sampled:r===RE,
    attributes:attributes,
    ...o
  }));
}}function An(e){
  if (typeof e=="number") {
    return zA(e);
  }

  if (Array.isArray(e)) {
    return e[0]+e[1]/1000000000/* 1e9 */;
  }

  if (e instanceof Date) {
    return zA(e.getTime());
  }

  return oc();
}function zA(e){return e>9999999999?e/1000/* 1e3 */:e;}function Re(e){if (s1(e)) {
  return e.getSpanJSON();
}const{spanId,traceId}=e.spanContext();if(o1(e)){
  const {attributes,startTime,name,endTime,status,links}=e;
  const l="parentSpanId"in e?e.parentSpanId:"parentSpanContext"in e?e.parentSpanContext?.spanId:void 0;
  return {span_id:spanId,trace_id:traceId,data:attributes,description:name,parent_span_id:l,start_timestamp:An(startTime),timestamp:An(endTime)||void 0,status:ul(status),op:attributes[Ee],origin:attributes[Ge],links:cl(links)};
}return {span_id:spanId,trace_id:traceId,start_timestamp:0,data:{}};}function o1(e){const t=e;return!!t.attributes&&!!t.startTime&&!!t.name&&!!t.endTime&&!!t.status}function s1(e){return typeof e.getSpanJSON=="function"}function po(e){const{traceFlags}=e.spanContext();return traceFlags===RE;}function ul(e){if (!(!e||e.code===$k)) {
  return e.code===Tu?"ok":e.message||"internal_error"
}}
const Ka="_sentryChildSpans";
const dp="_sentryRootSpan";
function NE(e,t){
  const n=e[dp]||e;
  cn(t,dp,n);

  if (e[Ka]) {
    e[Ka].add(t);
  } else {
    cn(e,Ka,new Set([t]));
  }
}function i1(e){
  const t=new Set;function n(r){if(!t.has(r)&&po(r)){t.add(r);const o=r[Ka]?Array.from(r[Ka]):[];for (const s of o) {
    n(s)
  }}}
  n(e);
  return Array.from(t);
}function Yt(e){return e[dp]||e}function ll(){
  const e=Yn();
  const t=fo(e);
  return t.getActiveSpan?t.getActiveSpan():hu(Ke())
}function fp(){
  if (!KA) {
    an(()=>{console.warn("[Sentry] Returning null from `beforeSendSpan` is disallowed. To drop certain spans, configure the respective integrations directly or use `ignoreSpans`.")});
    KA=true;
  }
}let ZA=false;function a1(){
  if (ZA) {
    return;
  }function e(){
    const t=ll();
    const n=t&&Yt(t);
    if(n){
      const r="internal_error";

      if (le) {
        x.log(`[Tracing] Root span: ${r} -> Global error occurred`);
      }

      n.setStatus({code:Ae,message:r});
    }
  }
  e.tag="sentry_tracingErrorCallback";
  ZA=true;
  XU(e);
  JU(e);
}function zt(e){if (typeof __SENTRY_TRACING__=="boolean"&&!__SENTRY_TRACING__) {
  return false;
}const t=e||he()?.getOptions();return!!t&&(t.tracesSampleRate!=null||!!t.tracesSampler)}function XA(e){x.log(`Ignoring span ${e.op} - ${e.description} because it matches \`ignoreSpans\`.`)}function _p(e,t){if (!t?.length||!e.description) {
  return false;
}for(const n of t){
  if(u1(n)){if (Lo(e.description,n)) {
    if (le) {
      XA(e);
    }

    return true;
  }continue}if (!n.name&&!n.op) {
    continue;
  }
  const r=n.name?Lo(e.description,n.name):true;
  const o=n.op?e.op&&Lo(e.op,n.op):true;
  if (r&&o) {
    if (le) {
      XA(e);
    }

    return true;
  }
}return false;}function c1(e,t){
  const n=t.parent_span_id;
  const r=t.span_id;
  if (n) {
    for (const o of e) {
      if (o.parent_span_id===r) {
        (o.parent_span_id = n);
      }
    }
  }
}function u1(e){return typeof e=="string"||e instanceof RegExp}
const yE="production";
const QI="_frozenDsc";
function gd(e,t){cn(e,QI,t)}function JI(e,t){
  const n=t.getOptions();
  const {publicKey}=t.getDsn()||{};
  const o={environment:n.environment||yE,release:n.release,public_key:publicKey,trace_id:e,org_id:WI(t)};
  t.emit("createDsc",o);
  return o;
}function Nc(e,t){const n=t.getPropagationContext();return n.dsc||JI(n.traceId,e)}function xt(e){
  const t=he();if (!t) {
      return{};
    }
  const n=Yt(e);
  const r=Re(n);
  const o=r.data;
  const s=n.spanContext().traceState;
  const i=s?.get("sentry.sample_rate")??o[Vo]??o[Dk];
  function a(p){
    if ((typeof i=="number" || typeof i=="string")) {
      (p.sample_rate = `${i}`);
    }

    return p;
  }const c=n[QI];if (c) {
      return a(c);
    }
  const l=s?.get("sentry.dsc");
  const f=l&&Rc(l);
  if (f) {
    return a(f);
  }
  const d=JI(e.spanContext().traceId,t);
  const u=o[Kt];
  const _=r.description;

  if (u!=="url"&&_) {
    (d.transaction = _);
  }

  if (zt()) {
    d.sampled=String(po(n));
    d.sample_rand=s?.get("sentry.sample_rand")??$o(n).scope?.getPropagationContext().sampleRand.toString();
  }

  a(d);
  t.emit("createDsc",d,n);
  return d;
}class dl{constructor(t={}){
  this._traceId=t.traceId||to();
  this._spanId=t.spanId||lo();
}spanContext(){return{spanId:this._spanId,traceId:this._traceId,traceFlags:XI}}end(t){}setAttribute(t,n){return this}setAttributes(t){return this}setStatus(t){return this}updateName(t){return this}isRecording(){return false;}addEvent(t,n,r){return this}addLink(t){return this}addLinks(t){return this}recordException(t,n){}}function kn(e,t=100,n=Infinity){try{return pp("",e,t,n)}catch(r){return{ERROR:`**non-serializable** (${r})`}}}function eP(e,t=3,n=100*1024){const r=kn(e,t);return _1(r)>n?eP(e,t-1,n):r}function pp(e,t,n=Infinity,r=Infinity,o=p1()){
  const[s,i]=o;if (t==null||["boolean","string"].includes(typeof t)||typeof t=="number"&&Number.isFinite(t)) {
    return t;
  }const a=l1(e,t);if (!a.startsWith("[object ")) {
    return a;
  }if (t.__sentry_skip_normalization__) {
    return t;
  }const c=typeof t.__sentry_override_normalization_depth__=="number"?t.__sentry_override_normalization_depth__:n;if (c===0) {
    return a.replace("object ","");
  }if (s(t)) {
    return"[Circular ~]";
  }const l=t;if (l&&typeof l.toJSON=="function") {
    try{const _=l.toJSON();return pp("",_,c-1,r,o)}catch{}
  }const f=Array.isArray(t)?[]:{};let d=0;const u=xI(t);for(const _ in u){
    if (!Object.prototype.hasOwnProperty.call(u,_)) {
      continue;
    }if(d>=r){f[_]="[MaxProperties ~]";break}const p=u[_];
    f[_]=pp(_,p,c-1,r,o);
    d++;
  }
  i(t);
  return f;
}function l1(e,t){try{if (e==="domain"&&t&&typeof t=="object"&&t._events) {
  return"[Domain]";
}if (e==="domainEmitter") {
  return"[DomainEmitter]";
}if (typeof global !== "undefined"&&t===global) {
  return"[Global]";
}if (typeof window !== "undefined"&&t===window) {
  return"[Window]";
}if (typeof document !== "undefined"&&t===document) {
  return"[Document]";
}if (VI(t)) {
  return UI(t);
}if (sk(t)) {
  return"[SyntheticEvent]";
}if (typeof t=="number"&&!Number.isFinite(t)) {
  return`[${t}]`;
}if (typeof t=="function") {
  return`[Function: ${DI(t)}]`;
}if (typeof t=="symbol") {
  return`[${String(t)}]`;
}if (typeof t=="bigint") {
  return`[BigInt: ${String(t)}]`;
}const n=d1(t);return /^HTML(\w*)Element$/.test(n)?`[HTMLElement: ${n}]`:`[object ${n}]`;}catch(n){return`**non-serializable** (${n})`}}function d1(e){const t=Object.getPrototypeOf(e);return t?.constructor?t.constructor.name:"null prototype"}function f1(e){return ~-encodeURI(e).split(/%..|./).length;}function _1(e){return f1(JSON.stringify(e))}function p1(){const e=new WeakSet;function t(r){return e.has(r)?true:(e.add(r),false);}function n(r){e.delete(r)}return[t,n]}function or(e,t=[]){return[e,t]}function E1(e,t){const[n,r]=e;return[n,[...r,t]]}function QA(e,t){const n=e[1];for(const r of n){const o=r[0].type;if (t(r,o)) {
  return true;
}}return false;}function Ep(e){const t=Sc(ye);return t.encodePolyfill?t.encodePolyfill(e):new TextEncoder().encode(e)}function tP(e){const[t,n]=e;let r=JSON.stringify(t);function o(s){
  if (typeof r=="string") {
    r=typeof s=="string"?r+s:[Ep(r),s];
  } else {
    r.push(typeof s=="string"?Ep(s):s);
  }
}for(const s of n){
  const[i,a]=s;

  o(`
  ${JSON.stringify(i)}
  `);

  if (typeof a=="string"||a instanceof Uint8Array) {
    o(a);
  } else
    {let c;try{c=JSON.stringify(a)}catch{c=JSON.stringify(kn(a))}o(c)}
}return typeof r=="string"?r:h1(r)}function h1(e){
  const t=e.reduce((o, s) => o+s.length,0);

  const n=new Uint8Array(t);
  let r=0;for (const o of e) {
    n.set(o,r);
    r+=o.length;
  }return n
}function T1(e){return[{type:"span"},e]}function S1(e){const t=typeof e.data=="string"?Ep(e.data):e.data;return[{type:"attachment",length:t.length,filename:e.filename,content_type:e.contentType,attachment_type:e.attachmentType},t]}const m1={session:"session",sessions:"session",attachment:"attachment",transaction:"transaction",event:"error",client_report:"internal",user_report:"default",profile:"profile",profile_chunk:"profile",replay_event:"replay",replay_recording:"replay",check_in:"monitor",feedback:"feedback",span:"span",raw_security:"security",log:"log_item",metric:"metric",trace_metric:"metric"};function JA(e){return m1[e]}function nP(e){if (!e?.sdk) {
  return;
}const{name,version}=e.sdk;return {name:name,version:version};}function A1(e,t,n,r){const o=e.sdkProcessingMetadata?.dynamicSamplingContext;return {event_id:e.event_id,sent_at:new Date().toISOString(),...(t && {sdk:t}),...(!!n&&r && {dsn:_o(r)}),...(o && {trace:o})};}function g1(e,t){
  if (!t) {
    return e;
  }const n=e.sdk||{};
  e.sdk={...n,name:n.name||t.name,version:n.version||t.version,integrations:[...(e.sdk?.integrations || []),...(t.integrations || [])],packages:[...(e.sdk?.packages || []),...(t.packages || [])],settings:e.sdk?.settings||t.settings?{...e.sdk?.settings,...t.settings}:void 0};
  return e;
}function R1(e,t,n,r){
  const o=nP(n);
  const s={sent_at:new Date().toISOString(),...(o && {sdk:o}),...(!!r&&t && {dsn:_o(t)})};
  const i="aggregates"in e?[{type:"sessions"},e]:[{type:"session"},e.toJSON()];
  return or(s,[i])
}function N1(e,t,n,r){
  const o=nP(n);
  const s=e.type&&e.type!=="replay_event"?e.type:"event";
  g1(e,n?.sdk);const i=A1(e,o,r,t);
  delete e.sdkProcessingMetadata;
  return or(i,[[{type:s},e]]);
}function y1(e,t){
  function n(_){return!!_.trace_id&&!!_.public_key}
  const r=xt(e[0]);
  const o=t?.getDsn();
  const s=t?.getOptions().tunnel;
  const i={sent_at:new Date().toISOString(),...(n(r) && {trace:r}),...(!!s&&o && {dsn:_o(o)})};
  const {beforeSendSpan,ignoreSpans}=t?.getOptions()||{};

  const l=ignoreSpans?.length?e.filter(_ => !_p(Re(_),ignoreSpans)):e;

  const f=e.length-l.length;

  if (f) {
    t?.recordDroppedEvent("before_send","span",f);
  }

  const d=beforeSendSpan?_=>{
    const p=Re(_);
    const E=beforeSendSpan(p);
    return E||(fp(),p)
  }:Re;

  const u=[];
  for(const _ of l){
    const p=d(_);

    if (p) {
      u.push(T1(p));
    }
  }return or(i,u)
}function rP(e){
  if (!le) {
    return;
  }
  const {description="< unknown name >",op_1="< unknown op >",parent_span_id}=Re(e);
  const {spanId}=e.spanContext();
  const s=po(e);
  const i=Yt(e);
  const a=i===e;
  const c=`[Tracing] Starting ${s?"sampled":"unsampled"} ${a?"root ":""}span`;
  const l=[`op: ${op_1}`,`name: ${description}`,`ID: ${spanId}`];

  if (parent_span_id) {
    l.push(`parent ID: ${parent_span_id}`);
  }

  if (!a) {
    const{op: op_2,description: description_1}=Re(i);
    l.push(`root ID: ${i.spanContext().spanId}`);

    if (op_2) {
      l.push(`root op: ${op_2}`);
    }

    if (description_1) {
      l.push(`root description: ${description_1}`);
    }
  }

  x.log(`${c}
    ${l.join(`
    `)}`)
}function oP(e){
  if (!le) {
    return;
  }
  const {description="< unknown name >",op_1="< unknown op >"}=Re(e);
  const {spanId}=e.spanContext();
  const s=Yt(e)===e;
  const i=`[Tracing] Finishing "${op_1}" ${s?"root ":""}span "${description}" with ID ${spanId}`;
  x.log(i)
}function mu(e){
  if (!e||e.length===0) {
    return;
  }const t={};

  e.forEach(n=>{
    const r=n.attributes||{};
    const o=r[Uk];
    const s=r[kk];

    if (typeof o=="string"&&typeof s=="number") {
      (t[n.name] = {value:s,unit:o});
    }
  });

  return t;
}const eg=1000/* 1e3 */;class OE{constructor(t={}){
  this._traceId=t.traceId||to();
  this._spanId=t.spanId||lo();
  this._startTime=t.startTimestamp||oc();
  this._links=t.links;
  this._attributes={};
  this.setAttributes({[Ge]:"manual",[Ee]:t.op,...t.attributes});
  this._name=t.name;

  if (t.parentSpanId) {
    (this._parentSpanId = t.parentSpanId);
  }

  if ("sampled"in t) {
    (this._sampled = t.sampled);
  }

  if (t.endTimestamp) {
    (this._endTime = t.endTimestamp);
  }

  this._events=[];
  this._isStandaloneSpan=t.isStandalone;

  if (this._endTime) {
    this._onSpanEnded();
  }
}addLink(t){
  if (this._links) {
    this._links.push(t);
  } else {
    this._links=[t];
  }

  return this;
}addLinks(t){
  if (this._links) {
    this._links.push(...t);
  } else {
    this._links=t;
  }

  return this;
}recordException(t,n){}spanContext(){const{_spanId,_traceId,_sampled}=this;return {spanId:_spanId,traceId:_traceId,traceFlags:_sampled?RE:XI};}setAttribute(t,n){
  if (n===void 0) {
    delete this._attributes[t];
  } else {
    this._attributes[t]=n;
  }

  return this;
}setAttributes(t){
  Object.keys(t).forEach(n => this.setAttribute(n,t[n]));

  return this;
}updateStartTime(t){this._startTime=An(t)}setStatus(t){
  this._status=t;
  return this;
}updateName(t){
  this._name=t;
  this.setAttribute(Kt,"custom");
  return this;
}end(t){
  if (!this._endTime) {
    this._endTime=An(t);
    oP(this);
    this._onSpanEnded();
  }
}getSpanJSON(){return{data:this._attributes,description:this._name,op:this._attributes[Ee],parent_span_id:this._parentSpanId,span_id:this._spanId,start_timestamp:this._startTime,status:ul(this._status),timestamp:this._endTime,trace_id:this._traceId,origin:this._attributes[Ge],profile_id:this._attributes[SE],exclusive_time:this._attributes[mE],measurements:mu(this._events),is_segment:this._isStandaloneSpan&&Yt(this)===this||void 0,segment_id:this._isStandaloneSpan?Yt(this).spanContext().spanId:void 0,links:cl(this._links)}}isRecording(){return!this._endTime&&!!this._sampled}addEvent(t,n,r){
  if (le) {
    x.log("[Tracing] Adding an event to span:",t);
  }

  const o=tg(n)?n:r||oc();
  const s=tg(n)?{}:n||{};
  const i={name:t,time:An(o),attributes:s};
  this._events.push(i);
  return this;
}isStandaloneSpan(){return!!this._isStandaloneSpan}_onSpanEnded(){
  const t=he();

  if (t) {
    t.emit("spanEnd",this);
  }

  if (!(this._isStandaloneSpan||this===Yt(this))) {
    return;
  }

  if(this._isStandaloneSpan){
    if (this._sampled) {
      b1(y1([this],t));
    } else {
      le&&x.log("[Tracing] Discarding standalone span because its trace was not chosen to be sampled.");
      t&&t.recordDroppedEvent("sample_rate","span");
    }

    return
  }const r=this._convertSpanToTransaction();

  if (r) {
    ($o(this).scope||Ke()).captureEvent(r);
  }
}_convertSpanToTransaction(){
  if (!ng(Re(this))) {
    return;
  }

  if (!this._name) {
    le&&x.warn("Transaction has no name, falling back to `<unlabeled transaction>`.");
    this._name="<unlabeled transaction>";
  }

  const {scope,isolationScope}=$o(this);
  const r=scope?.getScopeData().sdkProcessingMetadata?.normalizedRequest;
  if (this._sampled!==true) {
    return;
  }

  const s=i1(this).filter(f => f!==this&&!O1(f)).map(f => Re(f)).filter(ng);

  const i=this._attributes[Kt];
  delete this._attributes[xo];
  s.forEach(f=>{delete f.data[xo]});

  const a={contexts:{trace:t1(this)},spans:s.length>eg?s.sort((f, d) => f.start_timestamp-d.start_timestamp).slice(0,eg):s,start_timestamp:this._startTime,timestamp:this._endTime,transaction:this._name,type:"transaction",sdkProcessingMetadata:{capturedSpanScope:scope,capturedSpanIsolationScope:isolationScope,dynamicSamplingContext:xt(this)},request:r,...(i && {transaction_info:{source:i}})};

  const c=mu(this._events);

  if (c&&Object.keys(c).length) {
    le&&x.log("[Measurements] Adding measurements to transaction event",JSON.stringify(c,void 0,2));
    a.measurements=c;
  }

  return a;
}}function tg(e){return e&&typeof e=="number"||e instanceof Date||Array.isArray(e)}function ng(e){return!!e.start_timestamp&&!!e.timestamp&&!!e.span_id&&!!e.trace_id}function O1(e){return e instanceof OE&&e.isStandaloneSpan()}function b1(e){const t=he();if (!t) {
  return;
}const n=e[1];if(!n||n.length===0){t.recordDroppedEvent("before_send","span");return}t.sendEnvelope(e)}function oo(e,t,n=()=>{},r=()=>{}){let o;try{o=e()}catch(s){
  t(s);
  n();
  throw s;
}return C1(o,t,n,r)}function C1(e,t,n,r){return nr(e)?e.then(o => {
  n();
  r(o);
  return o;
},o=>{
  t(o);
  n();
  throw o;
}):(n(),r(e),e);}function sP(e,t,n){
  if (!zt(e)) {
    return [false];
  }
  let r;
  let o;

  if (typeof e.tracesSampler=="function") {
    o=e.tracesSampler({...t,inheritOrSampleWith:a => typeof t.parentSampleRate=="number"?t.parentSampleRate:typeof t.parentSampled=="boolean"?Number(t.parentSampled):a});
    r=true;
  } else if (t.parentSampled!==void 0) {
    o=t.parentSampled;
  } else if (typeof e.tracesSampleRate !== "undefined") {
    o=e.tracesSampleRate;
    r=true;
  }

  const s=ro(o);if (s===void 0) {
    if (le) {
      x.warn(`[Tracing] Discarding root span because of invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(o)} of type ${JSON.stringify(typeof o)}.`);
    }

    return [false];
  }if (!s) {
    if (le) {
      x.log(`[Tracing] Discarding transaction because ${typeof e.tracesSampler=="function"?"tracesSampler returned 0 or false":"a negative sampling decision was inherited or tracesSampleRate is set to 0"}`);
    }

    return [false,s,r];
  }const i=n<s;

  if (!i) {
    if (le) {
      x.log(`[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(o)})`);
    }
  }

  return [i,s,r];
}const Au="__SENTRY_SUPPRESS_TRACING__";function Qo(e,t){
  const n=fl();if (n.startSpan) {
    return n.startSpan(e,t);
  }
  const r=uP(e);
  const {forceTransaction,parentSpan,scope}=e;
  const a=scope?.clone();
  return no(a,() => dP(parentSpan)(()=>{
    const l=Ke();
    const f=lP(l,parentSpan);
    const u=e.onlyIfParent&&!f?new dl:cP({parentSpan:f,spanArguments:r,forceTransaction:forceTransaction,scope:l});
    sc(l,u);

    return oo(() => t(u),()=>{
      const{status}=Re(u);

      if (u.isRecording()&&(!status||status==="ok")) {
        u.setStatus({code:Ae,message:"internal_error"});
      }
    },()=>{u.end()});
  }));
}function xn(e,t){
  const n=fl();if (n.startSpanManual) {
    return n.startSpanManual(e,t);
  }
  const r=uP(e);
  const {forceTransaction,parentSpan,scope}=e;
  const a=scope?.clone();
  return no(a,() => dP(parentSpan)(()=>{
    const l=Ke();
    const f=lP(l,parentSpan);
    const u=e.onlyIfParent&&!f?new dl:cP({parentSpan:f,spanArguments:r,forceTransaction:forceTransaction,scope:l});
    sc(l,u);

    return oo(() => t(u,() => u.end()),()=>{
      const{status}=Re(u);

      if (u.isRecording()&&(!status||status==="ok")) {
        u.setStatus({code:Ae,message:"internal_error"});
      }
    });
  }));
}function iP(e,t){const n=fl();return n.withActiveSpan?n.withActiveSpan(e,t):no(r => {
  sc(r,e||void 0);
  return t(r);
});}function aP(e){const t=fl();return t.suppressTracing?t.suppressTracing(e):no(n=>{
  n.setSDKProcessingMetadata({[Au]:true});const r=e();
  n.setSDKProcessingMetadata({[Au]:void 0});
  return r;
});}function cP({parentSpan,spanArguments,forceTransaction,scope}){
  if(!zt()){const i=new dl;if(forceTransaction||!parentSpan){const a={sampled:"false",sample_rate:"0",transaction:spanArguments.name,...xt(i)};gd(i,a)}return i}const o=je();let s;if (parentSpan&&!forceTransaction) {
    s=I1(parentSpan,scope,spanArguments);
    NE(parentSpan,s);
  } else if(parentSpan){
    const i=xt(parentSpan);
    const {traceId,spanId}=parentSpan.spanContext();
    const l=po(parentSpan);
    s=rg({traceId:traceId,parentSpanId:spanId,...spanArguments},scope,l);
    gd(s,i);
  }else{
  const{traceId,dsc,parentSpanId,sampled}={...o.getPropagationContext(),...scope.getPropagationContext()};
  s=rg({traceId:traceId,parentSpanId:parentSpanId,...spanArguments},scope,sampled);

  if (dsc) {
    gd(s,dsc);
  }
}
  rP(s);
  YI(s,scope,o);
  return s;
}function uP(e){const n={isStandalone:(e.experimental||{}).standalone,...e};if(e.startTime){
  const r={...n};
  r.startTimestamp=An(e.startTime);
  delete r.startTime;
  return r;
}return n}function fl(){const e=Yn();return fo(e)}function rg(e,t,n){
  const r=he();
  const o=r?.getOptions()||{};
  const {name=""}=e;
  const i={spanAttributes:{...e.attributes},spanName:name,parentSampled:n};
  r?.emit("beforeSampling",i,{decision:false});
  const a=i.parentSampled??n;
  const c=i.spanAttributes;
  const l=t.getPropagationContext();
  const [f,d,u]=t.getScopeData().sdkProcessingMetadata[Au]?[false]:sP(o,{name:name,parentSampled:a,attributes:c,parentSampleRate:ro(l.dsc?.sample_rate)},l.sampleRand);
  const _=new OE({...e,attributes:{[Kt]:"custom",[Vo]:d!==void 0&&u?d:void 0,...c},sampled:f});

  if (!f&&r) {
    le&&x.log("[Tracing] Discarding root span because its trace was not chosen to be sampled.");
    r.recordDroppedEvent("sample_rate","transaction");
  }

  if (r) {
    r.emit("spanStart",_);
  }

  return _;
}function I1(e,t,n){
  const {spanId,traceId}=e.spanContext();
  const s=t.getScopeData().sdkProcessingMetadata[Au]?false:po(e);
  const i=s?new OE({...n,parentSpanId:spanId,traceId:traceId,sampled:s}):new dl({traceId:traceId});
  NE(e,i);const a=he();

  if (a) {
    a.emit("spanStart",i);
    n.endTimestamp&&a.emit("spanEnd",i);
  }

  return i;
}function lP(e,t){if (t) {
  return t;
}if (t===null) {
  return;
}const n=hu(e);if (!n) {
  return;
}const r=he();return(r?r.getOptions():{}).parentSpanIsAlwaysRootSpan?Yt(n):n}function dP(e){return e!==void 0?t => iP(e,t):t => t();}
const Rd=0;
const og=1;
const sg=2;
function gu(e){return new ic(t=>{t(e)})}function bE(e){return new ic((t,n)=>{n(e)})}class ic{constructor(t){
  this._state=Rd;
  this._handlers=[];
  this._runExecutor(t);
}then(t,n){return new ic((r,o)=>{
  this._handlers.push([false,s=>{if (!t) {
    r(s);
  } else {
    try{r(t(s))}catch(i){o(i)}
  }},s=>{if (!n) {
    o(s);
  } else {
    try{r(n(s))}catch(i){o(i)}
  }}]);

  this._executeHandlers();
});}catch(t){return this.then(n => n,t);}finally(t){return new ic((n,r)=>{
  let o;
  let s;
  return this.then(i=>{
    s=false;
    o=i;

    if (t) {
      t();
    }
  },i=>{
    s=true;
    o=i;

    if (t) {
      t();
    }
  }).then(()=>{if(s){r(o);return}n(o)});
});}_executeHandlers(){
  if (this._state===Rd) {
    return;
  }const t=this._handlers.slice();
  this._handlers=[];
  t.forEach(n=>{
    if (!n[0]) {
      this._state===og&&n[1](this._value);
      this._state===sg&&n[2](this._value);
      n[0]=true;
    }
  });
}_runExecutor(t){
  const n=(s,i)=>{if(this._state===Rd){
    if(nr(i)){i.then(r,o);return}
    this._state=s;
    this._value=i;
    this._executeHandlers();
  }};

  const r=s=>{n(og,s)};
  const o=s=>{n(sg,s)};
  try{t(r,o)}catch(s){o(s)}
}}function P1(e,t,n,r=0){try{const o=hp(t,n,e,r);return nr(o)?o:gu(o)}catch(o){return bE(o)}}function hp(e,t,n,r){
  const o=n[r];if (!e||!o) {
      return e;
    }const s=o({...e},t);

  if (le&&s===null) {
    x.log(`Event processor "${o.id||"?"}" dropped event`);
  }

  return nr(s)?s.then(i => hp(i,t,n,r+1)):hp(s,t,n,r+1);
}function M1(e,t){
  const{fingerprint,span,breadcrumbs,sdkProcessingMetadata}=t;
  v1(e,t);

  if (span) {
    D1(e,span);
  }

  U1(e,fingerprint);
  L1(e,breadcrumbs);
  w1(e,sdkProcessingMetadata);
}function ig(e,t){
  const{extra,tags,user,contexts,level,sdkProcessingMetadata,breadcrumbs,fingerprint,eventProcessors,attachments,propagationContext,transactionName,span}=t;
  Lc(e,"extra",extra);
  Lc(e,"tags",tags);
  Lc(e,"user",user);
  Lc(e,"contexts",contexts);
  e.sdkProcessingMetadata=gc(e.sdkProcessingMetadata,sdkProcessingMetadata,2);

  if (level) {
    (e.level = level);
  }

  if (transactionName) {
    (e.transactionName = transactionName);
  }

  if (span) {
    (e.span = span);
  }

  if (breadcrumbs.length) {
    (e.breadcrumbs = [...e.breadcrumbs,...breadcrumbs]);
  }

  if (fingerprint.length) {
    (e.fingerprint = [...e.fingerprint,...fingerprint]);
  }

  if (eventProcessors.length) {
    (e.eventProcessors = [...e.eventProcessors,...eventProcessors]);
  }

  if (attachments.length) {
    (e.attachments = [...e.attachments,...attachments]);
  }

  e.propagationContext={...e.propagationContext,...propagationContext};
}function Lc(e,t,n){e[t]=gc(e[t],n,1)}function v1(e,t){
  const{extra,tags,user,contexts,level,transactionName}=t;

  if (Object.keys(extra).length) {
    (e.extra = {...extra,...e.extra});
  }

  if (Object.keys(tags).length) {
    (e.tags = {...tags,...e.tags});
  }

  if (Object.keys(user).length) {
    (e.user = {...user,...e.user});
  }

  if (Object.keys(contexts).length) {
    (e.contexts = {...contexts,...e.contexts});
  }

  if (level) {
    (e.level = level);
  }

  if (transactionName&&e.type!=="transaction") {
    (e.transaction = transactionName);
  }
}function L1(e,t){const n=[...(e.breadcrumbs || []),...t];e.breadcrumbs=n.length?n:void 0}function w1(e,t){e.sdkProcessingMetadata={...e.sdkProcessingMetadata,...t}}function D1(e,t){
  e.contexts={trace:al(t),...e.contexts};
  e.sdkProcessingMetadata={dynamicSamplingContext:xt(t),...e.sdkProcessingMetadata};
  const n=Yt(t);
  const r=Re(n).description;

  if (r&&!e.transaction&&e.type==="transaction") {
    (e.transaction = r);
  }
}function U1(e,t){
  e.fingerprint=e.fingerprint?Array.isArray(e.fingerprint)?e.fingerprint:[e.fingerprint]:[];

  if (t) {
    (e.fingerprint = e.fingerprint.concat(t));
  }

  if (!e.fingerprint.length) {
    delete e.fingerprint;
  }
}
let Nr;
let ag;
let cg;
let Wn;
function k1(e){
  const t=ye._sentryDebugIds;
  const n=ye._debugIds;
  if (!t&&!n) {
    return{};
  }
  const r=t?Object.keys(t):[];
  const o=n?Object.keys(n):[];
  if (Wn&&r.length===ag&&o.length===cg) {
    return Wn;
  }
  ag=r.length;
  cg=o.length;
  Wn={};

  if (!Nr) {
    (Nr = {});
  }

  const s=(i,a)=>{for(const c of i){
    const l=a[c];
    const f=Nr?.[c];
    if (f&&Wn&&l) {
      Wn[f[0]]=l;

      if (Nr) {
        (Nr[c] = [f[0],l]);
      }
    } else if(l){const d=e(c);for(let u=d.length-1;u>=0;u--){const p=d[u]?.filename;if(p&&Wn&&Nr){
      Wn[p]=l;
      Nr[c]=[p,l];
      break
    }}}
  }};

  if (t) {
    s(r,t);
  }

  if (n) {
    s(o,n);
  }

  return Wn;
}function G1(e,t,n,r,o,s){
  const {normalizeDepth=3,normalizeMaxBreadth=1000/* 1e3 */}=e;
  const c={...t,event_id:t.event_id||n.event_id||Ft(),timestamp:t.timestamp||Ac()};

  const l=n.integrations||e.integrations.map(h => h.name);

  V1(c,e);
  B1(c,l);

  if (o) {
    o.emit("applyFrameMetadata",t);
  }

  if (t.type===void 0) {
    x1(c,e.stackParser);
  }

  const f=F1(r,n.captureContext);

  if (n.mechanism) {
    EE(c,n.mechanism);
  }

  const d=o?o.getEventProcessors():[];
  const u=Lk().getScopeData();
  if(s){const h=s.getScopeData();ig(u,h)}if(f){const h=f.getScopeData();ig(u,h)}const _=[...(n.attachments || []),...u.attachments];

  if (_.length) {
    (n.attachments = _);
  }

  M1(c,u);
  const p=[...d,...u.eventProcessors];return P1(p,c,n).then(h => {
    if (h) {
      $1(h);
    }

    return typeof normalizeDepth=="number"&&normalizeDepth>0?H1(h,normalizeDepth,normalizeMaxBreadth):h;
  });
}function V1(e,t){
  const{environment,release,dist,maxValueLength}=t;
  e.environment=e.environment||environment||yE;

  if (!e.release&&release) {
    (e.release = release);
  }

  if (!e.dist&&dist) {
    (e.dist = dist);
  }

  const i=e.request;

  if (i?.url&&maxValueLength) {
    (i.url = Eu(i.url,maxValueLength));
  }

  if (maxValueLength) {
    e.exception?.values?.forEach(a=>{
      if (a.value) {
        (a.value = Eu(a.value,maxValueLength));
      }
    });
  }
}function x1(e,t){const n=k1(t);e.exception?.values?.forEach(r=>{r.stacktrace?.frames?.forEach(o=>{
  if (o.filename) {
    (o.debug_id = n[o.filename]);
  }
})})}function $1(e){
  const t={};
  e.exception?.values?.forEach(r=>{r.stacktrace?.frames?.forEach(o=>{
    if (o.debug_id) {
      o.abs_path?t[o.abs_path]=o.debug_id:o.filename&&(t[o.filename]=o.debug_id);
      delete o.debug_id;
    }
  })});

  if (Object.keys(t).length===0) {
    return;
  }

  e.debug_meta=e.debug_meta||{};
  e.debug_meta.images=e.debug_meta.images||[];
  const n=e.debug_meta.images;Object.entries(t).forEach(([r,o])=>{n.push({type:"sourcemap",code_file:r,debug_id:o})})
}function B1(e,t){
  if (t.length>0) {
    e.sdk=e.sdk||{};
    e.sdk.integrations=[...(e.sdk.integrations || []),...t];
  }
}function H1(e,t,n){
  if (!e) {
    return null;
  }const r={...e,...(e.breadcrumbs && {breadcrumbs:e.breadcrumbs.map(o => ({
    ...o,
    ...(o.data && {data:kn(o.data,t,n)})
  }))}),...(e.user && {user:kn(e.user,t,n)}),...(e.contexts && {contexts:kn(e.contexts,t,n)}),...(e.extra && {extra:kn(e.extra,t,n)})};

  if (e.contexts?.trace&&r.contexts) {
    r.contexts.trace=e.contexts.trace;
    e.contexts.trace.data&&(r.contexts.trace.data=kn(e.contexts.trace.data,t,n));
  }

  if (e.spans) {
    (r.spans = e.spans.map(o => ({
      ...o,
      ...(o.data && {data:kn(o.data,t,n)})
    })));
  }

  if (e.contexts?.flags&&r.contexts) {
    (r.contexts.flags = kn(e.contexts.flags,3,n));
  }

  return r;
}function F1(e,t){
  if (!t) {
    return e;
  }const n=e?e.clone():new gn;
  n.update(t);
  return n;
}function Y1(e){if (e) {
  return j1(e)?{captureContext:e}:W1(e)?{captureContext:e}:e
}}function j1(e){return e instanceof gn||typeof e=="function"}const q1=["user","level","extra","contexts","tags","fingerprint","propagationContext"];function W1(e){return Object.keys(e).some(t => q1.includes(t));}function xe(e,t){return Ke().captureException(e,Y1(t))}function K1(e,t){return Ke().captureEvent(e,t)}function z1(e,t){je().setTag(e,t)}function ug(e){je().setUser(e)}async function Z1(e){const t=he();return t?t.flush(e):(le&&x.warn("Cannot flush events. No client defined."),Promise.resolve(false));}function X1(){const e=he();return e?.getOptions().enabled!==false&&!!e?.getTransport();}function Q1(e){
  const t=je();
  const n=Ke();
  const {userAgent}=ye.navigator||{};
  const o=Nk({user:n.getUser()||t.getUser(),...(userAgent && {userAgent:userAgent}),...e});
  const s=t.getSession();

  if (s?.status==="ok") {
    ko(s,{status:"exited"});
  }

  fP();
  t.setSession(o);
  return o;
}function fP(){
  const e=je();
  const n=Ke().getSession()||e.getSession();

  if (n) {
    yk(n);
  }

  J1();
  e.setSession();
}function J1(){
  const e=je();
  const t=he();
  const n=e.getSession();

  if (n&&t) {
    t.captureSession(n);
  }
}const eG="7";function tG(e){
  const t=e.protocol?`${e.protocol}:`:"";
  const n=e.port?`:${e.port}`:"";
  return`${t}//${e.host}${n}${e.path?`/${e.path}`:""}/api/`
}function nG(e){return`${tG(e)}${e.projectId}/envelope/`}function rG(e,t){
  const n={sentry_version:eG};

  if (e.publicKey) {
    (n.sentry_key = e.publicKey);
  }

  if (t) {
    (n.sentry_client = `${t.name}/${t.version}`);
  }

  return new URLSearchParams(n).toString();
}function oG(e,t,n){return t||`${nG(e)}?${rG(e,n)}`}const lg=[];function sG(e){
  const t={};

  e.forEach(n=>{
    const {name}=n;
    const o=t[r];

    if (!o || o.isDefaultInstance || !n.isDefaultInstance) {
      (t[r] = n);
    }
  });

  return Object.values(t);
}function iG(e){
  const t=e.defaultIntegrations||[];
  const n=e.integrations;
  t.forEach(o=>{o.isDefaultInstance=true});let r;if (Array.isArray(n)) {
    r=[...t,...n];
  } else if (typeof n=="function")
    {const o=n(t);r=Array.isArray(o)?o:[o]} else {
    r=t;
  }return sG(r)
}function aG(e,t){
  const n={};
  t.forEach(r=>{
    if (r) {
      _P(e,r,n);
    }
  });
  return n;
}function dg(e,t){for (const n of t) {
  if (n?.afterAllSetup) {
    n.afterAllSetup(e);
  }
}}function _P(e,t,n){
  if(n[t.name]){
    if (le) {
      x.log(`Integration skipped because it was already installed: ${t.name}`);
    }

    return
  }
  n[t.name]=t;

  if (!lg.includes(t.name)&&typeof t.setupOnce=="function") {
    t.setupOnce();
    lg.push(t.name);
  }

  if (t.setup&&typeof t.setup=="function") {
    t.setup(e);
  }

  if (typeof t.preprocessEvent=="function") {const r=t.preprocessEvent.bind(t);e.on("preprocessEvent",(o, s) => r(o,s,e))}

  if(typeof t.processEvent=="function"){
    const r=t.processEvent.bind(t);

    const o=Object.assign((s, i) => r(s,i,e),{id:t.name});

    e.addEventProcessor(o)
  }

  if (le) {
    x.log(`Integration installed: ${t.name}`);
  }
}function cG(e,t){return t?no(t,()=>{
  const n=ll();
  const r=n?al(n):TE(t);
  return[n?xt(n):Nc(e,t),r]
}):[void 0,void 0];}function uG(e){return[{type:"log",item_count:e.length,content_type:"application/vnd.sentry.items.log+json"},{items:e}]}function lG(e,t,n,r){
  const o={};

  if (t?.sdk) {
    (o.sdk = {name:t.sdk.name,version:t.sdk.version});
  }

  if (n&&r) {
    (o.dsn = _o(r));
  }

  return or(o,[uG(e)]);
}function pP(e,t){
  const n=t??dG(e)??[];if (n.length===0) {
    return;
  }
  const r=e.getOptions();
  const o=lG(n,r._metadata,r.tunnel,e.getDsn());
  EP().set(e,[]);
  e.emit("flushLogs");
  e.sendEnvelope(o);
}function dG(e){return EP().get(e)}function EP(){return Zo("clientToLogBufferMap",() => new WeakMap);}function fG(e){return[{type:"trace_metric",item_count:e.length,content_type:"application/vnd.sentry.items.trace-metric+json"},{items:e}]}function _G(e,t,n,r){
  const o={};

  if (t?.sdk) {
    (o.sdk = {name:t.sdk.name,version:t.sdk.version});
  }

  if (n&&r) {
    (o.dsn = _o(r));
  }

  return or(o,[fG(e)]);
}function pG(e,t){
  const n=t??EG(e)??[];if (n.length===0) {
    return;
  }
  const r=e.getOptions();
  const o=_G(n,r._metadata,r.tunnel,e.getDsn());
  hP().set(e,[]);
  e.emit("flushMetrics");
  e.sendEnvelope(o);
}function EG(e){return hP().get(e)}function hP(){return Zo("clientToMetricBufferMap",() => new WeakMap);}const CE=Symbol.for("SentryBufferFullError");function TP(e=100){const t=new Set;function n(){return t.size<e}function r(i){t.delete(i)}function o(i){
  if (!n()) {
    return bE(CE);
  }const a=i();
  t.add(a);

  a.then(() => r(a),() => r(a));

  return a;
}function s(i){if (!t.size) {
  return gu(true);
}const a=Promise.allSettled(Array.from(t)).then(() => true);if (!i) {
  return a;
}const c=[a,new Promise(l => setTimeout(() => l(false),i))];return Promise.race(c)}return {get $() {return Array.from(t)},add:o,drain:s};}const hG=60*1000/* 1e3 */;function TG(e,t=Date.now()){const n=parseInt(`${e}`,10);if (!isNaN(n)) {
  return n*1000/* 1e3 */;
}const r=Date.parse(`${e}`);return isNaN(r)?hG:r-t}function SG(e,t){return e[t]||e.all||0}function mG(e,t,n=Date.now()){return SG(e,t)>n}function AG(e,{statusCode,headers},r=Date.now()){
  const o={...e};
  const s=headers?.["x-sentry-rate-limits"];
  const i=headers?.["retry-after"];
  if (s) {
    for(const a of s.trim().split(",")){
      const [c,l,,,f]=a.split(":",5);
      const d=parseInt(c,10);
      const u=(isNaN(d)?60:d)*1000/* 1e3 */;
      if (!l) {
        o.all=r+u;
      } else {
        for (const _ of l.split(";")) {
          if (_==="metric_bucket") {
            if ((!f || f.split(";").includes("custom"))) {
              (o[_] = r+u);
            }
          } else {
            o[_]=r+u;
          }
        }
      }
    }
  } else {
    if (i) {
      o.all=r+TG(i,r);
    } else if (statusCode===429) {
      (o.all = r+60*1000/* 1e3 */);
    }
  }return o
}const SP=64;function fg(e,t,n=TP(e.bufferSize||SP)){let r={};const o=i => n.drain(i);function s(i){
  const a=[];
  QA(i,(d,u)=>{
    const _=JA(u);

    if (mG(r,_)) {
      e.recordDroppedEvent("ratelimit_backoff",_);
    } else {
      a.push(d);
    }
  });

  if (a.length===0) {
    return Promise.resolve({});
  }

  const c=or(i[0],a);
  const l=d=>{QA(c,(u,_)=>{e.recordDroppedEvent(d,JA(_))})};

  const f=() => t({body:tP(c)}).then(d => {
    if (d.statusCode!==void 0&&(d.statusCode<200||d.statusCode>=300)&&le) {
      x.warn(`Sentry responded with status code ${d.statusCode} to sent event.`);
    }

    r=AG(r,d);
    return d;
  },d=>{
    l("network_error");

    if (le) {
      x.error("Encountered error running transport request:",d);
    }

    throw d;
  });

  return n.add(f).then(d => d,d=>{if (d===CE) {
    if (le) {
      x.error("Skipped sending event because buffer is full.");
    }

    l("queue_overflow");
    return Promise.resolve({});
  }throw d});
}return{send:s,flush:o}}function gG(e,t,n){const r=[{type:"client_report"},{timestamp:Ac(),discarded_events:e}];return or(t?{dsn:t}:{},[r])}function mP(e){
  const t=[];

  if (e.message) {
    t.push(e.message);
  }

  try{
    const n=e.exception.values[e.exception.values.length-1];

    if (n?.value) {
      t.push(n.value);
      n.type&&t.push(`${n.type}: ${n.value}`);
    }
  }catch{}return t
}function RG(e){const{trace_id,parent_span_id,span_id,status,origin,data,op: op_1}=e.contexts?.trace??{};return {data:data??{},description:e.transaction,op:op_1,parent_span_id:parent_span_id,span_id:span_id??"",start_timestamp:e.start_timestamp??0,status:status,timestamp:e.timestamp,trace_id:trace_id??"",origin:origin,profile_id:data?.[SE],exclusive_time:data?.[mE],measurements:e.measurements,is_segment:true};}function NG(e){return {type:"transaction",timestamp:e.timestamp,start_timestamp:e.start_timestamp,transaction:e.description,contexts:{trace:{trace_id:e.trace_id,span_id:e.span_id,parent_span_id:e.parent_span_id,op:e.op,status:e.status,origin:e.origin,data:{...e.data,...(e.profile_id && {[SE]:e.profile_id}),...(e.exclusive_time && {[mE]:e.exclusive_time})}}},measurements:e.measurements};}
const _g="Not capturing exception because it's already been captured.";
const pg="Discarded session because of missing or non-string release";
const AP=Symbol.for("SentryInternalError");
const gP=Symbol.for("SentryDoNotSendEventError");
const yG=5000/* 5e3 */;
function nu(e){return {message:e,[AP]:true};}function Nd(e){return {message:e,[gP]:true};}function Eg(e){return!!e&&typeof e=="object"&&AP in e}function hg(e){return!!e&&typeof e=="object"&&gP in e}function Tg(e,t,n,r,o){
  let s=0;
  let i;
  let a=false;

  e.on(n,()=>{
    s=0;
    clearTimeout(i);
    a=false;
  });

  e.on(t,c=>{
    s+=r(c);

    if (s>=800000/* 8e5 */) {
      o(e);
    } else if (!a) {
      a=true;
      i=setTimeout(()=>{o(e)},yG);
    }
  });

  e.on("flush",()=>{o(e)});
}class OG{constructor(t){
  this._options=t;
  this._integrations={};
  this._numProcessing=0;
  this._outcomes={};
  this._hooks={};
  this._eventProcessors=[];
  this._promiseBuffer=TP(t.transportOptions?.bufferSize??SP);

  if (t.dsn) {
    this._dsn=Xk(t.dsn);
  } else if (le) {
    x.warn("No DSN provided, client will not send events.");
  }

  if (this._dsn)
    {const r=oG(this._dsn,t.tunnel,t._metadata?t._metadata.sdk:void 0);this._transport=t.transport({tunnel:this._options.tunnel,recordDroppedEvent:this.recordDroppedEvent.bind(this),...t.transportOptions,url:r})}

  this._options.enableLogs=this._options.enableLogs??this._options._experiments?.enableLogs;

  if (this._options.enableLogs) {
    Tg(this,"afterCaptureLog","flushLogs",PG,pP);
  }

  if ((this._options.enableMetrics??this._options._experiments?.enableMetrics ?? true)) {
    Tg(this,"afterCaptureMetric","flushMetrics",IG,pG);
  }
}captureException(t,n,r){
  const o=Ft();if (YA(t)) {
  if (le) {
    x.log(_g);
  }

  return o;
}const s={event_id:o,...n};

  this._process(() => this.eventFromException(t,s).then(i => this._captureEvent(i,s,r)).then(i => i),"error");

  return s.event_id;
}captureMessage(t,n,r,o){
  const s={event_id:Ft(),...r};
  const i=pE(t)?t:String(t);
  const a=GI(t);
  const c=a?this.eventFromMessage(i,n,s):this.eventFromException(t,s);

  this._process(() => c.then(l => this._captureEvent(l,s,o)),a?"unknown":"error");

  return s.event_id;
}captureEvent(t,n,r){
  const o=Ft();if (n?.originalException&&YA(n.originalException)) {
  if (le) {
    x.log(_g);
  }

  return o;
}
  const s={event_id:o,...n};
  const i=t.sdkProcessingMetadata||{};
  const a=i.capturedSpanScope;
  const c=i.capturedSpanIsolationScope;
  const l=Sg(t.type);

  this._process(() => this._captureEvent(t,s,a||r,c),l);

  return s.event_id;
}captureSession(t){
  this.sendSession(t);
  ko(t,{init:false});
}getDsn(){return this._dsn}getOptions(){return this._options}getSdkMetadata(){return this._options._metadata}getTransport(){return this._transport}async flush(t){
  const n=this._transport;if (!n) {
    return true;
  }this.emit("flush");
  const r=await this._isClientDoneProcessing(t);
  const o=await n.flush(t);
  return r&&o
}async close(t){
  const n=await this.flush(t);
  this.getOptions().enabled=false;
  this.emit("close");
  return n;
}getEventProcessors(){return this._eventProcessors}addEventProcessor(t){this._eventProcessors.push(t)}init(){
  if ((this._isEnabled() || this._options.integrations.some(({name}) => name.startsWith("Spotlight")))) {
    this._setupIntegrations();
  }
}getIntegrationByName(t){return this._integrations[t]}addIntegration(t){
  const n=this._integrations[t.name];
  _P(this,t,this._integrations);

  if (!n) {
    dg(this,[t]);
  }
}sendEvent(t,n={}){this.emit("beforeSendEvent",t,n);let r=N1(t,this._dsn,this._options._metadata,this._options.tunnel);for (const o of n.attachments||[]) {
  r=E1(r,S1(o));
}this.sendEnvelope(r).then(o => this.emit("afterSendEvent",t,o))}sendSession(t){const{release,environment=yE}=this._options;if("aggregates"in t){
  const s=t.attrs||{};if(!s.release&&!release){
  if (le) {
    x.warn(pg);
  }

  return
}
  s.release=s.release||release;
  s.environment=s.environment||environment;
  t.attrs=s;
}else{
  if(!t.release&&!release){
    if (le) {
      x.warn(pg);
    }

    return
  }
  t.release=t.release||release;
  t.environment=t.environment||environment;
}this.emit("beforeSendSession",t);const o=R1(t,this._dsn,this._options._metadata,this._options.tunnel);this.sendEnvelope(o)}recordDroppedEvent(t,n,r=1){if(this._options.sendClientReports){
  const o=`${t}:${n}`;

  if (le) {
    x.log(`Recording outcome: "${o}"${r>1?` (${r} times)`:""}`);
  }

  this._outcomes[o]=(this._outcomes[o]||0)+r;
}}on(t,n){
  const r=this._hooks[t]=this._hooks[t]||new Set;

  const o=(...s) => n(...s);

  r.add(o);
  return ()=>{r.delete(o)};
}emit(t,...n){
  const r=this._hooks[t];

  if (r) {
    r.forEach(o => o(...n));
  }
}async sendEnvelope(t){
  this.emit("beforeEnvelope",t);

  if (this._isEnabled()&&this._transport) {
    try{return await this._transport.send(t)}catch(n){
      if (le) {
        x.error("Error while sending envelope:",n);
      }

      return {};
    }
  }

  if (le) {
    x.error("Transport disabled");
  }

  return {};
}_setupIntegrations(){
  const{integrations}=this._options;
  this._integrations=aG(this,integrations);
  dg(this,integrations);
}_updateSessionFromEvent(t,n){
  let r=n.level==="fatal";
  let o=false;
  const s=n.exception?.values;if(s){
      o=true;
      r=false;
      for (const c of s) {
        if(c.mechanism?.handled===false){r=true;break}
      }
    }const i=t.status==="ok";

  if ((i&&t.errors===0 || i&&r)) {
    ko(t,{...(r && {status:"crashed"}),errors:t.errors||Number(o||r)});
    this.captureSession(t);
  }
}async _isClientDoneProcessing(t){
  let n=0;

  while (!t||n<t) {
    await new Promise(r => setTimeout(r,1));

    if (!this._numProcessing) {
      return true;
    }

    n++
  }

  return false;
}_isEnabled(){return this.getOptions().enabled!==false&&this._transport!==void 0;}_prepareEvent(t,n,r,o){
  const s=this.getOptions();
  const i=Object.keys(this._integrations);

  if (!n.integrations&&i?.length) {
    (n.integrations = i);
  }

  this.emit("preprocessEvent",t,n);

  if (!t.type) {
    o.setLastEventId(t.event_id||n.event_id);
  }

  return G1(s,t,n,r,this,o).then(a=>{
    if (a===null) {
      return a;
    }
    this.emit("postprocessEvent",a,n);
    a.contexts={trace:TE(r),...a.contexts};
    const c=Nc(this,r);
    a.sdkProcessingMetadata={dynamicSamplingContext:c,...a.sdkProcessingMetadata};
    return a;
  });
}_captureEvent(t,n={},r=Ke(),o=je()){
  if (le&&Tp(t)) {
    x.log(`Captured error event \`${mP(t)[0]||"<unknown>"}\``);
  }

  return this._processEvent(t,n,r,o).then(s => s.event_id,s=>{
    if (le) {
      if (hg(s)) {
        x.log(s.message);
      } else if (Eg(s)) {
        x.warn(s.message);
      } else {
        x.warn(s);
      }
    }
  });
}_processEvent(t,n,r,o){
  const s=this.getOptions();
  const {sampleRate}=s;
  const a=RP(t);
  const c=Tp(t);
  const f=`before send for type \`${t.type||"error"}\``;
  const d=typeof sampleRate === "undefined"?void 0:ro(sampleRate);
  if (c&&typeof d=="number"&&Math.random()>d) {
    this.recordDroppedEvent("sample_rate","error");
    return bE(Nd(`Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`));
  }const u=Sg(t.type);return this._prepareEvent(t,n,r,o).then(_=>{if (_===null) {
    this.recordDroppedEvent("event_processor",u);
    throw Nd("An event processor returned `null`, will not send event.");
  }if (n.data&&n.data.__sentry__===true) {
    return _;
  }const E=CG(this,s,_,n);return bG(E,f)}).then(_=>{
  if(_===null){
    this.recordDroppedEvent("before_send",u);

    if (a)
      {const T=1+(t.spans||[]).length;this.recordDroppedEvent("before_send","span",T)}

    throw Nd(`${f} returned \`null\`, will not send event.`)
  }const p=r.getSession()||o.getSession();

  if (c&&p) {
    this._updateSessionFromEvent(p,_);
  }

  if (a) {
    const h=_.sdkProcessingMetadata?.spanCountBeforeProcessing||0;
    const T=_.spans?_.spans.length:0;
    const m=h-T;

    if (m>0) {
      this.recordDroppedEvent("before_send","span",m);
    }
  }

  const E=_.transaction_info;if(a&&E&&_.transaction!==t.transaction){const h="custom";_.transaction_info={...E,source:h}}
  this.sendEvent(_,n);
  return _;
}).then(null,_=>{throw hg(_)||Eg(_)?_:(this.captureException(_,{mechanism:{handled:false,type:"internal"},data:{__sentry__:true},originalException:_}),nu(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
  Reason: ${_}`))});
}_process(t,n){
  this._numProcessing++;

  this._promiseBuffer.add(t).then(r => {
    this._numProcessing--;
    return r;
  },r => {
    this._numProcessing--;

    if (r===CE) {
      this.recordDroppedEvent("queue_overflow",n);
    }

    return r;
  });
}_clearOutcomes(){
  const t=this._outcomes;
  this._outcomes={};
  return Object.entries(t).map(([n,r])=>{const[o,s]=n.split(":");return{reason:o,category:s,quantity:r}});
}_flushOutcomes(){
  if (le) {
    x.log("Flushing outcomes...");
  }

  const t=this._clearOutcomes();if(t.length===0){
    if (le) {
      x.log("No outcomes to send");
    }

    return
  }if(!this._dsn){
    if (le) {
      x.log("No dsn provided, will not send outcomes");
    }

    return
  }

  if (le) {
    x.log("Sending outcomes:",t);
  }

  const n=gG(t,this._options.tunnel&&_o(this._dsn));this.sendEnvelope(n)
}}function Sg(e){return e==="replay_event"?"replay":e||"error"}function bG(e,t){const n=`${t} must return \`null\` or a valid event.`;if (nr(e)) {
  return e.then(r=>{if (!rc(r)&&r!==null) {
    throw nu(n);
  }return r},r=>{throw nu(`${t} rejected with ${r}`)});
}if (!rc(e)&&e!==null) {
  throw nu(n);
}return e}function CG(e,t,n,r){const{beforeSend,beforeSendTransaction,beforeSendSpan,ignoreSpans}=t;let c=n;if (Tp(c)&&beforeSend) {
  return beforeSend(c,r);
}if(RP(c)){if(beforeSendSpan||ignoreSpans){const l=RG(c);if (ignoreSpans?.length&&_p(l,ignoreSpans)) {
  return null;
}if(beforeSendSpan){
  const f=beforeSendSpan(l);

  if (f) {
    c=gc(n,NG(f));
  } else {
    fp();
  }
}if(c.spans){
  const f=[];
  const d=c.spans;
  for(const _ of d){if(ignoreSpans?.length&&_p(_,ignoreSpans)){c1(d,_);continue}if (beforeSendSpan)
    {
      const p=beforeSendSpan(_);

      if (p) {
        f.push(p);
      } else {
        fp();
        f.push(_);
      }
    } else {
    f.push(_)
  }}const u=c.spans.length-f.length;

  if (u) {
    e.recordDroppedEvent("before_send","span",u);
  }

  c.spans=f;
}}if(beforeSendTransaction){if(c.spans){const l=c.spans.length;c.sdkProcessingMetadata={...n.sdkProcessingMetadata,spanCountBeforeProcessing:l}}return beforeSendTransaction(c,r);}}return c}function Tp(e){return e.type===void 0}function RP(e){return e.type==="transaction"}function IG(e){
  let t=0;

  if (e.name) {
    (t += e.name.length*2);
  }

  t+=8;
  return t+NP(e.attributes);
}function PG(e){
  let t=0;

  if (e.message) {
    (t += e.message.length*2);
  }

  return t+NP(e.attributes);
}function NP(e){
  if (!e) {
    return 0;
  }let t=0;
  Object.values(e).forEach(n=>{
    if (Array.isArray(n)) {
      t+=n.length*mg(n[0]);
    } else if (GI(n)) {
      t+=mg(n);
    } else {
      t+=100;
    }
  });
  return t;
}function mg(e){return typeof e=="string"?e.length*2:typeof e=="number"?8:typeof e=="boolean"?4:0}function MG(e,t,n,r,o){
  const s={sent_at:new Date().toISOString()};

  if (n?.sdk) {
    (s.sdk = {name:n.sdk.name,version:n.sdk.version});
  }

  if (r&&o) {
    (s.dsn = _o(o));
  }

  if (t) {
    (s.trace = t);
  }

  const i=vG(e);return or(s,[i])
}function vG(e){return[{type:"check_in"},e]}function LG(e){
  const t=e._metadata?.sdk;
  const n=t?.name&&t?.version?`${t?.name}/${t?.version}`:void 0;
  e.transportOptions={...e.transportOptions,headers:{...(n && {"user-agent":n}),...e.transportOptions?.headers}}
}function yP(e,t){return e(t.stack||"",1)}function OP(e,t){
  const n={type:t.name||t.constructor.name,value:t.message};
  const r=yP(e,t);

  if (r.length) {
    (n.stacktrace = {frames:r});
  }

  return n;
}function wG(e){for (const t in e) {
  if(Object.prototype.hasOwnProperty.call(e,t)){const n=e[t];if (n instanceof Error) {
    return n
  }}
}}function DG(e){if("name"in e&&typeof e.name=="string"){
  let r=`'${e.name}' captured as exception`;

  if ("message"in e&&typeof e.message=="string") {
    (r += ` with message '${e.message}'`);
  }

  return r;
}else if ("message"in e&&typeof e.message=="string") {
  return e.message;
}const t=_k(e);if (tk(e)) {
  return`Event \`ErrorEvent\` captured as exception with message \`${e.message}\``;
}const n=UG(e);return`${n&&n!=="Object"?`'${n}'`:"Object"} captured as exception with keys: ${t}`}function UG(e){try{const t=Object.getPrototypeOf(e);return t?t.constructor.name:void 0}catch{}}function kG(e,t,n,r){
  if (_u(n)) {
    return[n,void 0];
  }
  t.synthetic=true;

  if (rc(n)) {
    const s=e?.getOptions().normalizeDepth;
    const i={__serialized__:eP(n,s)};
    const a=wG(n);
    if (a) {
      return[a,i];
    }
    const c=DG(n);
    const l=r?.syntheticException||new Error(c);
    l.message=c;
    return [l,i];
  }

  const o=r?.syntheticException||new Error(n);
  o.message=`${n}`;
  return [o,void 0];
}function GG(e,t,n,r){
  const s=r?.data&&r.data.mechanism||{handled:true,type:"generic"};
  const [i,a]=kG(e,s,n,r);
  const c={exception:{values:[OP(t,i)]}};

  if (a) {
    (c.extra = a);
  }

  Sk(c);
  EE(c,s);
  return {...c,event_id:r?.event_id};
}function VG(e,t,n="info",r,o){
  const s={event_id:r?.event_id,level:n};if(o&&r?.syntheticException){
  const i=yP(e,r.syntheticException);

  if (i.length) {
    s.exception={values:[{value:t,stacktrace:{frames:i}}]};
    EE(s,{synthetic:true});
  }
}if(pE(t)){
    const{__sentry_template_string__,__sentry_template_values__}=t;
    s.logentry={message:__sentry_template_string__,params:__sentry_template_values__};
    return s;
  }
  s.message=t;
  return s;
}class xG extends OG{constructor(t){
  a1();
  LG(t);
  super(t);
  this._setUpMetricsProcessing();
}eventFromException(t,n){
  const r=GG(this,this._options.stackParser,t,n);
  r.level="error";
  return gu(r);
}eventFromMessage(t,n="info",r){return gu(VG(this._options.stackParser,t,n,r,this._options.attachStacktrace))}captureException(t,n,r){
  Ag(n);
  return super.captureException(t,n,r);
}captureEvent(t,n,r){
  if (!t.type&&t.exception?.values&&t.exception.values.length>0) {
    Ag(n);
  }

  return super.captureEvent(t,n,r);
}captureCheckIn(t,n,r){
  const o="checkInId"in t&&t.checkInId?t.checkInId:Ft();if (!this._isEnabled()) {
    if (le) {
      x.warn("SDK not enabled, will not capture check-in.");
    }

    return o;
  }
  const s=this.getOptions();
  const {release,environment,tunnel}=s;
  const l={check_in_id:o,monitor_slug:t.monitorSlug,status:t.status,release:release,environment:environment};

  if ("duration"in t) {
    (l.duration = t.duration);
  }

  if (n) {
    (l.monitor_config = {schedule:n.schedule,checkin_margin:n.checkinMargin,max_runtime:n.maxRuntime,timezone:n.timezone,failure_issue_threshold:n.failureIssueThreshold,recovery_threshold:n.recoveryThreshold});
  }

  const[f,d]=cG(this,r);

  if (d) {
    (l.contexts = {trace:d});
  }

  const u=MG(l,f,this.getSdkMetadata(),tunnel,this.getDsn());

  if (le) {
    x.log("Sending checkin:",t.monitorSlug,t.status);
  }

  this.sendEnvelope(u);
  return o;
}_prepareEvent(t,n,r,o){
  if (this._options.platform) {
    (t.platform = t.platform||this._options.platform);
  }

  if (this._options.runtime) {
    (t.contexts = {...t.contexts,runtime:t.contexts?.runtime||this._options.runtime});
  }

  if (this._options.serverName) {
    (t.server_name = t.server_name||this._options.serverName);
  }

  return super._prepareEvent(t,n,r,o);
}_setUpMetricsProcessing(){this.on("processMetric",t=>{
  if (this._options.serverName) {
    (t.attributes = {"server.address":this._options.serverName,...t.attributes});
  }
})}}function Ag(e){const t=je().getScopeData().sdkProcessingMetadata.requestSession;if(t){
  const n=e?.mechanism?.handled??true;

  if (n&&t.status!=="crashed") {
    t.status="errored";
  } else if (!n) {
    (t.status = "crashed");
  }
}}const IE=new Set;function $G(e){e.forEach(t=>{
  IE.add(t);

  if (le) {
    x.log(`AI provider "${t}" wrapping will be skipped`);
  }
})}function PE(e){return IE.has(e)}function BG(){
  IE.clear();

  if (le) {
    x.log("Cleared AI provider skip registrations");
  }
}const HG="thismessage:/";function FG(e,t){
  const n=e.indexOf("://")<=0&&e.indexOf("//")!==0;
  const r=n?HG:void 0;
  try{if ("canParse"in URL&&!URL.canParse(e,r)) {
    return;
  }const o=new URL(e,r);return n?{isRelative:n,pathname:o.pathname,search:o.search,hash:o.hash}:o}catch{}
}function _l(e){
  if (!e) {
    return{};
  }const t=e.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);if (!t) {
    return{};
  }
  const n=t[6]||"";
  const r=t[8]||"";
  return{host:t[4],path:t[5],protocol:t[2],search:n,hash:r,relative:t[5]+n+r}
}function ac(e){return e.split(/[?#]/,1)[0];}function pl(e){
  const {protocol,host,path}=e;
  const o=host?.replace(/^.*@/,"[filtered]:[filtered]@").replace(/(:80)$/,"").replace(/(:443)$/,"")||"";
  return `${protocol?`${protocol}://`:""}${o}${path}`;
}function ME(e,t,n=[t],r="npm"){
  const o=e._metadata||{};

  if (!o.sdk) {
    (o.sdk = {name:`sentry.javascript.${t}`,packages:n.map(s => ({
      name:`${r}:@sentry/${s}`,
      version:Ze
    })),version:Ze});
  }

  e._metadata=o;
}function bP(e={}){
  const t=e.client||he();if (!X1()||!t) {
    return{};
  }
  const n=Yn();
  const r=fo(n);
  if (r.getTraceData) {
    return r.getTraceData(e);
  }
  const o=e.scope||Ke();
  const s=e.span||ll();
  const i=s?n1(s):YG(o);
  const a=s?xt(s):Nc(t,o);
  const c=gE(a);
  if (!KI.test(i)) {
    x.warn("Invalid sentry-trace data. Cannot generate trace data");
    return {};
  }const f={"sentry-trace":i,baggage:c};if(e.propagateTraceparent){
  const d=s?r1(s):jG(o);

  if (d) {
    (f.traceparent = d);
  }
}return f
}function YG(e){const{traceId,sampled,propagationSpanId}=e.getPropagationContext();return il(traceId,propagationSpanId,sampled);}function jG(e){const{traceId,sampled,propagationSpanId}=e.getPropagationContext();return ZI(traceId,propagationSpanId,sampled);}function qG(e,t,n){
  let r;
  let o;
  let s;
  const i=Math.max(n.maxWait,t);
  const a=n?.setTimeoutImpl||setTimeout;
  function c(){
    l();
    r=e();
    return r;
  }function l(){
  if (o!==void 0) {
    clearTimeout(o);
  }

  if (s!==void 0) {
    clearTimeout(s);
  }

  o = void 0;
  s = void 0;
}function f(){return o!==void 0||s!==void 0?c():r}function d(){
  if (o) {
    clearTimeout(o);
  }

  o=a(c,t);

  if (i&&s===void 0) {
    (s = a(c,i));
  }

  return r;
}
  d.cancel=l;
  d.flush=f;
  return d;
}function WG(e){const t=Object.create(null);try{Object.entries(e).forEach(([n,r])=>{
  if (typeof r=="string") {
    (t[n] = r);
  }
})}catch{}return t}function KG(e){
  const t=e.headers||{};
  const r=(typeof t["x-forwarded-host"]=="string"?t["x-forwarded-host"]:void 0)||(typeof t.host=="string"?t.host:void 0);
  const s=(typeof t["x-forwarded-proto"]=="string"?t["x-forwarded-proto"]:void 0)||e.protocol||(e.socket?.encrypted?"https":"http");
  const i=e.url||"";
  const a=zG({url:i,host:r,protocol:s});
  const c=e.body||void 0;
  const l=e.cookies;
  return{url:a,method:e.method,query_string:QG(i),headers:WG(t),cookies:l,data:c}
}function zG({url,protocol,host}){if (url?.startsWith("http")) {
  return url;
}if (url&&host) {
  return `${protocol}://${host}${url}`;
}}const ZG=["auth","token","secret","cookie","-user","password","key","jwt","bearer","sso","saml"];function XG(e){const t={};try{Object.entries(e).forEach(([n,r])=>{
  if (r==null) {
    return;
  }
  const o=n.toLowerCase();

  const s=ZG.some(a => o.includes(a));

  const i=`http.request.header.${o.replace(/-/g,"_")}`;

  if (s) {
    t[i]="[Filtered]";
  } else if (Array.isArray(r)) {
    t[i]=r.map(a => a!=null?String(a):a).join(";");
  } else if (typeof r=="string") {
    (t[i] = r);
  }
})}catch{}return t}function QG(e){if (e) {
  try{const t=new URL(e,"http://s.io").search.slice(1);return t.length?t:void 0}catch{return}
}}const JG=100;function Bo(e,t){
  const n=he();
  const r=je();
  if (!n) {
    return;
  }const{beforeBreadcrumb=null,maxBreadcrumbs=JG}=n.getOptions();if (maxBreadcrumbs<=0) {
      return;
    }
  const a={timestamp:Ac(),...e};

  const c=beforeBreadcrumb?an(() => beforeBreadcrumb(a,t)):a;

  if (c!==null) {
    n.emit&&n.emit("beforeAddBreadcrumb",c,t);
    r.addBreadcrumb(c,maxBreadcrumbs);
  }
}let gg;
const eV="FunctionToString";
const Rg=new WeakMap;

const tV=(() => ({
  name:eV,

  setupOnce(){gg=Function.prototype.toString;try{Function.prototype.toString=function(...e){
    const t=fk(this);
    const n=Rg.has(he())&&t!==void 0?t:this;
    return gg.apply(n,e)
  }}catch{}},

  setup(e){Rg.set(e,true)}
}));

const nV=tV;
const rV=[/^Script error\.?$/,/^Javascript error: Script error\.? on line 0$/,/^ResizeObserver loop completed with undelivered notifications.$/,/^Cannot redefine property: googletag$/,/^Can't find variable: gmo$/,/^undefined is not an object \(evaluating 'a\.[A-Z]'\)$/,`can't redefine non-configurable property "solana"`,"vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)","Can't find variable: _AutofillCallbackHandler",/^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/,/^Java exception was raised during method invocation$/];
const oV="EventFilters";
const sV=(e={})=>{let t;return{name:oV,setup(n){const r=n.getOptions();t=Ng(e,r)},processEvent(n,r,o){if(!t){const s=o.getOptions();t=Ng(e,s)}return aV(n,t)?null:n}}};

const iV=((e={}) => ({
  ...sV(e),
  name:"InboundFilters"
}));

function Ng(e={},t={}){return {allowUrls:[...(e.allowUrls || []),...(t.allowUrls || [])],denyUrls:[...(e.denyUrls || []),...(t.denyUrls || [])],ignoreErrors:[...(e.ignoreErrors || []),...(t.ignoreErrors || []),...(e.disableErrorDefaults ? [] : rV)],ignoreTransactions:[...(e.ignoreTransactions || []),...(t.ignoreTransactions || [])]};}function aV(e,t){if(e.type){if (e.type==="transaction"&&uV(e,t.ignoreTransactions)) {
  if (le) {
    x.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
    Event: ${yo(e)}`);
  }

  return true;
}}else{if (cV(e,t.ignoreErrors)) {
  if (le) {
    x.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
    Event: ${yo(e)}`);
  }

  return true;
}if (_V(e)) {
  if (le) {
    x.warn(`Event dropped due to not having an error message, error type or stacktrace.
    Event: ${yo(e)}`);
  }

  return true;
}if (lV(e,t.denyUrls)) {
  if (le) {
    x.warn(`Event dropped due to being matched by \`denyUrls\` option.
    Event: ${yo(e)}.
    Url: ${Ru(e)}`);
  }

  return true;
}if (!dV(e,t.allowUrls)) {
  if (le) {
    x.warn(`Event dropped due to not being matched by \`allowUrls\` option.
    Event: ${yo(e)}.
    Url: ${Ru(e)}`);
  }

  return true;
}}return false;}function cV(e,t){return t?.length?mP(e).some(n => mc(n,t)):false;}function uV(e,t){if (!t?.length) {
  return false;
}const n=e.transaction;return n?mc(n,t):false;}function lV(e,t){if (!t?.length) {
  return false;
}const n=Ru(e);return n?mc(n,t):false;}function dV(e,t){if (!t?.length) {
  return true;
}const n=Ru(e);return n?mc(n,t):true;}function fV(e=[]){for(let t=e.length-1;t>=0;t--){const n=e[t];if (n&&n.filename!=="<anonymous>"&&n.filename!=="[native code]") {
  return n.filename||null
}}return null}function Ru(e){try{const n=[...(e.exception?.values ?? [])].reverse().find(r => r.mechanism?.parent_id===void 0&&r.stacktrace?.frames?.length)?.stacktrace?.frames;return n?fV(n):null}catch{
  if (le) {
    x.error(`Cannot extract url for event ${yo(e)}`);
  }

  return null;
}}function _V(e){return e.exception?.values?.length?!e.message&&!e.exception.values.some(t => t.stacktrace||t.type&&t.type!=="Error"||t.value):false;}function pV(e,t,n,r,o,s){
  if (!o.exception?.values||!s||!eo(s.originalException,Error)) {
    return;
  }const i=o.exception.values.length>0?o.exception.values[o.exception.values.length-1]:void 0;

  if (i) {
    (o.exception.values = Sp(e,t,r,s.originalException,n,o.exception.values,i,0));
  }
}function Sp(e,t,n,r,o,s,i,a){
  if (s.length>=n+1) {
    return s;
  }let c=[...s];if(eo(r[o],Error)){
      yg(i,a);
      const l=e(t,r[o]);
      const f=c.length;
      Og(l,o,f,a);
      c=Sp(e,t,n,r[o],o,[l,...c],l,f);
    }

  if (Array.isArray(r.errors)) {
    r.errors.forEach((l,f)=>{if(eo(l,Error)){
      yg(i,a);
      const d=e(t,l);
      const u=c.length;
      Og(d,`errors[${f}]`,u,a);
      c=Sp(e,t,n,l,o,[d,...c],d,u);
    }});
  }

  return c;
}function yg(e,t){e.mechanism={handled:true,type:"auto.core.linked_errors",...e.mechanism,...(e.type==="AggregateError" && {is_exception_group:true}),exception_id:t}}function Og(e,t,n,r){e.mechanism={handled:true,...e.mechanism,type:"chained",source:t,exception_id:n,parent_id:r}}
const EV="cause";
const hV=5;
const TV="LinkedErrors";

const SV=((e={})=>{
  const t=e.limit||hV;
  const n=e.key||EV;
  return{name:TV,preprocessEvent(r,o,s){const i=s.getOptions();pV(OP,i.stackParser,n,t,r,o)}}
});

const mV=SV;
function AV(e){
  const t={};let n=0;

  while (n<e.length) {const r=e.indexOf("=",n);if (r===-1) {
    break;
  }let o=e.indexOf(";",n);if (o===-1) {
    o=e.length;
  } else
    if(o<r){n=e.lastIndexOf(";",r-1)+1;continue}const s=e.slice(n,r).trim();if(t[s]===void 0){
    let i=e.slice(r+1,o).trim();

    if (i.charCodeAt(0)===34) {
      (i = i.slice(1,-1));
    }

    try{t[s]=i.includes("%")?decodeURIComponent(i):i}catch{t[s]=i}
  }n=o+1}

  return t
}const CP=["X-Client-IP","X-Forwarded-For","Fly-Client-IP","CF-Connecting-IP","Fastly-Client-Ip","True-Client-Ip","X-Real-IP","X-Cluster-Client-IP","X-Forwarded","Forwarded-For","Forwarded","X-Vercel-Forwarded-For"];function gV(e){return CP.map(o=>{
  const s=e[o];
  const i=Array.isArray(s)?s.join(";"):s;
  return o==="Forwarded"?RV(i):i?.split(",").map(a => a.trim());
}).reduce((o, s) => s?o.concat(s):o,[]).find(o => o!==null&&NV(o))||null;}function RV(e){if (!e) {
  return null;
}for (const t of e.split(";")) {
  if (t.startsWith("for=")) {
    return t.slice(4);
  }
}return null}function NV(e){return /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-fA-F\d]{1,4}:){7}(?:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,2}|:)|(?:[a-fA-F\d]{1,4}:){4}(?:(?::[a-fA-F\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,3}|:)|(?:[a-fA-F\d]{1,4}:){3}(?:(?::[a-fA-F\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,4}|:)|(?:[a-fA-F\d]{1,4}:){2}(?:(?::[a-fA-F\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,5}|:)|(?:[a-fA-F\d]{1,4}:){1}(?:(?::[a-fA-F\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,6}|:)|(?::(?:(?::[a-fA-F\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,7}|:)))(?:%[0-9a-zA-Z]{1,})?$)/.test(e);}
const yV={cookies:true,data:true,headers:true,query_string:true,url:true};
const OV="RequestData";

const bV=((e={})=>{const t={...yV,...e.include};return {name:OV,processEvent(n,r,o){
  const {sdkProcessingMetadata={}}=n;
  const {normalizedRequest,ipAddress}=sdkProcessingMetadata;
  const c={...t,ip:t.ip??o.getOptions().sendDefaultPii};

  if (normalizedRequest) {
    IV(n,normalizedRequest,{ipAddress:ipAddress},c);
  }

  return n;
}};});

const CV=bV;
function IV(e,t,n,r){
  e.request={...e.request,...PV(t,r)};

  if (r.ip)
    {
      const o=t.headers&&gV(t.headers)||n.ipAddress;

      if (o) {
        (e.user = {...e.user,ip_address:o});
      }
    }
}function PV(e,t){
  const n={};
  const r={...e.headers};

  if (t.headers) {
    n.headers=r;
    t.cookies||delete r.cookie;
    t.ip||CP.forEach(o=>{delete r[o]});
  }

  n.method=e.method;

  if (t.url) {
    (n.url = e.url);
  }

  if (t.cookies)
    {const o=e.cookies||(r?.cookie?AV(r.cookie):void 0);n.cookies=o||{}}

  if (t.query_string) {
    (n.query_string = e.query_string);
  }

  if (t.data) {
    (n.data = e.data);
  }

  return n;
}function MV(e){
  const t="console";
  dE(t,e);
  fE(t,vV);
}function vV(){
  if ("console"in ye) {
    PI.forEach(e => {
      if (e in ye.console) {
        lk(ye.console,e,t => {
          fu[e]=t;

          return (...n) => {
            _E("console",{args:n,level:e});
            fu[e]?.apply(ye.console,n);
          };
        });
      }
    });
  }
}function LV(e){return e==="warn"?"warning":["fatal","error","warning","log","info","debug"].includes(e)?e:"log"}function wV(e,t){let n=0;for(let r=e.length-1;r>=0;r--){
  const o=e[r];

  if (o===".") {
    e.splice(r,1);
  } else if (o==="..") {
    e.splice(r,1);
    n++;
  } else if (n) {
    e.splice(r,1);
    n--;
  }
}if (t) {
  for (; n--; n) {
    e.unshift("..");
  }
}return e}const DV=/^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/;function IP(e){
  const t=e.length>1024?`<truncated>${e.slice(-1024)}`:e;
  const n=DV.exec(t);
  return n?n.slice(1):[]
}function bg(...e){
  let t="";
  let n=false;
  for(let r=e.length-1;r>=-1&&!n;r--){
    const o=r>=0?e[r]:"/";

    if (o) {
      t=`${o}/${t}`;
      n=o.charAt(0)==="/";
    }
  }

  t=wV(t.split("/").filter(r => !!r),!n).join("/");

  return (n?"/":"")+t||".";
}function Cg(e){let t=0;for (; t<e.length&&e[t]===""; t++)
  {}let n=e.length-1;for (; n>=0&&e[n]===""; n--)
  {}return t>n?[]:e.slice(t,n-t+1)}function UV(e,t){
  e=bg(e).slice(1);
  t=bg(t).slice(1);
  const n=Cg(e.split("/"));
  const r=Cg(t.split("/"));
  const o=Math.min(n.length,r.length);
  let s=o;for (let a=0; a<o; a++) {
    if(n[a]!==r[a]){s=a;break}
  }let i=[];for (let a=s; a<n.length; a++) {
    i.push("..");
  }
  i=i.concat(r.slice(s));
  return i.join("/");
}function kV(e){
  const t=IP(e);
  const n=t[0]||"";
  let r=t[1];return!n&&!r?".":(r&&(r=r.slice(0,r.length-1)),n+r)
}function GV(e,t){return IP(e)[2]||""}
const VV="RewriteFrames";

const xV=(e={})=>{
  const t=e.root;
  const n=e.prefix||"app:///";
  const r="window"in ye&&!!ye.window;
  const o=e.iteratee||$V({isBrowser:r,root:t,prefix:n});
  function s(a){try{return {...a,exception:{...a.exception,values:a.exception.values.map(c => ({
    ...c,
    ...(c.stacktrace && {stacktrace:i(c.stacktrace)})
  }))}};}catch{return a}}function i(a){return {...a,frames:a?.frames?.map(c => o(c))};}return {name:VV,processEvent(a){
  let c=a;

  if (a.exception&&Array.isArray(a.exception.values)) {
    (c = s(c));
  }

  return c;
}};
};

function $V({isBrowser,root,prefix}){return r=>{
  if (!r.filename) {
    return r;
  }
  const o=/^[a-zA-Z]:\\/.test(r.filename)||r.filename.includes("\\")&&!r.filename.includes("/");
  const s=/^\//.test(r.filename);
  if(isBrowser){if(root){
    const i=r.filename;

    if (i.indexOf(root)===0) {
      (r.filename = i.replace(root,prefix));
    }
  }}else if(o||s){
    const i=o?r.filename.replace(/^[a-zA-Z]:/,"").replace(/\\/g,"/"):r.filename;
    const a=root?UV(root,i):GV(i);
    r.filename=`${prefix}${a}`
  }return r
};}
const BV="Console";
const HV=(e={})=>{const t=new Set(e.levels||PI);return {name:BV,setup(n){MV(({args,level})=>{
  if (he() === n && t.has(level)) {
    FV(level,args);
  }
})}};};
function FV(e,t){const n={category:"console",data:{arguments:t,logger:"console"},level:LV(e),message:Ig(t)};if (e==="assert") {
  if (t[0]===false) {
    const r=t.slice(1);
    n.message=r.length>0?`Assertion failed: ${Ig(r)}`:"Assertion failed";
    n.data.arguments=r;
  } else {
    return;
  }
}Bo(n,{input:t,level:e})}function Ig(e){return"util"in ye&&typeof ye.util.format=="function"?ye.util.format(...e):Ek(e," ")}
const YV="gen_ai.prompt";
const El="gen_ai.system";
const Nt="gen_ai.request.model";
const vE="gen_ai.request.stream";
const hl="gen_ai.request.temperature";
const LE="gen_ai.request.max_tokens";
const Tl="gen_ai.request.frequency_penalty";
const wE="gen_ai.request.presence_penalty";
const Sl="gen_ai.request.top_p";
const PP="gen_ai.request.top_k";
const jV="gen_ai.request.encoding_format";
const qV="gen_ai.request.dimensions";
const sr="gen_ai.response.finish_reasons";
const Rn="gen_ai.response.model";
const Jo="gen_ai.response.id";
const WV="gen_ai.response.stop_reason";
const jt="gen_ai.usage.input_tokens";
const qt="gen_ai.usage.output_tokens";
const so="gen_ai.usage.total_tokens";
const Fn="gen_ai.operation.name";
const Gt="gen_ai.request.messages";
const Wt="gen_ai.response.text";
const ml="gen_ai.request.available_tools";
const Al="gen_ai.response.streaming";
const On="gen_ai.response.tool_calls";
const MP="gen_ai.agent.name";
const KV="gen_ai.pipeline.name";
const zV="gen_ai.usage.cache_creation_input_tokens";
const ZV="gen_ai.usage.cache_read_input_tokens";
const Pg="gen_ai.usage.input_tokens.cache_write";
const $a="gen_ai.usage.input_tokens.cached";
const XV="gen_ai.invoke_agent";
const QV="openai.response.id";
const vP="openai.response.model";
const JV="openai.response.timestamp";
const ex="openai.usage.completion_tokens";
const tx="openai.usage.prompt_tokens";
const yd={CHAT:"chat",RESPONSES:"responses",EMBEDDINGS:"embeddings"};
const Mg="anthropic.response.timestamp";
const DE=new Map;
const LP=20000/* 2e4 */;

const Nu=e => new TextEncoder().encode(e).length;

const yu=e => Nu(JSON.stringify(e));

function UE(e,t){
  if (Nu(e)<=t) {
    return e;
  }
  let n=0;
  let r=e.length;
  let o="";

  while (n<=r) {
    const s=Math.floor((n+r)/2);
    const i=e.slice(0,s);

    if (Nu(i)<=t) {
      o=i;
      n=s+1;
    } else {
      r=s-1;
    }
  }

  return o
}function nx(e){return typeof e=="string"?e:e.text}function vg(e,t){return typeof e=="string"?t:{...e,text:t}}function rx(e){return e!==null&&typeof e=="object"&&"content"in e&&typeof e.content=="string"}function ox(e){return e!==null&&typeof e=="object"&&"parts"in e&&Array.isArray(e.parts)&&e.parts.length>0}function sx(e,t){
  const n={...e,content:""};
  const r=yu(n);
  const o=t-r;
  if (o<=0) {
    return[];
  }const s=UE(e.content,o);return[{...e,content:s}]
}function ix(e,t){
  const {parts}=e;

  const r=parts.map(a => vg(a,""));

  const o=yu({...e,parts:r});
  let s=t-o;if (s<=0) {
    return[];
  }const i=[];for(const a of parts){
    const c=nx(a);
    const l=Nu(c);
    if (l<=s) {
      i.push(a);
      s-=l;
    } else if (i.length===0)
      {
        const f=UE(c,s);

        if (f) {
          i.push(vg(a,f));
        }

        break
      } else {
      break
    }
  }return i.length>0?[{...e,parts:i}]:[]
}function ax(e,t){
  if (!e||typeof e!="object") {
    return [];
  }

  if (rx(e)) {
    return sx(e,t);
  }

  if (ox(e)) {
    return ix(e,t);
  }

  return [];
}function cx(e,t){
  if (!Array.isArray(e)||e.length===0||yu(e)<=t) {
    return e;
  }const r=e.map(yu);
  let o=0;
  let s=e.length;
  for(let i=e.length-1;i>=0;i--){
    const a=r[i];if (a&&o+a>t) {
        break;
      }

    if (a) {
      (o += a);
    }

    s=i;
  }if(s===e.length){const i=e[e.length-1];return ax(i,t)}return e.slice(s)
}function kE(e){return cx(e,LP)}function ux(e){return UE(e,LP)}function yc(e){return e.includes("messages")?"messages":e.includes("completions")?"completions":e.includes("models")?"models":e.includes("chat")?"chat":e.split(".").pop()||"unknown"}function Ou(e){return`gen_ai.${yc(e)}`}function wP(e,t){return e?`${e}.${t}`:t}function GE(e,t,n,r,o){
  if (t!==void 0) {
    e.setAttributes({[jt]:t});
  }

  if (n!==void 0) {
    e.setAttributes({[qt]:n});
  }

  if (t!==void 0||n!==void 0||r!==void 0||o!==void 0)
    {const s=(t??0)+(n??0)+(r??0)+(o??0);e.setAttributes({[so]:s})}
}function $n(e){if (typeof e=="string") {
  return ux(e);
}if(Array.isArray(e)){const t=kE(e);return JSON.stringify(t)}return JSON.stringify(e)}
const lx="operation.name";
const Od="ai.prompt";
const dx="ai.schema";
const fx="ai.response.object";
const _x="ai.response.text";
const px="ai.response.toolCalls";
const DP="ai.prompt.messages";
const na="ai.prompt.tools";
const pn="ai.model.id";
const Ex="ai.model.provider";
const hx="ai.response.providerMetadata";
const Tx="ai.usage.cachedInputTokens";
const Sx="ai.telemetry.functionId";
const mx="ai.usage.completionTokens";
const Ax="ai.usage.promptTokens";
const UP="ai.toolCall.name";
const kP="ai.toolCall.id";
const gx="ai.toolCall.args";
const Rx="ai.toolCall.result";
function Nx(e,t){
  const n=e.parent_span_id;if (!n) {
    return;
  }
  const r=e.data[jt];
  const o=e.data[qt];
  if(typeof r=="number"||typeof o=="number"){
    const s=t.get(n)||{inputTokens:0,outputTokens:0};

    if (typeof r=="number") {
      (s.inputTokens += r);
    }

    if (typeof o=="number") {
      (s.outputTokens += o);
    }

    t.set(n,s);
  }
}function Lg(e,t){
  const n=t.get(e.span_id);

  if (n && e.data) {
    n.inputTokens>0&&(e.data[jt]=n.inputTokens);
    n.outputTokens>0&&(e.data[qt]=n.outputTokens);
    (n.inputTokens>0||n.outputTokens>0)&&(e.data["gen_ai.usage.total_tokens"]=n.inputTokens+n.outputTokens);
  }
}function yx(e){return DE.get(e)}function Ox(e){DE.delete(e)}function bx(e){const t=e.map(n=>{if (typeof n=="string") {
  try{return JSON.parse(n)}catch{return n}
}return n});return JSON.stringify(t)}function Cx(e){try{const t=JSON.parse(e);if(t&&typeof t=="object"){const{prompt,system}=t;if(typeof prompt=="string"||typeof system=="string"){
  const o=[];

  if (typeof system=="string") {
    o.push({role:"system",content:system});
  }

  if (typeof prompt=="string") {
    o.push({role:"user",content:prompt});
  }

  return o;
}}}catch{}return[]}function Ix(e,t){if(t[Od]){const r=$n(t[Od]);e.setAttribute("gen_ai.prompt",r)}const n=t[Od];if(typeof n=="string"&&!t[Gt]&&!t[DP]){
  const r=Cx(n);

  if (r.length) {
    e.setAttribute(Gt,$n(r));
  }
}}function GP(e,t){e.setAttribute(Ge,t)}function Px(e){
  const{data,description}=Re(e);if (!description) {
      return;
    }if(data[UP]&&data[kP]&&description==="ai.toolCall"){Lx(e,data);return}
  const r=data[pn];
  const o=data[Ex];

  if (typeof r == "string" && typeof o == "string" && r && o) {
    wx(e,description,data);
  }
}function Mx(e){if(e.type==="transaction"&&e.spans){
  const t=new Map;for (const r of e.spans) {
    vx(r);
    Nx(r,t);
  }for (const r of e.spans) {
    if (r.op==="gen_ai.invoke_agent") {
      Lg(r,t);
    }
  }const n=e.contexts?.trace;

  if (n&&n.op==="gen_ai.invoke_agent") {
    Lg(n,t);
  }
}return e}function vx(e){const{data,origin}=e;if(origin==="auto.vercelai.otel"){
  ct(data,mx,qt);
  ct(data,Ax,jt);
  ct(data,Tx,$a);

  if (typeof data[qt]=="number"&&typeof data[jt]=="number") {
    (data["gen_ai.usage.total_tokens"] = data[qt]+data[jt]);
  }

  if (data[na]&&Array.isArray(data[na])) {
    (data[na] = bx(data[na]));
  }

  ct(data,lx,Fn);
  ct(data,DP,Gt);
  ct(data,_x,"gen_ai.response.text");
  ct(data,px,"gen_ai.response.tool_calls");
  ct(data,fx,"gen_ai.response.object");
  ct(data,na,"gen_ai.request.available_tools");
  ct(data,gx,"gen_ai.tool.input");
  ct(data,Rx,"gen_ai.tool.output");
  ct(data,dx,"gen_ai.request.schema");
  ct(data,pn,Nt);
  Dx(data);
  for (const r of Object.keys(data)) {
    if (r.startsWith("ai.")) {
      ct(data,r,`vercel.${r}`);
    }
  }
}}function ct(e,t,n){
  if (e[t]!=null) {
    e[n]=e[t];
    delete e[t];
  }
}function Lx(e,t){
  GP(e,"auto.vercelai.otel");
  e.setAttribute(Ee,"gen_ai.execute_tool");
  ct(t,UP,"gen_ai.tool.name");
  ct(t,kP,"gen_ai.tool.call.id");
  const n=t["gen_ai.tool.call.id"];

  if (typeof n=="string") {
    DE.set(n,e);
  }

  if (!t["gen_ai.tool.type"]) {
    e.setAttribute("gen_ai.tool.type","function");
  }

  const r=t["gen_ai.tool.name"];

  if (r) {
    e.updateName(`execute_tool ${r}`);
  }
}function wx(e,t,n){
  GP(e,"auto.vercelai.otel");const r=t.replace("ai.","");
  e.setAttribute("ai.pipeline.name",r);
  e.updateName(r);
  const o=n[Sx];

  if (o&&typeof o=="string") {
    e.updateName(`${r} ${o}`);
    e.setAttribute("gen_ai.function_id",o);
  }

  Ix(e,n);

  if (n[pn]&&!n[Rn]) {
    e.setAttribute(Rn,n[pn]);
  }

  e.setAttribute("ai.streaming",t.includes("stream"));

  if (t==="ai.generateText")
    {e.setAttribute(Ee,"gen_ai.invoke_agent");return}

  if(t==="ai.generateText.doGenerate"){
    e.setAttribute(Ee,"gen_ai.generate_text");
    e.updateName(`generate_text ${n[pn]}`);
    return
  }if(t==="ai.streamText"){e.setAttribute(Ee,"gen_ai.invoke_agent");return}if(t==="ai.streamText.doStream"){
      e.setAttribute(Ee,"gen_ai.stream_text");
      e.updateName(`stream_text ${n[pn]}`);
      return
    }if(t==="ai.generateObject"){e.setAttribute(Ee,"gen_ai.invoke_agent");return}if(t==="ai.generateObject.doGenerate"){
      e.setAttribute(Ee,"gen_ai.generate_object");
      e.updateName(`generate_object ${n[pn]}`);
      return
    }if(t==="ai.streamObject"){e.setAttribute(Ee,"gen_ai.invoke_agent");return}if(t==="ai.streamObject.doStream"){
      e.setAttribute(Ee,"gen_ai.stream_object");
      e.updateName(`stream_object ${n[pn]}`);
      return
    }if(t==="ai.embed"){e.setAttribute(Ee,"gen_ai.invoke_agent");return}if(t==="ai.embed.doEmbed"){
      e.setAttribute(Ee,"gen_ai.embed");
      e.updateName(`embed ${n[pn]}`);
      return
    }if(t==="ai.embedMany"){e.setAttribute(Ee,"gen_ai.invoke_agent");return}if(t==="ai.embedMany.doEmbed"){
      e.setAttribute(Ee,"gen_ai.embed_many");
      e.updateName(`embed_many ${n[pn]}`);
      return
    }if(t.startsWith("ai.stream")){e.setAttribute(Ee,"ai.run");return}
}function wg(e){
  e.on("spanStart",Px);
  e.addEventProcessor(Object.assign(Mx,{id:"VercelAiEventProcessor"}));
}function Dx(e){const t=e[hx];if (t) {
  try{
    const n=JSON.parse(t);

    if (n.openai) {
      en(e,$a,n.openai.cachedPromptTokens);
      en(e,"gen_ai.usage.output_tokens.reasoning",n.openai.reasoningTokens);
      en(e,"gen_ai.usage.output_tokens.prediction_accepted",n.openai.acceptedPredictionTokens);
      en(e,"gen_ai.usage.output_tokens.prediction_rejected",n.openai.rejectedPredictionTokens);
      en(e,"gen_ai.conversation.id",n.openai.responseId);
    }

    if (n.anthropic)
      {const r=n.anthropic.usage?.cache_read_input_tokens??n.anthropic.cacheReadInputTokens;en(e,$a,r);const o=n.anthropic.usage?.cache_creation_input_tokens??n.anthropic.cacheCreationInputTokens;en(e,Pg,o)}

    if (n.bedrock?.usage) {
      en(e,$a,n.bedrock.usage.cacheReadInputTokens);
      en(e,Pg,n.bedrock.usage.cacheWriteInputTokens);
    }

    if (n.deepseek) {
      en(e,$a,n.deepseek.promptCacheHitTokens);
      en(e,"gen_ai.usage.input_tokens.cache_miss",n.deepseek.promptCacheMissTokens);
    }
  }catch{}
}}function en(e,t,n){
  if (n!=null) {
    (e[t] = n);
  }
}
const gl="OpenAI";
const Ux=["responses.create","chat.completions.create","embeddings.create"];
const kx=["response.output_item.added","response.function_call_arguments.delta","response.function_call_arguments.done","response.output_item.done"];
const Gx=["response.created","response.in_progress","response.failed","response.completed","response.incomplete","response.queued","response.output_text.delta",...kx];
function VE(e){return e.includes("chat.completions")?yd.CHAT:e.includes("responses")?yd.RESPONSES:e.includes("embeddings")?yd.EMBEDDINGS:e.split(".").pop()||"unknown"}function Dg(e){return`gen_ai.${VE(e)}`}function Vx(e){return Ux.includes(e)}function xx(e,t){return e?`${e}.${t}`:t}function $x(e){return e!==null&&typeof e=="object"&&"object"in e&&e.object==="chat.completion"}function Bx(e){return e!==null&&typeof e=="object"&&"object"in e&&e.object==="response"}function Hx(e){if (e===null||typeof e!="object"||!("object"in e)) {
  return false;
}const t=e;return t.object==="list"&&typeof t.model=="string"&&t.model.toLowerCase().includes("embedding")}function Fx(e){return e!==null&&typeof e=="object"&&"type"in e&&typeof e.type=="string"&&e.type.startsWith("response.")}function Yx(e){return e!==null&&typeof e=="object"&&"object"in e&&e.object==="chat.completion.chunk"}function jx(e,t,n){
  xE(e,t.id,t.model,t.created);

  if (t.usage) {
    Rl(e,t.usage.prompt_tokens,t.usage.completion_tokens,t.usage.total_tokens);
  }

  if (Array.isArray(t.choices)) {
    const r=t.choices.map(o => o.finish_reason).filter(o => o!==null);

    if (r.length>0) {
      e.setAttributes({[sr]:JSON.stringify(r)});
    }

    if (n) {
      const o=t.choices.map(s => s.message?.tool_calls).filter(s => Array.isArray(s)&&s.length>0).flat();

      if (o.length>0) {
        e.setAttributes({[On]:JSON.stringify(o)});
      }
    }
  }
}function qx(e,t,n){
  xE(e,t.id,t.model,t.created_at);

  if (t.status) {
    e.setAttributes({[sr]:JSON.stringify([t.status])});
  }

  if (t.usage) {
    Rl(e,t.usage.input_tokens,t.usage.output_tokens,t.usage.total_tokens);
  }

  if (n) {const r=t;if(Array.isArray(r.output)&&r.output.length>0){
    const o=r.output.filter(s => typeof s=="object"&&s!==null&&s.type==="function_call");

    if (o.length>0) {
      e.setAttributes({[On]:JSON.stringify(o)});
    }
  }}
}function Wx(e,t){
  e.setAttributes({[vP]:t.model,[Rn]:t.model});

  if (t.usage) {
    Rl(e,t.usage.prompt_tokens,void 0,t.usage.total_tokens);
  }
}function Rl(e,t,n,r){
  if (t!==void 0) {
    e.setAttributes({[tx]:t,[jt]:t});
  }

  if (n!==void 0) {
    e.setAttributes({[ex]:n,[qt]:n});
  }

  if (r!==void 0) {
    e.setAttributes({[so]:r});
  }
}function xE(e,t,n,r){
  e.setAttributes({[QV]:t,[Jo]:t});
  e.setAttributes({[vP]:n,[Rn]:n});
  e.setAttributes({[JV]:new Date(r*1000/* 1e3 */).toISOString()});
}function Kx(e,t){for(const n of e){const r=n.index;if (!(r===void 0||!n.function)) {
  if (!(r in t.chatCompletionToolCalls)) {
    t.chatCompletionToolCalls[r]={...n,function:{name:n.function.name,arguments:n.function.arguments||""}};
  } else
    {
      const o=t.chatCompletionToolCalls[r];

      if (n.function.arguments&&o?.function) {
        (o.function.arguments += n.function.arguments);
      }
    }
}}}function zx(e,t,n){
  t.responseId=e.id??t.responseId;
  t.responseModel=e.model??t.responseModel;
  t.responseTimestamp=e.created??t.responseTimestamp;

  if (e.usage) {
    t.promptTokens=e.usage.prompt_tokens;
    t.completionTokens=e.usage.completion_tokens;
    t.totalTokens=e.usage.total_tokens;
  }

  for (const r of e.choices??[]) {
    if (n) {
      r.delta?.content&&t.responseTexts.push(r.delta.content);
      r.delta?.tool_calls&&Kx(r.delta.tool_calls,t);
    }

    if (r.finish_reason) {
      t.finishReasons.push(r.finish_reason);
    }
  }
}function Zx(e,t,n,r){if(!(e&&typeof e=="object")){t.eventTypes.push("unknown:non-object");return}if(e instanceof Error){
  r.setStatus({code:Ae,message:"internal_error"});
  xe(e,{mechanism:{handled:false,type:"auto.ai.openai.stream-response"}});
  return
}if (!("type"in e)) {
  return;
}const o=e;if(!Gx.includes(o.type)){t.eventTypes.push(o.type);return}if(n&&(o.type==="response.output_item.done"&&"item"in o&&t.responsesApiToolCalls.push(o.item),o.type==="response.output_text.delta"&&"delta"in o&&o.delta)){t.responseTexts.push(o.delta);return}if("response"in o){
  const{response}=o;
  t.responseId=response.id??t.responseId;
  t.responseModel=response.model??t.responseModel;
  t.responseTimestamp=response.created_at??t.responseTimestamp;

  if (response.usage) {
    t.promptTokens=response.usage.input_tokens;
    t.completionTokens=response.usage.output_tokens;
    t.totalTokens=response.usage.total_tokens;
  }

  if (response.status) {
    t.finishReasons.push(response.status);
  }

  if (n&&response.output_text) {
    t.responseTexts.push(response.output_text);
  }
}}async function*Xx(e,t,n){const r={eventTypes:[],responseTexts:[],finishReasons:[],responseId:"",responseModel:"",responseTimestamp:0,promptTokens:void 0,completionTokens:void 0,totalTokens:void 0,chatCompletionToolCalls:{},responsesApiToolCalls:[]};try{for await (const o of e) {
  if (Yx(o)) {
    zx(o,r,n);
  } else if (Fx(o)) {
    Zx(o,r,n,t);
  }

  yield o;
}}finally{
  xE(t,r.responseId,r.responseModel,r.responseTimestamp);
  Rl(t,r.promptTokens,r.completionTokens,r.totalTokens);
  t.setAttributes({[Al]:true});

  if (r.finishReasons.length) {
    t.setAttributes({[sr]:JSON.stringify(r.finishReasons)});
  }

  if (n&&r.responseTexts.length) {
    t.setAttributes({[Wt]:r.responseTexts.join("")});
  }

  const s=[...Object.values(r.chatCompletionToolCalls),...r.responsesApiToolCalls];

  if (s.length>0) {
    t.setAttributes({[On]:JSON.stringify(s)});
  }

  t.end();
}}function Qx(e,t){const n={[El]:"openai",[Fn]:VE(t),[Ge]:"auto.ai.openai"};if(e.length>0&&typeof e[0]=="object"&&e[0]!==null){
  const r=e[0];
  const o=Array.isArray(r.tools)?r.tools:[];
  const i=r.web_search_options&&typeof r.web_search_options=="object"?[{type:"web_search_options",...r.web_search_options}]:[];
  const a=[...o,...i];

  if (a.length>0) {
    (n[ml] = JSON.stringify(a));
  }
}if (e.length>0&&typeof e[0]=="object"&&e[0]!==null) {
  const r=e[0];
  n[Nt]=r.model??"unknown";

  if ("temperature"in r) {
    (n[hl] = r.temperature);
  }

  if ("top_p"in r) {
    (n[Sl] = r.top_p);
  }

  if ("frequency_penalty"in r) {
    (n[Tl] = r.frequency_penalty);
  }

  if ("presence_penalty"in r) {
    (n[wE] = r.presence_penalty);
  }

  if ("stream"in r) {
    (n[vE] = r.stream);
  }

  if ("encoding_format"in r) {
    (n[jV] = r.encoding_format);
  }

  if ("dimensions"in r) {
    (n[qV] = r.dimensions);
  }
} else {
  n[Nt]="unknown";
}return n}function Jx(e,t,n){if (!t||typeof t!="object") {
  return;
}const r=t;if ($x(r)) {
  jx(e,r,n);

  if (n&&r.choices?.length) {const o=r.choices.map(s => s.message?.content||"");e.setAttributes({[Wt]:JSON.stringify(o)})}
} else {
  if (Bx(r)) {
    qx(e,r,n);
    n&&r.output_text&&e.setAttributes({[Wt]:r.output_text});
  } else if (Hx(r)) {
    Wx(e,r);
  }
}}function Ug(e,t){if("messages"in t){const n=$n(t.messages);e.setAttributes({[Gt]:n})}if("input"in t){const n=$n(t.input);e.setAttributes({[Gt]:n})}}function e$(e,t,n,r){return async (...s) => {
  const i=Qx(s,t);
  const a=i[Nt]||"unknown";
  const c=VE(t);
  const l=s[0];
  return l&&typeof l=="object"&&l.stream===true?xn({name:`${c} ${a} stream-response`,op:Dg(t),attributes:i},async d=>{try{
    if (r.recordInputs&&l) {
      Ug(d,l);
    }

    const u=await e.apply(n,s);return Xx(u,d,r.recordOutputs??false);
  }catch(u){
    d.setStatus({code:Ae,message:"internal_error"});
    xe(u,{mechanism:{handled:false,type:"auto.ai.openai.stream",data:{function:t}}});
    d.end();
    throw u;
  }}):Qo({name:`${c} ${a}`,op:Dg(t),attributes:i},async d=>{try{
    if (r.recordInputs&&l) {
      Ug(d,l);
    }

    const u=await e.apply(n,s);
    Jx(d,u,r.recordOutputs);
    return u;
  }catch(u){
    xe(u,{mechanism:{handled:false,type:"auto.ai.openai",data:{function:t}}});
    throw u;
  }});
};}function VP(e,t="",n){return new Proxy(e,{get(r,o){
  const s=r[o];
  const i=xx(t,String(o));
  return typeof s=="function"&&Vx(i)?e$(s,i,r,n):typeof s=="function"?s.bind(r):s&&typeof s=="object"?VP(s,i,n):s
}});}function t$(e,t){
  const n=!!he()?.getOptions().sendDefaultPii;
  const r={recordInputs:n,recordOutputs:n,...t};
  return VP(e,"",r)
}function n$(e,t){return "type"in e&&typeof e.type=="string"&&e.type==="error"?(t.setStatus({code:Ae,message:e.error?.type??"internal_error"}),xe(e.error,{mechanism:{handled:false,type:"auto.ai.anthropic.anthropic_error"}}),true):false;}function r$(e,t){
  if (e.type==="message_delta"&&e.usage&&"output_tokens"in e.usage&&typeof e.usage.output_tokens=="number") {
    (t.completionTokens = e.usage.output_tokens);
  }

  if (e.message) {
    const n=e.message;

    if (n.id) {
      (t.responseId = n.id);
    }

    if (n.model) {
      (t.responseModel = n.model);
    }

    if (n.stop_reason) {
      t.finishReasons.push(n.stop_reason);
    }

    if (n.usage) {
      typeof n.usage.input_tokens=="number"&&(t.promptTokens=n.usage.input_tokens);
      typeof n.usage.cache_creation_input_tokens=="number"&&(t.cacheCreationInputTokens=n.usage.cache_creation_input_tokens);
      typeof n.usage.cache_read_input_tokens=="number"&&(t.cacheReadInputTokens=n.usage.cache_read_input_tokens);
    }
  }
}function o$(e,t){
  if (e.type === "content_block_start" && typeof e.index == "number" && e.content_block) {
    if ((e.content_block.type==="tool_use" || e.content_block.type==="server_tool_use")) {
      (t.activeToolBlocks[e.index] = {id:e.content_block.id,name:e.content_block.name,inputJsonParts:[]});
    }
  }
}function s$(e,t,n){if(!(e.type!=="content_block_delta"||!e.delta)){
  if(typeof e.index=="number"&&"partial_json"in e.delta&&typeof e.delta.partial_json=="string"){
    const r=t.activeToolBlocks[e.index];

    if (r) {
      r.inputJsonParts.push(e.delta.partial_json);
    }
  }

  if (n&&typeof e.delta.text=="string") {
    t.responseTexts.push(e.delta.text);
  }
}}function i$(e,t){
  if (e.type!=="content_block_stop"||typeof e.index!="number") {
    return;
  }const n=t.activeToolBlocks[e.index];if (!n) {
    return;
  }const r=n.inputJsonParts.join("");let o;try{o=r?JSON.parse(r):{}}catch{o={__unparsed:r}}
  t.toolCalls.push({type:"tool_use",id:n.id,name:n.name,input:o});
  delete t.activeToolBlocks[e.index];
}function xP(e,t,n,r){
  if ((e && typeof e=="object") && !n$(e,r)) {
    r$(e,t);
    o$(e,t);
    s$(e,t,n);
    i$(e,t);
  }
}function a$(e,t,n){
  if (t.isRecording()) {
    e.responseId&&t.setAttributes({[Jo]:e.responseId});
    e.responseModel&&t.setAttributes({[Rn]:e.responseModel});
    GE(t,e.promptTokens,e.completionTokens,e.cacheCreationInputTokens,e.cacheReadInputTokens);
    t.setAttributes({[Al]:true});
    e.finishReasons.length>0&&t.setAttributes({[sr]:JSON.stringify(e.finishReasons)});
    n&&e.responseTexts.length>0&&t.setAttributes({[Wt]:e.responseTexts.join("")});
    n&&e.toolCalls.length>0&&t.setAttributes({[On]:JSON.stringify(e.toolCalls)});
    t.end();
  }
}async function*c$(e,t,n){const r={responseTexts:[],finishReasons:[],responseId:"",responseModel:"",promptTokens:void 0,completionTokens:void 0,cacheCreationInputTokens:void 0,cacheReadInputTokens:void 0,toolCalls:[],activeToolBlocks:{}};try{for await (const o of e) {
  xP(o,r,n,t);
  yield o;
}}finally{
  if (r.responseId) {
    t.setAttributes({[Jo]:r.responseId});
  }

  if (r.responseModel) {
    t.setAttributes({[Rn]:r.responseModel});
  }

  GE(t,r.promptTokens,r.completionTokens,r.cacheCreationInputTokens,r.cacheReadInputTokens);
  t.setAttributes({[Al]:true});

  if (r.finishReasons.length>0) {
    t.setAttributes({[sr]:JSON.stringify(r.finishReasons)});
  }

  if (n&&r.responseTexts.length>0) {
    t.setAttributes({[Wt]:r.responseTexts.join("")});
  }

  if (n&&r.toolCalls.length>0) {
    t.setAttributes({[On]:JSON.stringify(r.toolCalls)});
  }

  t.end();
}}function u$(e,t,n){
  const r={responseTexts:[],finishReasons:[],responseId:"",responseModel:"",promptTokens:void 0,completionTokens:void 0,cacheCreationInputTokens:void 0,cacheReadInputTokens:void 0,toolCalls:[],activeToolBlocks:{}};
  e.on("streamEvent",o=>{xP(o,r,n,t)});
  e.on("message",()=>{a$(r,t,n)});

  e.on("error",o=>{
    xe(o,{mechanism:{handled:false,type:"auto.ai.anthropic.stream_error"}});

    if (t.isRecording()) {
      t.setStatus({code:Ae,message:"stream_error"});
      t.end();
    }
  });

  return e;
}
const Nl="Anthropic_AI";
const l$=["messages.create","messages.stream","messages.countTokens","models.get","completions.create","models.retrieve","beta.messages.create"];
function d$(e){return l$.includes(e)}function f$(e,t){
  if (t.error) {
    e.setStatus({code:Ae,message:t.error.type||"internal_error"});
    xe(t.error,{mechanism:{handled:false,type:"auto.ai.anthropic.anthropic_error"}});
  }
}function _$(e){
  const {system,messages}=e;
  const r=typeof system=="string"?[{role:"system",content:e.system}]:[];
  const o=Array.isArray(messages)?messages:messages!=null?[messages]:[];
  return[...r,...o]
}function p$(e,t){const n={[El]:"anthropic",[Fn]:yc(t),[Ge]:"auto.ai.anthropic"};if (e.length>0&&typeof e[0]=="object"&&e[0]!==null) {
  const r=e[0];

  if (r.tools&&Array.isArray(r.tools)) {
    (n[ml] = JSON.stringify(r.tools));
  }

  n[Nt]=r.model??"unknown";

  if ("temperature"in r) {
    (n[hl] = r.temperature);
  }

  if ("top_p"in r) {
    (n[Sl] = r.top_p);
  }

  if ("stream"in r) {
    (n[vE] = r.stream);
  }

  if ("top_k"in r) {
    (n[PP] = r.top_k);
  }

  if ("frequency_penalty"in r) {
    (n[Tl] = r.frequency_penalty);
  }

  if ("max_tokens"in r) {
    (n[LE] = r.max_tokens);
  }
} else {
  if (t==="models.retrieve"||t==="models.get") {
    n[Nt]=e[0];
  } else {
    n[Nt]="unknown";
  }
}return n}function mp(e,t){
  const n=_$(t);if(n.length){const r=$n(n);e.setAttributes({[Gt]:r})}if("input"in t){const r=$n(t.input);e.setAttributes({[Gt]:r})}

  if ("prompt"in t) {
    e.setAttributes({[YV]:JSON.stringify(t.prompt)});
  }
}function E$(e,t){
  if("content"in t&&Array.isArray(t.content)){
    e.setAttributes({[Wt]:t.content.map(r => r.text).filter(r => !!r).join("")});const n=[];for (const r of t.content) {
      if ((r.type==="tool_use" || r.type==="server_tool_use")) {
        n.push(r);
      }
    }

    if (n.length>0) {
      e.setAttributes({[On]:JSON.stringify(n)});
    }
  }

  if ("completion"in t) {
    e.setAttributes({[Wt]:t.completion});
  }

  if ("input_tokens"in t) {
    e.setAttributes({[Wt]:JSON.stringify(t.input_tokens)});
  }
}function h$(e,t){
  if ("id"in t&&"model"in t) {
    e.setAttributes({[Jo]:t.id,[Rn]:t.model});
    "created"in t&&typeof t.created=="number"&&e.setAttributes({[Mg]:new Date(t.created*1000/* 1e3 */).toISOString()});
    "created_at"in t&&typeof t.created_at=="number"&&e.setAttributes({[Mg]:new Date(t.created_at*1000/* 1e3 */).toISOString()});
    "usage"in t&&t.usage&&GE(e,t.usage.input_tokens,t.usage.output_tokens,t.usage.cache_creation_input_tokens,t.usage.cache_read_input_tokens);
  }
}function T$(e,t,n){if(!(!t||typeof t!="object")){
  if("type"in t&&t.type==="error"){f$(e,t);return}

  if (n) {
    E$(e,t);
  }

  h$(e,t);
}}function kg(e,t,n){
  xe(e,{mechanism:{handled:false,type:"auto.ai.anthropic",data:{function:n}}});

  if (t.isRecording()) {
    t.setStatus({code:Ae,message:"internal_error"});
    t.end();
  }

  throw e;
}function S$(e,t,n,r,o,s,i,a,c,l,f){
  const d=o[Nt]??"unknown";
  const u={name:`${s} ${d} stream-response`,op:Ou(i),attributes:o};
  return l&&!f?xn(u,async _=>{try{
    if (c.recordInputs&&a) {
      mp(_,a);
    }

    const p=await e.apply(n,r);return c$(p,_,c.recordOutputs??false);
  }catch(p){return kg(p,_,i)}}):xn(u,_=>{try{
    if (c.recordInputs&&a) {
      mp(_,a);
    }

    const p=t.apply(n,r);return u$(p,_,c.recordOutputs??false);
  }catch(p){return kg(p,_,i)}});
}function m$(e,t,n,r){return new Proxy(e,{apply(o,s,i){
  const a=p$(i,t);
  const c=a[Nt]??"unknown";
  const l=yc(t);
  const f=typeof i[0]=="object"?i[0]:void 0;
  const d=!!f?.stream;
  const u=t==="messages.stream";
  return d||u?S$(e,o,n,i,a,l,t,f,r,d,u):Qo({name:`${l} ${c}`,op:Ou(t),attributes:a},_ => {
    if (r.recordInputs&&f) {
      mp(_,f);
    }

    return oo(() => o.apply(n,i),p=>{xe(p,{mechanism:{handled:false,type:"auto.ai.anthropic",data:{function:t}}})},()=>{},p => T$(_,p,r.recordOutputs));
  });
}});}function $P(e,t="",n){return new Proxy(e,{get(r,o){
  const s=r[o];
  const i=wP(t,String(o));
  return typeof s=="function"&&d$(i)?m$(s,i,r,n):typeof s=="function"?s.bind(r):s&&typeof s=="object"?$P(s,i,n):s
}});}function A$(e,t){
  const n=!!he()?.getOptions().sendDefaultPii;
  const r={recordInputs:n,recordOutputs:n,...t};
  return $P(e,"",r)
}
const yl="Google_GenAI";
const Gg=["models.generateContent","models.generateContentStream","chats.create","sendMessage","sendMessageStream"];
const g$="google_genai";
const BP="chats.create";
const R$="chat";
function N$(e,t){const n=e?.promptFeedback;if(n?.blockReason){
  const r=n.blockReasonMessage??n.blockReason;
  t.setStatus({code:Ae,message:`Content blocked: ${r}`});
  xe(`Content blocked: ${r}`,{mechanism:{handled:false,type:"auto.ai.google_genai"}});
  return true;
}return false;}function y$(e,t){
  if (typeof e.responseId=="string") {
    (t.responseId = e.responseId);
  }

  if (typeof e.modelVersion=="string") {
    (t.responseModel = e.modelVersion);
  }

  const n=e.usageMetadata;

  if (n) {
    typeof n.promptTokenCount=="number"&&(t.promptTokens=n.promptTokenCount);
    typeof n.candidatesTokenCount=="number"&&(t.completionTokens=n.candidatesTokenCount);
    typeof n.totalTokenCount=="number"&&(t.totalTokens=n.totalTokenCount);
  }
}function O$(e,t,n){
  if (Array.isArray(e.functionCalls)) {
    t.toolCalls.push(...e.functionCalls);
  }

  for(const r of e.candidates??[]){
    if (r?.finishReason&&!t.finishReasons.includes(r.finishReason)) {
      t.finishReasons.push(r.finishReason);
    }

    for (const o of r?.content?.parts??[]) {
      if (n&&o.text) {
        t.responseTexts.push(o.text);
      }

      if (o.functionCall) {
        t.toolCalls.push({type:"function",id:o.functionCall.id,name:o.functionCall.name,arguments:o.functionCall.args});
      }
    }
  }
}function b$(e,t,n,r){
  if (e && !N$(e,r)) {
    y$(e,t);
    O$(e,t,n);
  }
}async function*C$(e,t,n){const r={responseTexts:[],finishReasons:[],toolCalls:[]};try{for await (const o of e) {
  b$(o,r,n,t);
  yield o;
}}finally{
  const o={[Al]:true};

  if (r.responseId) {
    (o[Jo] = r.responseId);
  }

  if (r.responseModel) {
    (o[Rn] = r.responseModel);
  }

  if (r.promptTokens!==void 0) {
    (o[jt] = r.promptTokens);
  }

  if (r.completionTokens!==void 0) {
    (o[qt] = r.completionTokens);
  }

  if (r.totalTokens!==void 0) {
    (o[so] = r.totalTokens);
  }

  if (r.finishReasons.length) {
    (o[sr] = JSON.stringify(r.finishReasons));
  }

  if (n&&r.responseTexts.length) {
    (o[Wt] = r.responseTexts.join(""));
  }

  if (n&&r.toolCalls.length) {
    (o[On] = JSON.stringify(r.toolCalls));
  }

  t.setAttributes(o);
  t.end();
}}function I$(e){if (Gg.includes(e)) {
  return true;
}const t=e.split(".").pop();return Gg.includes(t)}function P$(e){return e.includes("Stream")||e.endsWith("generateContentStream")||e.endsWith("sendMessageStream")}function Vg(e,t){if ("model"in e&&typeof e.model=="string") {
  return e.model;
}if(t&&typeof t=="object"){const n=t;if ("model"in n&&typeof n.model=="string") {
  return n.model;
}if ("modelVersion"in n&&typeof n.modelVersion=="string") {
  return n.modelVersion
}}return"unknown"}function M$(e){
  const t={};

  if ("temperature"in e&&typeof e.temperature=="number") {
    (t[hl] = e.temperature);
  }

  if ("topP"in e&&typeof e.topP=="number") {
    (t[Sl] = e.topP);
  }

  if ("topK"in e&&typeof e.topK=="number") {
    (t[PP] = e.topK);
  }

  if ("maxOutputTokens"in e&&typeof e.maxOutputTokens=="number") {
    (t[LE] = e.maxOutputTokens);
  }

  if ("frequencyPenalty"in e&&typeof e.frequencyPenalty=="number") {
    (t[Tl] = e.frequencyPenalty);
  }

  if ("presencePenalty"in e&&typeof e.presencePenalty=="number") {
    (t[wE] = e.presencePenalty);
  }

  return t;
}function v$(e,t,n){const r={[El]:g$,[Fn]:yc(e),[Ge]:"auto.ai.google_genai"};if (t) {
  r[Nt]=Vg(t,n);

  if ("config"in t&&typeof t.config=="object"&&t.config) {
    const o=t.config;
    Object.assign(r,M$(o));

    if ("tools"in o&&Array.isArray(o.tools)) {const s=o.tools.flatMap(i => i.functionDeclarations);r[ml]=JSON.stringify(s)}
  }
} else {
  r[Nt]=Vg({},n);
}return r}function xg(e,t){if("contents"in t){
  const n=t.contents;
  const r=$n(n);
  e.setAttributes({[Gt]:r})
}if("message"in t){
  const n=t.message;
  const r=$n(n);
  e.setAttributes({[Gt]:r})
}if("history"in t){
  const n=t.history;
  const r=$n(n);
  e.setAttributes({[Gt]:r})
}}function L$(e,t,n){if(!(!t||typeof t!="object")){if(t.usageMetadata&&typeof t.usageMetadata=="object"){
  const r=t.usageMetadata;

  if (typeof r.promptTokenCount=="number") {
    e.setAttributes({[jt]:r.promptTokenCount});
  }

  if (typeof r.candidatesTokenCount=="number") {
    e.setAttributes({[qt]:r.candidatesTokenCount});
  }

  if (typeof r.totalTokenCount=="number") {
    e.setAttributes({[so]:r.totalTokenCount});
  }
}if(n&&Array.isArray(t.candidates)&&t.candidates.length>0){
  const r=t.candidates.map(o => o.content?.parts&&Array.isArray(o.content.parts)?o.content.parts.map(s => typeof s.text=="string"?s.text:"").filter(s => s.length>0).join(""):"").filter(o => o.length>0);

  if (r.length>0) {
    e.setAttributes({[Wt]:r.join("")});
  }
}if(n&&t.functionCalls){
  const r=t.functionCalls;

  if (Array.isArray(r)&&r.length>0) {
    e.setAttributes({[On]:JSON.stringify(r)});
  }
}}}function $g(e,t,n,r){const o=t===BP;return new Proxy(e,{apply(s,i,a){
  const c=a[0];
  const l=v$(t,c,n);
  const f=l[Nt]??"unknown";
  const d=yc(t);
  return P$(t)?xn({name:`${d} ${f} stream-response`,op:Ou(t),attributes:l},async u=>{try{
    if (r.recordInputs&&c) {
      xg(u,c);
    }

    const _=await s.apply(n,a);return C$(_,u,!!r.recordOutputs)
  }catch(_){
    u.setStatus({code:Ae,message:"internal_error"});
    xe(_,{mechanism:{handled:false,type:"auto.ai.google_genai",data:{function:t}}});
    u.end();
    throw _;
  }}):Qo({name:o?`${d} ${f} create`:`${d} ${f}`,op:Ou(t),attributes:l},u => {
    if (r.recordInputs&&c) {
      xg(u,c);
    }

    return oo(() => s.apply(n,a),_=>{xe(_,{mechanism:{handled:false,type:"auto.ai.google_genai",data:{function:t}}})},()=>{},_=>{
      if (!o) {
        L$(u,_,r.recordOutputs);
      }
    });
  });
}});}function Ap(e,t="",n){return new Proxy(e,{get:(r,o,s)=>{
  const i=Reflect.get(r,o,s);
  const a=wP(t,String(o));
  if(typeof i=="function"&&I$(a)){if(a===BP){const c=$g(i,a,r,n);return (...f) => {const d=c(...f);return d&&typeof d=="object"?Ap(d,R$,n):d};}return $g(i,a,r,n)}return typeof i=="function"?i.bind(r):i&&typeof i=="object"?Ap(i,a,n):i
}});}function w$(e,t){
  const n=!!he()?.getOptions().sendDefaultPii;
  const r={recordInputs:n,recordOutputs:n,...t};
  return Ap(e,"",r)
}
const HP="LangChain";
const Ba="auto.ai.langchain";
const D$={human:"user",ai:"assistant",assistant:"assistant",system:"system",function:"function",tool:"tool"};
const Gn=(e,t,n)=>{
  if (n!=null) {
    (e[t] = n);
  }
};
const Lt=(e,t,n)=>{
  const r=Number(n);

  if (!Number.isNaN(r)) {
    (e[t] = r);
  }
};
function Ct(e){if (typeof e=="string") {
  return e;
}try{return JSON.stringify(e)}catch{return String(e)}}function ra(e){const t=e.toLowerCase();return D$[t]??t}function Bg(e){return e.includes("System")?"system":e.includes("Human")?"user":e.includes("AI")||e.includes("Assistant")?"assistant":e.includes("Function")?"function":e.includes("Tool")?"tool":"user"}function Hg(e){if (!(!e||Array.isArray(e))) {
  return e.invocation_params
}}function $E(e){return e.map(t=>{const n=t._getType;if(typeof n=="function"){const o=n.call(t);return{role:ra(o),content:Ct(t.content)}}const r=t.constructor?.name;if (r) {
  return{role:ra(Bg(r)),content:Ct(t.content)};
}if(t.type){const o=String(t.type).toLowerCase();return{role:ra(o),content:Ct(t.content)}}if (t.role) {
  return{role:ra(String(t.role)),content:Ct(t.content)};
}if(t.lc===1&&t.kwargs){
  const o=t.id;
  const s=Array.isArray(o)&&o.length>0?o[o.length-1]:"";
  const i=typeof s=="string"?Bg(s):"user";
  return{role:ra(i),content:Ct(t.kwargs?.content)}
}return{role:"user",content:Ct(t.content)}});}function U$(e,t,n){
  const r={};
  const o="kwargs"in e?e.kwargs:void 0;
  const s=t?.temperature??n?.ls_temperature??o?.temperature;
  Lt(r,hl,s);const i=t?.max_tokens??n?.ls_max_tokens??o?.max_tokens;Lt(r,LE,i);const a=t?.top_p??o?.top_p;Lt(r,Sl,a);const c=t?.frequency_penalty;Lt(r,Tl,c);const l=t?.presence_penalty;
  Lt(r,wE,l);

  if (t&&"stream"in t) {
    Gn(r,vE,!!t.stream);
  }

  return r;
}function FP(e,t,n,r,o,s){return{[El]:Ct(e??"langchain"),[Fn]:n,[Nt]:Ct(t),[Ge]:Ba,...U$(r,o,s)}}function k$(e,t,n,r,o){
  const s=o?.ls_provider;
  const i=r?.model??o?.ls_model_name??"unknown";
  const a=FP(s,i,"pipeline",e,r,o);
  if(n&&Array.isArray(t)&&t.length>0){const c=t.map(l => ({
    role:"user",
    content:l
  }));Gn(a,Gt,Ct(c))}return a
}function G$(e,t,n,r,o){
  const s=o?.ls_provider??e.id?.[2];
  const i=r?.model??o?.ls_model_name??"unknown";
  const a=FP(s,i,"chat",e,r,o);
  if(n&&Array.isArray(t)&&t.length>0){
    const c=$E(t.flat());
    const l=kE(c);
    Gn(a,Gt,Ct(l))
  }return a
}function V$(e,t){
  const n=[];
  const r=e.flat();
  for(const o of r){const s=o.message?.content;if (Array.isArray(s)) {
    for(const i of s){
      const a=i;

      if (a.type==="tool_use") {
        n.push(a);
      }
    }
  }}

  if (n.length>0) {
    Gn(t,On,Ct(n));
  }
}function x$(e,t){
  if (!e) {
    return;
  }
  const n=e.tokenUsage;
  const r=e.usage;
  if (n) {
    Lt(t,jt,n.promptTokens);
    Lt(t,qt,n.completionTokens);
    Lt(t,so,n.totalTokens);
  } else if(r){
    Lt(t,jt,r.input_tokens);
    Lt(t,qt,r.output_tokens);
    const o=Number(r.input_tokens);
    const s=Number(r.output_tokens);
    const i=(Number.isNaN(o)?0:o)+(Number.isNaN(s)?0:s);

    if (i>0) {
      Lt(t,so,i);
    }

    if (r.cache_creation_input_tokens!==void 0) {
      Lt(t,zV,r.cache_creation_input_tokens);
    }

    if (r.cache_read_input_tokens!==void 0) {
      Lt(t,ZV,r.cache_read_input_tokens);
    }
  }
}function $$(e,t){
  if (!e) {
    return;
  }const n={};if(Array.isArray(e.generations)){
    const l=e.generations.flat().map(f => f.generationInfo?.finish_reason?f.generationInfo.finish_reason:f.generation_info?.finish_reason?f.generation_info.finish_reason:null).filter(f => typeof f=="string");

    if (l.length>0) {
      Gn(n,sr,Ct(l));
    }

    V$(e.generations,n);

    if (t) {
      const f=e.generations.flat().map(d => d.text??d.message?.content).filter(d => typeof d=="string");

      if (f.length>0) {
        Gn(n,Wt,Ct(f));
      }
    }
  }x$(e.llmOutput,n);
  const r=e.llmOutput;
  const s=e.generations?.[0]?.[0]?.message;
  const i=r?.model_name??r?.model??s?.response_metadata?.model_name;

  if (i) {
    Gn(n,Rn,i);
  }

  const a=r?.id??s?.id;

  if (a) {
    Gn(n,Jo,a);
  }

  const c=r?.stop_reason??s?.response_metadata?.finish_reason;

  if (c) {
    Gn(n,WV,Ct(c));
  }

  return n;
}function B$(e={}){
  const t=e.recordInputs??false;
  const n=e.recordOutputs??false;
  const r=new Map;
  const o=i=>{
    const a=r.get(i);

    if (a?.isRecording()) {
      a.end();
      r.delete(i);
    }
  };

  const s={lc_serializable:false,lc_namespace:["langchain_core","callbacks","sentry"],lc_secrets:void 0,lc_attributes:void 0,lc_aliases:void 0,lc_serializable_keys:void 0,lc_id:["langchain_core","callbacks","sentry"],lc_kwargs:{},name:"SentryCallbackHandler",ignoreLLM:false,ignoreChain:false,ignoreAgent:false,ignoreRetriever:false,ignoreCustomEvent:false,raiseError:false,awaitHandlers:true,handleLLMStart(i,a,c,l,f,d,u,_){
    const p=Hg(d);
    const E=k$(i,a,t,p,u);
    const h=E[Nt];
    const T=E[Fn];
    xn({name:`${T} ${h}`,op:"gen_ai.pipeline",attributes:{...E,[Ee]:"gen_ai.pipeline"}},m => {
      r.set(c,m);
      return m;
    })
  },handleChatModelStart(i,a,c,l,f,d,u,_){
    const p=Hg(d);
    const E=G$(i,a,t,p,u);
    const h=E[Nt];
    const T=E[Fn];
    xn({name:`${T} ${h}`,op:"gen_ai.chat",attributes:{...E,[Ee]:"gen_ai.chat"}},m => {
      r.set(c,m);
      return m;
    })
  },handleLLMEnd(i,a,c,l,f){const d=r.get(a);if(d?.isRecording()){
    const u=$$(i,n);

    if (u) {
      d.setAttributes(u);
    }

    o(a);
  }},handleLLMError(i,a){
    const c=r.get(a);

    if (c?.isRecording()) {
      c.setStatus({code:Ae,message:"llm_error"});
      o(a);
    }

    xe(i,{mechanism:{handled:false,type:`${Ba}.llm_error_handler`}});
  },handleChainStart(i,a,c,l){
    const f=i.name||"unknown_chain";
    const d={[Ge]:"auto.ai.langchain","langchain.chain.name":f};

    if (t) {
      (d["langchain.chain.inputs"] = JSON.stringify(a));
    }

    xn({name:`chain ${f}`,op:"gen_ai.invoke_agent",attributes:{...d,[Ee]:"gen_ai.invoke_agent"}},u => {
      r.set(c,u);
      return u;
    });
  },handleChainEnd(i,a){
    const c=r.get(a);

    if (c?.isRecording()) {
      n&&c.setAttributes({"langchain.chain.outputs":JSON.stringify(i)});
      o(a);
    }
  },handleChainError(i,a){
    const c=r.get(a);

    if (c?.isRecording()) {
      c.setStatus({code:Ae,message:"chain_error"});
      o(a);
    }

    xe(i,{mechanism:{handled:false,type:`${Ba}.chain_error_handler`}});
  },handleToolStart(i,a,c,l){
    const f=i.name||"unknown_tool";
    const d={[Ge]:Ba,"gen_ai.tool.name":f};

    if (t) {
      (d["gen_ai.tool.input"] = a);
    }

    xn({name:`execute_tool ${f}`,op:"gen_ai.execute_tool",attributes:{...d,[Ee]:"gen_ai.execute_tool"}},u => {
      r.set(c,u);
      return u;
    });
  },handleToolEnd(i,a){
    const c=r.get(a);

    if (c?.isRecording()) {
      n&&c.setAttributes({"gen_ai.tool.output":JSON.stringify(i)});
      o(a);
    }
  },handleToolError(i,a){
    const c=r.get(a);

    if (c?.isRecording()) {
      c.setStatus({code:Ae,message:"tool_error"});
      o(a);
    }

    xe(i,{mechanism:{handled:false,type:`${Ba}.tool_error_handler`}});
  },copy(){return s},toJSON(){return{lc:1,type:"not_implemented",id:s.lc_id}},toJSONNotImplemented(){return{lc:1,type:"not_implemented",id:s.lc_id}}};

  return s
}
const YP="LangGraph";
const jP="auto.ai.langgraph";
function H$(e){if (!e||e.length===0) {
  return null;
}const t=[];for (const n of e) {
  if(n&&typeof n=="object"){
    const r=n.tool_calls;

    if (r&&Array.isArray(r)) {
      t.push(...r);
    }
  }
}return t.length>0?t:null}function F$(e){
  const t=e;
  let n=0;
  let r=0;
  let o=0;
  if(t.usage_metadata&&typeof t.usage_metadata=="object"){
    const s=t.usage_metadata;

    if (typeof s.input_tokens=="number") {
      (n = s.input_tokens);
    }

    if (typeof s.output_tokens=="number") {
      (r = s.output_tokens);
    }

    if (typeof s.total_tokens=="number") {
      (o = s.total_tokens);
    }

    return {inputTokens:n,outputTokens:r,totalTokens:o};
  }if(t.response_metadata&&typeof t.response_metadata=="object"){const s=t.response_metadata;if(s.tokenUsage&&typeof s.tokenUsage=="object"){
  const i=s.tokenUsage;

  if (typeof i.promptTokens=="number") {
    (n = i.promptTokens);
  }

  if (typeof i.completionTokens=="number") {
    (r = i.completionTokens);
  }

  if (typeof i.totalTokens=="number") {
    (o = i.totalTokens);
  }
}}return{inputTokens:n,outputTokens:r,totalTokens:o}
}function Y$(e,t){const n=t;if(n.response_metadata&&typeof n.response_metadata=="object"){
  const r=n.response_metadata;

  if (r.model_name&&typeof r.model_name=="string") {
    e.setAttribute(Rn,r.model_name);
  }

  if (r.finish_reason&&typeof r.finish_reason=="string") {
    e.setAttribute(sr,[r.finish_reason]);
  }
}}function j$(e){if (!e.builder?.nodes?.tools?.runnable?.tools) {
  return null;
}const t=e.builder?.nodes?.tools?.runnable?.tools;return !t||!Array.isArray(t)||t.length===0?null:t.map(n => ({
  name:n.lc_kwargs?.name,
  description:n.lc_kwargs?.description,
  schema:n.lc_kwargs?.schema
}));}function q$(e,t,n){
  const o=n?.messages;if (!o||!Array.isArray(o)) {
      return;
    }
  const s=t?.length??0;
  const i=o.length>s?o.slice(s):[];
  if (i.length===0) {
    return;
  }const a=H$(i);

  if (a) {
    e.setAttribute(On,JSON.stringify(a));
  }

  const c=$E(i);e.setAttribute(Wt,JSON.stringify(c));
  let l=0;
  let f=0;
  let d=0;
  for(const u of i){
    const _=F$(u);
    l+=_.inputTokens;
    f+=_.outputTokens;
    d+=_.totalTokens;
    Y$(e,u);
  }

  if (l>0) {
    e.setAttribute(jt,l);
  }

  if (f>0) {
    e.setAttribute(qt,f);
  }

  if (d>0) {
    e.setAttribute(so,d);
  }
}function W$(e,t){return new Proxy(e,{apply(n,r,o){return Qo({op:"gen_ai.create_agent",name:"create_agent",attributes:{[Ge]:jP,[Ee]:"gen_ai.create_agent",[Fn]:"create_agent"}},s=>{try{
  const i=Reflect.apply(n,r,o);
  const a=o.length>0?o[0]:{};

  if (a?.name&&typeof a.name=="string") {
    s.setAttribute(MP,a.name);
    s.updateName(`create_agent ${a.name}`);
  }

  const c=i.invoke;

  if (c&&typeof c=="function") {
    (i.invoke = K$(c.bind(i),i,a,t));
  }

  return i;
}catch(i){
  s.setStatus({code:Ae,message:"internal_error"});
  xe(i,{mechanism:{handled:false,type:"auto.ai.langgraph.error"}});
  throw i;
}});}});}function K$(e,t,n,r){return new Proxy(e,{apply(o,s,i){return Qo({op:"gen_ai.invoke_agent",name:"invoke_agent",attributes:{[Ge]:jP,[Ee]:XV,[Fn]:"invoke_agent"}},async a=>{try{
  const c=n?.name;

  if (c&&typeof c=="string") {
    a.setAttribute(KV,c);
    a.setAttribute(MP,c);
    a.updateName(`invoke_agent ${c}`);
  }

  const l=j$(t);

  if (l) {
    a.setAttribute(ml,JSON.stringify(l));
  }

  const f=r.recordInputs;
  const d=r.recordOutputs;
  const u=i.length>0?i[0].messages??[]:[];
  if(u&&f){
    const p=$E(u);
    const E=kE(p);
    a.setAttribute(Gt,JSON.stringify(E))
  }const _=await Reflect.apply(o,s,i);

  if (d) {
    q$(a,u??null,_);
  }

  return _;
}catch(c){
  a.setStatus({code:Ae,message:"internal_error"});
  xe(c,{mechanism:{handled:false,type:"auto.ai.langgraph.error"}});
  throw c;
}});}});}function qP(e){if (e!==void 0) {
  return e>=400&&e<500?"warning":e>=500?"error":void 0
}}function z$(e,t,n){const r=e[t];if(typeof r=="function"){try{e[t]=n}catch{Object.defineProperty(e,t,{value:n,writable:true,configurable:true,enumerable:true})}if (e.default===r) {
  try{e.default=n}catch{Object.defineProperty(e,"default",{value:n,writable:true,configurable:true,enumerable:true})}
}}}function Z$(e,t=false){return !(t||e&&!e.startsWith("/")&&!e.match(/^[A-Z]:/)&&!e.startsWith(".")&&!e.match(/^[a-zA-Z]([a-zA-Z0-9.\-+])*:\/\//))&&e!==void 0&&!e.includes("node_modules/");}function X$(e){
  const t=/^\s*[-]{4,}$/;
  const n=/at (?:async )?(?:(.+?)\s+\()?(?:(.+):(\d+):(\d+)?|([^)]+))\)?/;
  const r=/at (?:async )?(.+?) \(data:(.*?),/;
  return o=>{const s=o.match(r);if (s) {
    return{filename:`<data:${s[2]}>`,function:s[1]};
  }const i=o.match(n);if(i){
    let a;
    let c;
    let l;
    let f;
    let d;
    if(i[1]){
      l=i[1];let p=l.lastIndexOf(".");

      if (l[p-1]===".") {
        p--;
      }

      if (p>0) {
        a=l.slice(0,p);
        c=l.slice(p+1);
        const E=a.indexOf(".Module");

        if (E>0) {
          l=l.slice(E+1);
          a=a.slice(0,E);
        }
      }

      f=void 0
    }

    if (c) {
      f=a;
      d=c;
    }

    if (c==="<anonymous>") {
      d=void 0;
      l=void 0;
    }

    if (l===void 0) {
      d=d||LI;
      l=f?`${f}.${d}`:d;
    }

    let u=i[2]?.startsWith("file://")?i[2].slice(7):i[2];const _=i[5]==="native";

    if (u?.match(/\/[A-Z]:/)) {
      (u = u.slice(1));
    }

    if (!u&&i[5]&&!_) {
      (u = i[5]);
    }

    return {filename:u?decodeURI(u):void 0,module:e?e(u):void 0,function:l,lineno:Fg(i[3]),colno:Fg(i[4]),in_app:Z$(u||"",_)};
  }if (o.match(t)) {
    return{filename:o}
  }};
}function Q$(e){return[90,X$(e)]}function Fg(e){return parseInt(e||"",10)||void 0}class es{constructor(t){
  this._maxSize=t;
  this._cache=new Map;
}get size(){return this._cache.size}get(t){const n=this._cache.get(t);if (n!==void 0) {
  this._cache.delete(t);
  this._cache.set(t,n);
  return n;
}}set(t,n){if(this._cache.size>=this._maxSize){const r=this._cache.keys().next().value;this._cache.delete(r)}this._cache.set(t,n)}remove(t){
  const n=this._cache.get(t);

  if (n) {
    this._cache.delete(t);
  }

  return n;
}clear(){this._cache.clear()}keys(){return Array.from(this._cache.keys())}values(){
  const t=[];

  this._cache.forEach(n => t.push(n));

  return t;
}}const bu={};function Ne(e,t,n){return n?eB(e,t,n):J$(e,t)}function J$(e,t){return Object.assign(n=>{
  const r=bu[e];if (r) {
  if (n) {
    r.setConfig(n);
  }

  return r;
}const o=t(n);
  bu[e]=o;
  rl({instrumentations:[o]});
  return o;
},{id:e});}function eB(e,t,n){return Object.assign(r=>{
  const o=n(r);
  const s=bu[e];
  if (s) {
    s.setConfig(o);
    return s;
  }const i=new t(o);
  bu[e]=i;
  rl({instrumentations:[i]});
  return i;
},{id:e});}function WP(e){
  let t=false;
  let n=[];
  if (!tB(e)) {
    t=true;
  } else {const o=e._wrap;e._wrap=(...s) => {
    t=true;

    n.forEach(i => i());

    n=[];
    return o(...s);
  }}return o=>{
  if (t) {
    o();
  } else {
    n.push(o);
  }
};
}function tB(e){return typeof e._wrap=="function"}
const Ie=typeof __SENTRY_DEBUG__ === "undefined"||__SENTRY_DEBUG__;
const Oo="@sentry/instrumentation-http";
const nB=1024*1024;
const Yg=C.createContextKey("sentry_http_server_instrumented");
const Zn="Http.Server";
const bd=new Map;
const jg=new WeakSet;
function rB(e,t){cn(e,"_startSpanCallback",new WeakRef(t))}
const oB=((e={})=>{const t={sessions:e.sessions??true,sessionFlushingDelayMS:e.sessionFlushingDelayMS??60000/* 6e4 */,maxRequestBodySize:e.maxRequestBodySize??"medium",ignoreRequestBody:e.ignoreRequestBody};return {name:Zn,setupOnce(){const n=(r=>{sB(r.server,t)});Sn.subscribe("http.server.request.start",n)},afterAllSetup(n){
  if (Ie&&n.getIntegrationByName("Http")) {
    x.warn("It seems that you have manually added `httpServerIntegration` while `httpIntegration` is also present. Make sure to remove `httpServerIntegration` when adding `httpIntegration`.");
  }
}};});
const KP=oB;
function sB(e,{ignoreRequestBody,maxRequestBodySize,sessions,sessionFlushingDelayMS}){
  const s=e.emit;if (jg.has(s)) {
    return;
  }const i=new Proxy(s,{apply(a,c,l){
  if (l[0]!=="request") {
    return a.apply(c,l);
  }const f=he();if (C.context.active().getValue(Yg)||!f) {
        return a.apply(c,l);
      }

  if (Ie) {
    x.log(Zn,"Handling incoming request");
  }

  const d=je().clone();
  const u=l[1];
  const _=l[2];
  const p=KG(u);
  const E=u.ip||u.socket?.remoteAddress;
  const h=u.url||"/";

  if (maxRequestBodySize!=="none"&&!ignoreRequestBody?.(h,u)) {
    aB(u,d,maxRequestBodySize);
  }

  d.setSDKProcessingMetadata({normalizedRequest:p,ipAddress:E});
  const T=(u.method||"GET").toUpperCase();
  const m=ac(h);
  const A=`${T} ${m}`;
  d.setTransactionName(A);

  if (sessions&&f) {
    iB(f,{requestIsolationScope:d,response:_,sessionFlushingDelayMS:sessionFlushingDelayMS??60000/* 6e4 */});
  }

  return wk(d,()=>{Ke().getPropagationContext().propagationSpanId=lo();const g=C.propagation.extract(C.context.active(),p.headers).setValue(Yg,true);return C.context.with(g,()=>{f.emit("httpServerRequest",u,_,p);const R=u._startSpanCallback?.deref();return R?R(() => a.apply(c,l)):a.apply(c,l);});});
}});
  jg.add(i);
  e.emit=i;
}function iB(e,{requestIsolationScope,response,sessionFlushingDelayMS}){
  requestIsolationScope.setSDKProcessingMetadata({requestSession:{status:"ok"}});

  response.once("close",()=>{const o=requestIsolationScope.getScopeData().sdkProcessingMetadata.requestSession;if(e&&o){
    if (Ie) {
      x.log(`Recorded request session with status: ${o.status}`);
    }

    const s=new Date;s.setSeconds(0,0);
    const i=s.toISOString();
    const a=bd.get(e);
    const c=a?.[i]||{exited:0,crashed:0,errored:0};
    c[{ok:"exited",crashed:"crashed",errored:"errored"}[o.status]]++;

    if (a) {
      a[i]=c;
    } else {
      if (Ie) {
        x.log("Opened new request session aggregate.");
      }

      const l={[i]:c};bd.set(e,l);

      const f=()=>{
        clearTimeout(u);
        d();
        bd.delete(e);
        const _=Object.entries(l).map(([p,E]) => ({
          started:p,
          exited:E.exited,
          errored:E.errored,
          crashed:E.crashed
        }));e.sendSession({aggregates:_})
      };

      const d=e.on("flush",()=>{
        if (Ie) {
          x.log("Sending request session aggregate due to client flush");
        }

        f();
      });

      const u=setTimeout(()=>{
        if (Ie) {
          x.log("Sending request session aggregate due to flushing schedule");
        }

        f();
      },sessionFlushingDelayMS).unref();
    }
  }});
}function aB(e,t,n){
  let r=0;const o=[];

  if (Ie) {
    x.log(Zn,"Patching request.on");
  }

  const s=new WeakMap;
  const i=n==="small"?1000/* 1e3 */:n==="medium"?10000/* 1e4 */:nB;
  try{
    e.on=new Proxy(e.on,{apply:(a,c,l)=>{const[f,d,...u]=l;if(f==="data"){
      if (Ie) {
        x.log(Zn,`Handling request.on("data") with maximum body size of ${i}b`);
      }

      const _=new Proxy(d,{apply:(p,E,h)=>{try{
        const T=h[0];
        const m=Buffer.from(T);

        if (r<i) {
          o.push(m);
          r+=m.byteLength;
        } else if (Ie) {
          x.log(Zn,`Dropping request body chunk because maximum body length of ${i}b is exceeded.`);
        }
      }catch{
        if (Ie) {
          x.error(Zn,"Encountered error while storing body chunk.");
        }
      }return Reflect.apply(p,E,h)}});
      s.set(d,_);
      return Reflect.apply(a,c,[f,_,...u]);
    }return Reflect.apply(a,c,l)}});

    e.off=new Proxy(e.off,{apply:(a,c,l)=>{
      const [,f]=l;
      const d=s.get(f);
      if(d){
        s.delete(f);const u=l.slice();
        u[1]=d;
        return Reflect.apply(a,c,u);
      }return Reflect.apply(a,c,l)
    }});

    e.on("end",()=>{try{const a=Buffer.concat(o).toString("utf-8");if(a){const l=Buffer.byteLength(a,"utf-8")>i?`${Buffer.from(a).subarray(0,i-3).toString("utf-8")}...`:a;t.setSDKProcessingMetadata({normalizedRequest:{data:l}})}}catch(a){
      if (Ie) {
        x.error(Zn,"Error building captured request body",a);
      }
    }});
  }catch(a){
    if (Ie) {
      x.error(Zn,"Error patching request to capture body",a);
    }
  }
}
const qg="Http.ServerSpans";

const cB=((e={})=>{
  const t=e.ignoreStaticAssets??true;
  const n=e.ignoreIncomingRequests;
  const r=e.ignoreStatusCodes??[[401,404],[301,303],[305,399]];
  const {onSpanCreated}=e;
  const {requestHook,responseHook,applyCustomAttributesOnSpan}=e.instrumentation??{};
  return {name:qg,setup(c){
    if (typeof __SENTRY_TRACING__ === "undefined" || __SENTRY_TRACING__) {
      c.on("httpServerRequest",(l,f,d)=>{
        const u=l;
        const _=f;
        rB(u,E=>{
          if (dB(u,{ignoreStaticAssets:t,ignoreIncomingRequests:n})) {
            if (Ie) {
              x.log(qg,"Skipping span creation for incoming request",u.url);
            }

            return E();
          }
          const h=d.url||u.url||"/";
          const T=FG(h);
          const m=u.headers;
          const A=m["user-agent"];
          const g=m["x-forwarded-for"];
          const R=u.httpVersion;
          const O=m.host;
          const I=O?.replace(/^(.*)(:[0-9]{1,5})/,"$1")||"localhost";
          const b=c.tracer;
          const L=h.startsWith("https")?"https":"http";
          const U=d.method||u.method?.toUpperCase()||"GET";
          const q=T?T.pathname:ac(h);
          const H=`${U} ${q}`;
          const $=b.startSpan(H,{kind:C.SpanKind.SERVER,attributes:{[Ee]:"http.server",[Ge]:"auto.http.otel.http","sentry.http.prefetch":uB(u)||void 0,"http.url":h,"http.method":d.method,"http.target":T?`${T.pathname}${T.search}`:q,"http.host":O,"net.host.name":I,"http.client_ip":typeof g=="string"?g.split(",")[0]:void 0,"http.user_agent":A,"http.scheme":L,"http.flavor":R,"net.transport":R?.toUpperCase()==="QUIC"?"ip_udp":"ip_tcp",...fB(u),...XG(d.headers||{})}});
          requestHook?.($,u);
          responseHook?.($,_);
          applyCustomAttributesOnSpan?.($,u,_);
          onSpanCreated?.($,u,_);
          const B={type:Jr.HTTP,span:$};return C.context.with(uI(C.trace.setSpan(C.context.active(),$),B),()=>{
            C.context.bind(C.context.active(),u);
            C.context.bind(C.context.active(),_);
            let F=false;function D(k){
          if (F) {
            return;
          }F=true;const Y=EB(u,_);
          $.setAttributes(Y);
          $.setStatus(k);
          $.end();
          const oe=Y["http.route"];

          if (oe) {
            je().setTransactionName(`${u.method?.toUpperCase()||"GET"} ${oe}`);
          }
        }
            _.on("close",()=>{D(lp(_.statusCode))});
            _.on(vw.errorMonitor,()=>{const k=lp(_.statusCode);D(k.code===Ae?k:{code:Ae})});
            return E();
          });
        })
      });
    }
  },processEvent(c){if(c.type==="transaction"){const l=c.contexts?.trace?.data?.["http.response.status_code"];if (typeof l=="number"&&hB(l,r)) {
    if (Ie) {
      x.log("Dropping transaction due to status code",l);
    }

    return null;
  }}return c},afterAllSetup(c){
    if (Ie) {
      c.getIntegrationByName("Http")&&x.warn("It seems that you have manually added `httpServerSpansIntergation` while `httpIntegration` is also present. Make sure to remove `httpIntegration` when adding `httpServerSpansIntegration`.");
      c.getIntegrationByName("Http.Server")||x.error("It seems that you have manually added `httpServerSpansIntergation` without adding `httpServerIntegration`. This is a requiement for spans to be created - please add the `httpServerIntegration` integration.");
    }
  }};
});

const zP=cB;
function uB(e){return e.headers["next-router-prefetch"]==="1"}function lB(e){const t=ac(e);return !!(t.match(/\.(ico|png|jpg|jpeg|gif|svg|css|js|woff|woff2|ttf|eot|webp|avif)$/)||t.match(/^\/(robots\.txt|sitemap\.xml|manifest\.json|browserconfig\.xml)$/));}function dB(e,{ignoreStaticAssets,ignoreIncomingRequests}){
  if (yn(C.context.active())) {
    return true;
  }
  const r=e.url;
  const o=e.method?.toUpperCase();
  return !!(o==="OPTIONS"||o==="HEAD"||!r||ignoreStaticAssets&&o==="GET"&&lB(r)||ignoreIncomingRequests?.(r,e));
}function fB(e){
  const t=_B(e.headers);

  if (t==null) {
    return {};
  }

  if (pB(e.headers)) {
    return {"http.request_content_length":t};
  }

  return {"http.request_content_length_uncompressed":t};
}function _B(e){const t=e["content-length"];if (t===void 0) {
  return null;
}const n=parseInt(t,10);return isNaN(n)?null:n}function pB(e){const t=e["content-encoding"];return!!t&&t!=="identity"}function EB(e,t){
  const {socket}=e;
  const {statusCode,statusMessage}=t;
  const s={[Q.ATTR_HTTP_RESPONSE_STATUS_CODE]:statusCode,[Q.SEMATTRS_HTTP_STATUS_CODE]:statusCode,"http.status_text":statusMessage?.toUpperCase()};
  const i=tl(C.context.active());
  if(socket){
    const{localAddress,localPort,remoteAddress,remotePort}=socket;
    s[Q.SEMATTRS_NET_HOST_IP]=localAddress;
    s[Q.SEMATTRS_NET_HOST_PORT]=localPort;
    s[Q.SEMATTRS_NET_PEER_IP]=remoteAddress;
    s["net.peer.port"]=remotePort;
  }
  s[Q.SEMATTRS_HTTP_STATUS_CODE]=statusCode;
  s["http.status_text"]=(statusMessage||"").toUpperCase();

  if (i?.type===Jr.HTTP&&i.route!==void 0)
    {const a=i.route;s[Q.ATTR_HTTP_ROUTE]=a}

  return s
}function hB(e,t){return t.some(n=>{if (typeof n=="number") {
  return n===e;
}const[r,o]=n;return e>=r&&e<=o});}function ZP(e){
  const t=e.protocol||"";
  const n=e.hostname||e.host||"";
  const r=!e.port||e.port===80||e.port===443||/^(.*):(\d+)$/.test(n)?"":`:${e.port}`;
  const o=e.path?e.path:"/";
  return`${t}//${n}${r}${o}`
}function TB(){return`unknown_service:${process.argv0}`}const Ha=e => e!==null&&typeof e=="object"&&typeof e.then=="function";class Cu{_rawAttributes;_asyncAttributesPending=false;_schemaUrl;_memoizedAttributes;static FromAttributeList(t,n){
  const r=new Cu({},n);
  r._rawAttributes=Wg(t);

  r._asyncAttributesPending=t.filter(([o,s]) => Ha(s)).length>0;

  return r;
}constructor(t,n){
  const r=t.attributes??{};

  this._rawAttributes=Object.entries(r).map(([o,s]) => {
    if (Ha(s)) {
      (this._asyncAttributesPending = true);
    }

    return [o,s];
  });

  this._rawAttributes=Wg(this._rawAttributes);
  this._schemaUrl=SB(n?.schemaUrl);
}get asyncAttributesPending(){return this._asyncAttributesPending}async waitForAsyncAttributes(){if(this.asyncAttributesPending){for(let t=0;t<this._rawAttributes.length;t++){const[n,r]=this._rawAttributes[t];this._rawAttributes[t]=[n,Ha(r)?await r:r]}this._asyncAttributesPending=false}}get attributes(){
  if (this.asyncAttributesPending) {
    C.diag.error("Accessing resource attributes before async attributes settled");
  }

  if (this._memoizedAttributes) {
    return this._memoizedAttributes;
  }

  const t={};for(const[n,r]of this._rawAttributes){
    if(Ha(r)){C.diag.debug(`Unsettled resource attribute ${n} skipped`);continue}

    if (r!=null) {
      (t[n] ??= r);
    }
  }

  if (!this._asyncAttributesPending) {
    (this._memoizedAttributes = t);
  }

  return t;
}getRawAttributes(){return this._rawAttributes}get schemaUrl(){return this._schemaUrl}merge(t){
  if (t==null) {
    return this;
  }
  const n=mB(this,t);
  const r=n?{schemaUrl:n}:void 0;
  return Cu.FromAttributeList([...t.getRawAttributes(),...this.getRawAttributes()],r)
}}function XP(e,t){return Cu.FromAttributeList(Object.entries(e),t)}function QP(){return XP({[Q.ATTR_SERVICE_NAME]:TB(),[Q.ATTR_TELEMETRY_SDK_LANGUAGE]:Xc[Q.ATTR_TELEMETRY_SDK_LANGUAGE],[Q.ATTR_TELEMETRY_SDK_NAME]:Xc[Q.ATTR_TELEMETRY_SDK_NAME],[Q.ATTR_TELEMETRY_SDK_VERSION]:Xc[Q.ATTR_TELEMETRY_SDK_VERSION]})}function Wg(e){return e.map(([t,n]) => Ha(n)?[t,n.catch(r=>{C.diag.debug("promise rejection for resource attribute: %s - %s",t,r)})]:[t,n]);}function SB(e){if (typeof e=="string"||e===void 0) {
  return e;
}C.diag.warn("Schema URL must be string or undefined, got %s. Schema URL will be ignored.",e)}function mB(e,t){
  const n=e?.schemaUrl;
  const r=t?.schemaUrl;
  const o=n===void 0||n==="";
  const s=r===void 0||r==="";
  if (o) {
    return r;
  }if (s||n===r) {
    return n;
  }C.diag.warn('Schema URL merge conflict: old resource has "%s", updating resource has "%s". Resulting resource will have undefined Schema URL.',n,r)
}const AB="exception";class gB{_spanContext;kind;parentSpanContext;attributes={};links=[];events=[];startTime;resource;instrumentationScope;_droppedAttributesCount=0;_droppedEventsCount=0;_droppedLinksCount=0;name;status={code:C.SpanStatusCode.UNSET};endTime=[0,0];_ended=false;_duration=[-1,-1];_spanProcessor;_spanLimits;_attributeValueLengthLimit;_performanceStartTime;_performanceOffset;_startTimeProvided;constructor(t){
  const n=Date.now();
  this._spanContext=t.spanContext;
  this._performanceStartTime=zr.now();
  this._performanceOffset=n-(this._performanceStartTime+Ju());
  this._startTimeProvided=t.startTime!=null;
  this._spanLimits=t.spanLimits;
  this._attributeValueLengthLimit=this._spanLimits.attributeValueLengthLimit||0;
  this._spanProcessor=t.spanProcessor;
  this.name=t.name;
  this.parentSpanContext=t.parentSpanContext;
  this.kind=t.kind;
  this.links=t.links||[];
  this.startTime=this._getTime(t.startTime??n);
  this.resource=t.resource;
  this.instrumentationScope=t.scope;

  if (t.attributes!=null) {
    this.setAttributes(t.attributes);
  }

  this._spanProcessor.onStart(this,t.context);
}spanContext(){return this._spanContext}setAttribute(t,n){if (n==null||this._isSpanEnded()) {
  return this;
}if (t.length===0) {
  C.diag.warn(`Invalid attribute key: ${t}`);
  return this;
}if (!tE(n)) {
  C.diag.warn(`Invalid attribute value set for key: ${t}`);
  return this;
}const{attributeCountLimit}=this._spanLimits;return attributeCountLimit!==void 0&&Object.keys(this.attributes).length>=attributeCountLimit&&!Object.prototype.hasOwnProperty.call(this.attributes,t)?(this._droppedAttributesCount++,this):(this.attributes[t]=this._truncateToSize(n),this);}setAttributes(t){for (const[n,r] of Object.entries(t)) {
  this.setAttribute(n,r);
}return this}addEvent(t,n,r){
  if (this._isSpanEnded()) {
    return this;
  }const{eventCountLimit}=this._spanLimits;if (eventCountLimit===0) {
      C.diag.warn("No events allowed.");
      this._droppedEventsCount++;
      return this;
    }

  if (eventCountLimit!==void 0&&this.events.length>=eventCountLimit) {
    this._droppedEventsCount===0&&C.diag.debug("Dropping extra events.");
    this.events.shift();
    this._droppedEventsCount++;
  }

  if (sp(n)) {
    sp(r)||(r=n);
    n=void 0;
  }

  const s=Wa(n);
  this.events.push({name:t,attributes:s,time:this._getTime(r),droppedAttributesCount:0});
  return this;
}addLink(t){
  this.links.push(t);
  return this;
}addLinks(t){
  this.links.push(...t);
  return this;
}setStatus(t){return this._isSpanEnded()?this:(this.status={...t},this.status.message!=null&&typeof t.message!="string"&&(C.diag.warn(`Dropping invalid status.message of type '${typeof t.message}', expected 'string'`),delete this.status.message),this)}updateName(t){return this._isSpanEnded()?this:(this.name=t,this)}end(t){
  if(this._isSpanEnded()){C.diag.error(`${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`);return}
  this._ended=true;
  this.endTime=this._getTime(t);
  this._duration=aI(this.startTime,this.endTime);

  if (this._duration[0]<0) {
    C.diag.warn("Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.",this.startTime,this.endTime);
    this.endTime=this.startTime.slice();
    this._duration=[0,0];
  }

  if (this._droppedEventsCount>0) {
    C.diag.warn(`Dropped ${this._droppedEventsCount} events because eventCountLimit reached`);
  }

  this._spanProcessor.onEnd(this);
}_getTime(t){if (typeof t=="number"&&t<=zr.now()) {
  return oE(t+this._performanceOffset);
}if (typeof t=="number") {
  return Vn(t);
}if (t instanceof Date) {
  return Vn(t.getTime());
}if (el(t)) {
  return t;
}if (this._startTimeProvided) {
  return Vn(Date.now());
}const n=zr.now()-this._performanceStartTime;return sE(this.startTime,Vn(n))}isRecording(){return this._ended===false;}recordException(t,n){
  const r={};

  if (typeof t=="string") {
    r[Q.ATTR_EXCEPTION_MESSAGE]=t;
  } else if (t) {
    t.code?r[Q.ATTR_EXCEPTION_TYPE]=t.code.toString():t.name&&(r[Q.ATTR_EXCEPTION_TYPE]=t.name);
    t.message&&(r[Q.ATTR_EXCEPTION_MESSAGE]=t.message);
    t.stack&&(r[Q.ATTR_EXCEPTION_STACKTRACE]=t.stack);
  }

  if (r[Q.ATTR_EXCEPTION_TYPE]||r[Q.ATTR_EXCEPTION_MESSAGE]) {
    this.addEvent(AB,r,n);
  } else {
    C.diag.warn(`Failed to record an exception ${t}`);
  }
}get duration(){return this._duration}get ended(){return this._ended}get droppedAttributesCount(){return this._droppedAttributesCount}get droppedEventsCount(){return this._droppedEventsCount}get droppedLinksCount(){return this._droppedLinksCount}_isSpanEnded(){if(this._ended){const t=new Error(`Operation attempted on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`);C.diag.warn(`Cannot execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`,t)}return this._ended}_truncateToLimitUtil(t,n){return t.length<=n?t:t.substring(0,n)}_truncateToSize(t){const n=this._attributeValueLengthLimit;return n<=0?(C.diag.warn(`Attribute value limit must be positive, got ${n}`),t):typeof t=="string"?this._truncateToLimitUtil(t,n):Array.isArray(t)?t.map(r => typeof r=="string"?this._truncateToLimitUtil(r,n):r):t;}}const Dt = {
  NOT_RECORD: 0,
  RECORD: 1,
  RECORD_AND_SAMPLED: 2,

  // reverse mapping
  0: "NOT_RECORD",

  1: "RECORD",
  2: "RECORD_AND_SAMPLED"
};class Iu{shouldSample(){return{decision:Dt.NOT_RECORD}}toString(){return"AlwaysOffSampler"}}class wo{shouldSample(){return{decision:Dt.RECORD_AND_SAMPLED}}toString(){return"AlwaysOnSampler"}}class wc{_root;_remoteParentSampled;_remoteParentNotSampled;_localParentSampled;_localParentNotSampled;constructor(t){
  this._root=t.root;

  if (!this._root) {
    nE(new Error("ParentBasedSampler must have a root sampler configured"));
    this._root=new wo;
  }

  this._remoteParentSampled=t.remoteParentSampled??new wo;
  this._remoteParentNotSampled=t.remoteParentNotSampled??new Iu;
  this._localParentSampled=t.localParentSampled??new wo;
  this._localParentNotSampled=t.localParentNotSampled??new Iu;
}shouldSample(t,n,r,o,s,i){
  const a=C.trace.getSpanContext(t);

  if (!a||!C.isSpanContextValid(a)) {
    return this._root.shouldSample(t,n,r,o,s,i);
  }

  if (a.isRemote) {
    if (a.traceFlags&C.TraceFlags.SAMPLED) {
      return this._remoteParentSampled.shouldSample(t,n,r,o,s,i);
    }

    return this._remoteParentNotSampled.shouldSample(t,n,r,o,s,i);
  }

  if (a.traceFlags&C.TraceFlags.SAMPLED) {
    return this._localParentSampled.shouldSample(t,n,r,o,s,i);
  }

  return this._localParentNotSampled.shouldSample(t,n,r,o,s,i);
}toString(){return`ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`}}class Kg{_ratio;_upperBound;constructor(t=0){
  this._ratio=t;
  this._ratio=this._normalize(t);
  this._upperBound=Math.floor(this._ratio*4294967295);
}shouldSample(t,n){return{decision:C.isValidTraceId(n)&&this._accumulate(n)<this._upperBound?Dt.RECORD_AND_SAMPLED:Dt.NOT_RECORD}}toString(){return`TraceIdRatioBased{${this._ratio}}`}_normalize(t){return typeof t!="number"||isNaN(t)?0:t>=1?1:t<=0?0:t}_accumulate(t){let n=0;for(let r=0;r<t.length/8;r++){
  const o=r*8;
  const s=parseInt(t.slice(o,o+8),16);
  n=(n^s)>>>0
}return n}}const En = {
  AlwaysOff: "always_off",
  AlwaysOn: "always_on",
  ParentBasedAlwaysOff: "parentbased_always_off",
  ParentBasedAlwaysOn: "parentbased_always_on",
  ParentBasedTraceIdRatio: "parentbased_traceidratio",
  TraceIdRatio: "traceidratio"
};const Dc=1;function JP(){return {sampler:eM(),forceFlushTimeoutMillis:30000/* 3e4 */,generalLimits:{attributeValueLengthLimit:bt("OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT")??Infinity,attributeCountLimit:bt("OTEL_ATTRIBUTE_COUNT_LIMIT")??128},spanLimits:{attributeValueLengthLimit:bt("OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT")??Infinity,attributeCountLimit:bt("OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT")??128,linkCountLimit:bt("OTEL_SPAN_LINK_COUNT_LIMIT")??128,eventCountLimit:bt("OTEL_SPAN_EVENT_COUNT_LIMIT")??128,attributePerEventCountLimit:bt("OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT")??128,attributePerLinkCountLimit:bt("OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT")??128}};}function eM(){const e=rE("OTEL_TRACES_SAMPLER")??En.ParentBasedAlwaysOn;switch(e){case En.AlwaysOn:
  {
    return new wo;
  }case En.AlwaysOff:
  {
    return new Iu;
  }case En.ParentBasedAlwaysOn:
  {
    return new wc({root:new wo});
  }case En.ParentBasedAlwaysOff:
  {
    return new wc({root:new Iu});
  }case En.TraceIdRatio:
  {
    return new Kg(zg());
  }case En.ParentBasedTraceIdRatio:
  {
    return new wc({root:new Kg(zg())});
  }default:
  {
    C.diag.error(`OTEL_TRACES_SAMPLER value "${e}" invalid, defaulting to "${En.ParentBasedAlwaysOn}".`);
    return new wc({root:new wo});
  }}}function zg(){const e=bt("OTEL_TRACES_SAMPLER_ARG");return e==null?(C.diag.error(`OTEL_TRACES_SAMPLER_ARG is blank, defaulting to ${Dc}.`),Dc):e<0||e>1?(C.diag.error(`OTEL_TRACES_SAMPLER_ARG=${e} was given, but it is out of range ([0..1]), defaulting to ${Dc}.`),Dc):e}
const RB=128;
const NB=Infinity;
function yB(e){
  const t={sampler:eM()};
  const n=JP();
  const r=Object.assign({},n,t,e);
  r.generalLimits=Object.assign({},n.generalLimits,e.generalLimits||{});
  r.spanLimits=Object.assign({},n.spanLimits,e.spanLimits||{});
  return r;
}function OB(e){
  const t=Object.assign({},e.spanLimits);
  t.attributeCountLimit=e.spanLimits?.attributeCountLimit??e.generalLimits?.attributeCountLimit??bt("OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT")??bt("OTEL_ATTRIBUTE_COUNT_LIMIT")??RB;
  t.attributeValueLengthLimit=e.spanLimits?.attributeValueLengthLimit??e.generalLimits?.attributeValueLengthLimit??bt("OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT")??bt("OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT")??NB;
  return Object.assign({},e,{spanLimits:t});
}
const bB=8;
const tM=16;
class CB{generateTraceId=Zg(tM);generateSpanId=Zg(bB)}const Uc=Buffer.allocUnsafe(tM);function Zg(e){return () => {for (let n=0; n<e/4; n++) {
  Uc.writeUInt32BE(Math.random()*2**32>>>0,n*4);
}for (let n=0; n<e&&!(Uc[n]>0); n++) {
  if (n===e-1) {
    (Uc[e-1] = 1);
  }
}return Uc.toString("hex",0,e)};}class IB{_sampler;_generalLimits;_spanLimits;_idGenerator;instrumentationScope;_resource;_spanProcessor;constructor(t,n,r,o){
  const s=yB(n);
  this._sampler=s.sampler;
  this._generalLimits=s.generalLimits;
  this._spanLimits=s.spanLimits;
  this._idGenerator=n.idGenerator||new CB;
  this._resource=r;
  this._spanProcessor=o;
  this.instrumentationScope=t;
}startSpan(t,n={},r=C.context.active()){
  if (n.root) {
    (r = C.trace.deleteSpan(r));
  }

  const o=C.trace.getSpan(r);if (yn(r)) {
      C.diag.debug("Instrumentation suppressed, returning Noop Span");
      return C.trace.wrapSpanContext(C.INVALID_SPAN_CONTEXT);
    }
  const s=o?.spanContext();
  const i=this._idGenerator.generateSpanId();
  let a;
  let c;
  let l;

  if (!s||!C.trace.isSpanContextValid(s)) {
    c=this._idGenerator.generateTraceId();
  } else {
    c=s.traceId;
    l=s.traceState;
    a=s;
  }

  const f=n.kind??C.SpanKind.INTERNAL;

  const d=(n.links??[]).map(m => ({
    context:m.context,
    attributes:Wa(m.attributes)
  }));

  const u=Wa(n.attributes);
  const _=this._sampler.shouldSample(r,c,t,f,u,d);
  l=_.traceState??l;
  const p=_.decision===C.SamplingDecision.RECORD_AND_SAMPLED?C.TraceFlags.SAMPLED:C.TraceFlags.NONE;
  const E={traceId:c,spanId:i,traceFlags:p,traceState:l};
  if (_.decision===C.SamplingDecision.NOT_RECORD) {
    C.diag.debug("Recording is off, propagating context in a non-recording span");
    return C.trace.wrapSpanContext(E);
  }const h=Wa(Object.assign(u,_.attributes));return new gB({resource:this._resource,scope:this.instrumentationScope,context:r,spanContext:E,name:t,kind:f,links:d,parentSpanContext:a,attributes:h,startTime:n.startTime,spanProcessor:this._spanProcessor,spanLimits:this._spanLimits})
}startActiveSpan(t,n,r,o){
  let s;
  let i;
  let a;
  if (arguments.length<2) {
    return;
  }

  if (arguments.length===2) {
    a=n;
  } else if (arguments.length===3) {
    s=n;
    a=r;
  } else {
    s=n;
    i=r;
    a=o;
  }

  const c=i??C.context.active();
  const l=this.startSpan(t,s,c);
  const f=C.trace.setSpan(c,l);
  return C.context.with(f,a,void 0,l)
}getGeneralLimits(){return this._generalLimits}getSpanLimits(){return this._spanLimits}}class PB{_spanProcessors;constructor(t){this._spanProcessors=t}forceFlush(){const t=[];for (const n of this._spanProcessors) {
  t.push(n.forceFlush());
}return new Promise(n=>{Promise.all(t).then(()=>{n()}).catch(r=>{
  nE(r||new Error("MultiSpanProcessor: forceFlush failed"));
  n();
})});}onStart(t,n){for (const r of this._spanProcessors) {
  r.onStart(t,n)
}}onEnd(t){for (const n of this._spanProcessors) {
  n.onEnd(t)
}}shutdown(){const t=[];for (const n of this._spanProcessors) {
  t.push(n.shutdown());
}return new Promise((n,r)=>{Promise.all(t).then(()=>{n()},r)})}}const Kr = {
  resolved: 0,
  timeout: 1,
  error: 2,
  unresolved: 3,

  // reverse mapping
  0: "resolved",

  1: "timeout",
  2: "error",
  3: "unresolved"
};class MB{_config;_tracers=new Map;_resource;_activeSpanProcessor;constructor(t={}){
  const n=pI({},JP(),OB(t));
  this._resource=n.resource??QP();
  this._config=Object.assign({},n,{resource:this._resource});
  const r=[];

  if (t.spanProcessors?.length) {
    r.push(...t.spanProcessors);
  }

  this._activeSpanProcessor=new PB(r);
}getTracer(t,n,r){
  const o=`${t}@${n||""}:${r?.schemaUrl||""}`;

  if (!this._tracers.has(o)) {
    this._tracers.set(o,new IB({name:t,version:n,schemaUrl:r?.schemaUrl},this._config,this._resource,this._activeSpanProcessor));
  }

  return this._tracers.get(o);
}forceFlush(){
  const t=this._config.forceFlushTimeoutMillis;

  const n=this._activeSpanProcessor._spanProcessors.map(r => new Promise(o=>{let s;const i=setTimeout(()=>{
    o(new Error(`Span processor did not completed within timeout period of ${t} ms`));
    s=Kr.timeout;
  },t);r.forceFlush().then(()=>{
    clearTimeout(i);

    if (s!==Kr.timeout) {
      s=Kr.resolved;
      o(s);
    }
  }).catch(a=>{
    clearTimeout(i);
    s=Kr.error;
    o(a);
  })}));

  return new Promise((r,o)=>{Promise.all(n).then(s=>{
    const i=s.filter(a => a!==Kr.resolved);

    if (i.length>0) {
      o(i);
    } else {
      r();
    }
  }).catch(s => o([s]))});
}shutdown(){return this._activeSpanProcessor.shutdown()}}
const BE="sentry.parentIsRemote";
const Fa="sentry.graphql.operation";
function HE(e){if ("parentSpanId"in e) {
  return e.parentSpanId;
}if ("parentSpanContext"in e) {
  return e.parentSpanContext?.spanId
}}function FE(e){const t=e;return!!t.attributes&&typeof t.attributes=="object"}function vB(e){return typeof e.kind=="number"}function LB(e){return!!e.status}function nM(e){return!!e.name}function wB(e){
  if (!FE(e)) {
    return{};
  }
  const t=e.attributes[Q.ATTR_URL_FULL]||e.attributes[Q.SEMATTRS_HTTP_URL];
  const n={url:t,"http.method":e.attributes[Q.ATTR_HTTP_REQUEST_METHOD]||e.attributes[Q.SEMATTRS_HTTP_METHOD]};

  if (!n["http.method"]&&n.url) {
    (n["http.method"] = "GET");
  }

  try{if(typeof t=="string"){
    const r=_l(t);
    n.url=pl(r);

    if (r.search) {
      (n["http.query"] = r.search);
    }

    if (r.hash) {
      (n["http.fragment"] = r.hash);
    }
  }}catch{}return n
}function DB(e){return vB(e)?e.kind:C.SpanKind.INTERNAL}
const Cd="sentry-trace";
const gp="baggage";
const YE="sentry.dsc";
const jE="sentry.sampled_not_recording";
const rM="sentry.url";
const UB="sentry.sample_rand";
const kB="sentry.sample_rate";
const oM=C.createContextKey("sentry_scopes");
const Rp=C.createContextKey("sentry_fork_isolation_scope");
const Np=C.createContextKey("sentry_fork_set_scope");
const yp=C.createContextKey("sentry_fork_set_isolation_scope");
const sM="_scopeContext";
function ts(e){return e.getValue(oM)}function iM(e,t){return e.setValue(oM,t)}function GB(e,t){cn(e,sM,t)}function cc(e){return e[sM]}function Ho(e){
  const {traceFlags,traceState}=e;
  const r=traceState?traceState.get(jE)==="1":false;
  if (traceFlags===C.TraceFlags.SAMPLED) {
    return true;
  }if (r) {
    return false;
  }
  const o=traceState?traceState.get(YE):void 0;
  const s=o?Rc(o):void 0;
  if (s?.sampled==="true") {
    return true;
  }if (s?.sampled==="false") {
    return false;
  }
}function aM(e,t,n){
  const r=t[Q.ATTR_HTTP_REQUEST_METHOD]||t[Q.SEMATTRS_HTTP_METHOD];if (r) {
    return xB({attributes:t,name:e,kind:n},r);
  }
  const o=t[Q.SEMATTRS_DB_SYSTEM];
  const s=typeof t[Ee]=="string"&&t[Ee].startsWith("cache.");
  if (o&&!s) {
    return VB({attributes:t,name:e});
  }const i=t[Kt]==="custom"?"custom":"route";if (t[Q.SEMATTRS_RPC_SERVICE]) {
    return{...za(e,t,"route"),op:"rpc"};
  }if (t[Q.SEMATTRS_MESSAGING_SYSTEM]) {
    return{...za(e,t,i),op:"message"};
  }const l=t[Q.SEMATTRS_FAAS_TRIGGER];return l?{...za(e,t,i),op:l.toString()}:{op:void 0,description:e,source:"custom"}
}function cM(e){
  const t=FE(e)?e.attributes:{};
  const n=nM(e)?e.name:"<unknown>";
  const r=DB(e);
  return aM(n,t,r)
}function VB({attributes,name}){const n=attributes[xo];if (typeof n=="string") {
  return {op:"db",description:n,source:attributes[Kt]||"custom"};
}if (attributes[Kt]==="custom") {
  return {op:"db",description:name,source:"custom"};
}const r=attributes[Q.SEMATTRS_DB_STATEMENT];return {op:"db",description:r?r.toString():name,source:"task"};}function xB({name,kind,attributes},r){
  const o=["http"];switch(kind){case C.SpanKind.CLIENT:
      {
        o.push("client");break;
      }case C.SpanKind.SERVER:
      {
        o.push("server");break
      }}

  if (attributes["sentry.http.prefetch"]) {
    o.push("prefetch");
  }

  const{urlPath,url,query,fragment,hasRoute}=BB(attributes,kind);if (!urlPath) {
      return {...za(name,attributes),op:o.join(".")};
    }
  const f=attributes[Fa];
  const d=`${r} ${urlPath}`;
  const u=f?`${d} (${$B(f)})`:d;
  const _=hasRoute||urlPath==="/"?"route":"url";
  const p={};

  if (url) {
    (p.url = url);
  }

  if (query) {
    (p["http.query"] = query);
  }

  if (fragment) {
    (p["http.fragment"] = fragment);
  }

  const E=kind===C.SpanKind.CLIENT||kind===C.SpanKind.SERVER;
  const T=!`${attributes[Ge]||"manual"}`.startsWith("auto");
  const m=attributes[Kt]==="custom";
  const A=attributes[xo];
  const g=!m&&A==null&&(E||!T);
  const {description,source}=g?{description:u,source:_}:za(name,attributes);
  return {op:o.join("."),description:description,source:source,data:p};
}function $B(e){if(Array.isArray(e)){const t=e.slice().sort();return t.length<=5?t.join(", "):`${t.slice(0,5).join(", ")}, +${t.length-5}`}return`${e}`}function BB(e,t){
  const n=e[Q.SEMATTRS_HTTP_TARGET];
  const r=e[Q.SEMATTRS_HTTP_URL]||e[Q.ATTR_URL_FULL];
  const o=e[Q.ATTR_HTTP_ROUTE];
  const s=typeof r=="string"?_l(r):void 0;
  const i=s?pl(s):void 0;
  const a=s?.search||void 0;
  const c=s?.hash||void 0;

  if (typeof o=="string") {
    return {urlPath:o,url:i,query:a,fragment:c,hasRoute:true};
  }

  if (t===C.SpanKind.SERVER&&typeof n=="string") {
    return {urlPath:ac(n),url:i,query:a,fragment:c,hasRoute:false};
  }

  if (s) {
    return {urlPath:i,url:i,query:a,fragment:c,hasRoute:false};
  }

  if (typeof n=="string") {
    return {urlPath:ac(n),url:i,query:a,fragment:c,hasRoute:false};
  }

  return {urlPath:void 0,url:i,query:a,fragment:c,hasRoute:false};
}function za(e,t,n="custom"){
  const r=t[Kt]||n;
  const o=t[xo];
  return o&&typeof o=="string"?{description:o,source:r}:{description:e,source:r}
}function HB(e){e.on("createDsc",(t,n)=>{
  if (!n) {
    return;
  }
  const s=Re(n).data[Kt];
  const {description}=nM(n)?cM(n):{description:void 0};

  if (s!=="url"&&description) {
    (t.transaction = description);
  }

  if (zt())
    {const a=Ho(n.spanContext());t.sampled=a==null?void 0:String(a)}
})}function uM(){return C.trace.getActiveSpan()}const Nn=typeof __SENTRY_DEBUG__ === "undefined"||__SENTRY_DEBUG__;function lM({dsc,sampled}){
  const n=dsc?gE(dsc):void 0;
  const r=new zo;
  const o=n?r.set(YE,n):r;
  return sampled===false?o.set(jE,"1"):o;
}const dM=new Set;function FB(){return Array.from(dM)}function Ol(e){dM.add(e)}class YB extends tI{constructor(){
  super();
  Ol("SentryPropagator");
  this._urlMatchesTargetsMap=new es(100);
}inject(t,n,r){
  if(yn(t)){
    if (Nn) {
      x.log("[Tracing] Not injecting trace data for url because tracing is suppressed.");
    }

    return
  }
  const o=C.trace.getSpan(t);
  const s=o&&WB(o);
  const i=he()?.getOptions()?.tracePropagationTargets;
  if(!qE(s,i,this._urlMatchesTargetsMap)){
    if (Nn) {
      x.log("[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:",s);
    }

    return
  }const a=qB(n);let c=C.propagation.getBaggage(t)||C.propagation.createBaggage({});const{dynamicSamplingContext,traceId,spanId,sampled}=fM(t);if(a){
    const _=Su(a);

    if (_) {
      Object.entries(_).forEach(([p,E])=>{c=c.setEntry(p,{value:E})});
    }
  }

  if (dynamicSamplingContext) {
    (c = Object.entries(dynamicSamplingContext).reduce((_, [p,E]) => E?_.setEntry(`${AE}${p}`,{value:E}):_,c));
  }

  if (traceId&&traceId!==C.INVALID_TRACEID) {
    r.set(n,Cd,il(traceId,spanId,sampled));
  }

  super.inject(C.propagation.setBaggage(t,c),n,r);
}extract(t,n,r){
  const o=r.get(n,Cd);
  const s=r.get(n,gp);
  const i=o?Array.isArray(o)?o[0]:o:void 0;
  return pM(_M(t,{sentryTrace:i,baggage:s}))
}fields(){return[Cd,gp]}}const Xg="[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:";function qE(e,t,n){
  if (typeof e!="string"||!t) {
    return true;
  }const r=n?.get(e);if (r!==void 0) {
    if (Nn&&!r) {
      x.log(Xg,e);
    }

    return r;
  }const o=mc(e,t);
  n?.set(e,o);

  if (Nn&&!o) {
    x.log(Xg,e);
  }

  return o;
}function fM(e,t={}){
  const n=C.trace.getSpan(e);if(n?.spanContext().isRemote){const a=n.spanContext();return{dynamicSamplingContext:xt(n),traceId:a.traceId,spanId:void 0,sampled:Ho(a)}}if(n){const a=n.spanContext();return{dynamicSamplingContext:xt(n),traceId:a.traceId,spanId:a.spanId,sampled:Ho(a)}}
  const r=t.scope||ts(e)?.scope||Ke();
  const o=t.client||he();
  const s=r.getPropagationContext();
  return{dynamicSamplingContext:o?Nc(o,r):void 0,traceId:s.traceId,spanId:s.propagationSpanId,sampled:s.sampled}
}function _M(e,{sentryTrace,baggage}){
  const r=zI(sentryTrace,baggage);
  const {traceId,parentSpanId,sampled,dsc}=r;
  const c=he();
  const l=Rc(baggage);
  if (!parentSpanId||c&&!e1(c,l?.org_id)) {
    return e;
  }const f=KB({traceId:traceId,spanId:parentSpanId,sampled:sampled,dsc:dsc});return C.trace.setSpanContext(e,f)
}function jB(e,t,n){const r=pM(_M(e,t));return C.context.with(r,n)}function pM(e){
  const t=ts(e);
  const n={scope:t?t.scope:Ke().clone(),isolationScope:t?t.isolationScope:je()};
  return iM(e,n)
}function qB(e){try{const t=e[gp];return Array.isArray(t)?t.join(","):t}catch{return}}function WB(e){
  const t=Re(e).data;
  const n=t[Q.SEMATTRS_HTTP_URL]||t[Q.ATTR_URL_FULL];
  if (typeof n=="string") {
    return n;
  }const r=e.spanContext().traceState?.get(rM);if (r) {
    return r
  }
}function KB({spanId,traceId,sampled,dsc}){const o=lM({dsc:dsc,sampled:sampled});return {traceId:traceId,spanId:spanId,isRemote:true,traceFlags:sampled?C.TraceFlags.SAMPLED:C.TraceFlags.NONE,traceState:o};}function EM(e,t,n){
  const r=TM();
  const {name,parentSpan}=e;
  return AM(parentSpan)(()=>{
    const a=mM(e.scope,e.forceTransaction);
    const l=e.onlyIfParent&&!C.trace.getSpan(a)?Qr(a):a;
    const f=SM(e);
    if(!zt()){const d=yn(l)?l:Qr(l);return C.context.with(d,() => r.startActiveSpan(name,f,d,u => C.context.with(a,() => oo(() => t(u),()=>{
      if (Re(u).status===void 0) {
        u.setStatus({code:C.SpanStatusCode.ERROR});
      }
    },n?() => u.end():void 0))));}return r.startActiveSpan(name,f,l,d => oo(() => t(d),()=>{
    if (Re(d).status===void 0) {
      d.setStatus({code:C.SpanStatusCode.ERROR});
    }
  },n?() => d.end():void 0));
  });
}function zB(e,t){return EM(e,t,true);}function ZB(e,t){return EM(e,n => t(n,() => n.end()),false);}function XB(e){
  const t=TM();
  const {name,parentSpan}=e;
  return AM(parentSpan)(()=>{
    const s=mM(e.scope,e.forceTransaction);let a=e.onlyIfParent&&!C.trace.getSpan(s)?Qr(s):s;const c=SM(e);

    if (!zt()) {
      (a = yn(a)?a:Qr(a));
    }

    return t.startSpan(name,c,a);
  });
}function hM(e,t){const n=e?C.trace.setSpan(C.context.active(),e):C.trace.deleteSpan(C.context.active());return C.context.with(n,() => t(Ke()));}function TM(){return he()?.tracer||C.trace.getTracer("@sentry/opentelemetry",Ze)}function SM(e){
  const {startTime,attributes,kind,op: op_1,links}=e;
  const i=typeof startTime=="number"?QB(startTime):startTime;
  return {attributes:op_1?{[Ee]:op_1,...attributes}:attributes,kind:kind,links:links,startTime:i};
}function QB(e){return e<9999999999?e*1000/* 1e3 */:e;}function mM(e,t){
  const n=JB(e);
  const r=C.trace.getSpan(n);
  if (!r||!t) {
    return n;
  }
  const o=C.trace.deleteSpan(n);
  const {spanId,traceId}=r.spanContext();
  const a=Ho(r.spanContext());
  const c=Yt(r);
  const l=xt(c);
  const f=lM({dsc:l,sampled:a});
  const d={traceId:traceId,spanId:spanId,isRemote:true,traceFlags:a?C.TraceFlags.SAMPLED:C.TraceFlags.NONE,traceState:f};
  return C.trace.setSpanContext(o,d)
}function JB(e){if(e){const t=cc(e);if (t) {
  return t
}}return C.context.active()}function eH(e,t){return jB(C.context.active(),e,t)}function tH(e,t){
  const n=cc(t);
  const r=n&&C.trace.getSpan(n);
  const o=r?al(r):TE(t);
  return[r?xt(r):Nc(e,t),o]
}function AM(e){return e!==void 0?t => hM(e,t):t => t();}function nH(e){const t=Qr(C.context.active());return C.context.with(t,e)}function rH(e){e.on("preprocessEvent",t=>{
  const n=uM();if (!n||t.type==="transaction") {
    return;
  }t.contexts={trace:al(n),...t.contexts};const r=Yt(n);
  t.sdkProcessingMetadata={dynamicSamplingContext:xt(r),...t.sdkProcessingMetadata};
  return t;
})}function oH({span:e,scope:t,client:n}={}){let r=(t&&cc(t))??C.context.active();if(e){const{scope}=$o(e);r=scope&&cc(scope)||C.trace.setSpan(C.context.active(),e)}const{traceId,spanId,sampled,dynamicSamplingContext}=fM(r,{scope:t,client:n});return {"sentry-trace":il(traceId,spanId,sampled),baggage:gE(dynamicSamplingContext)};}function sH(){function e(){
  const a=C.context.active();
  const c=ts(a);
  return c||{scope:hE(),isolationScope:Xo()}
}function t(a){const c=C.context.active();return C.context.with(c,() => a(s()));}function n(a,c){const l=cc(a)||C.context.active();return C.context.with(l.setValue(Np,a),() => c(a));}function r(a){const c=C.context.active();return C.context.with(c.setValue(Rp,true),() => a(i()));}function o(a,c){const l=C.context.active();return C.context.with(l.setValue(yp,a),() => c(i()));}function s(){return e().scope}function i(){return e().isolationScope}vk({withScope:t,withSetScope:n,withSetIsolationScope:o,withIsolationScope:r,getCurrentScope:s,getIsolationScope:i,startSpan:zB,startSpanManual:ZB,startInactiveSpan:XB,getActiveSpan:uM,suppressTracing:nH,getTraceData:oH,continueTrace:eH,withActiveSpan:hM})}function iH(e){class t extends e{constructor(...r){
  super(...r);
  Ol("SentryContextManager");
}with(r,o,s,...i){
  const a=ts(r);
  const c=a?.scope||Ke();
  const l=a?.isolationScope||je();
  const f=r.getValue(Rp)===true;
  const d=r.getValue(Np);
  const u=r.getValue(yp);
  const _=d||c.clone();
  const p=u||(f?l.clone():l);
  const T=iM(r,{scope:_,isolationScope:p}).deleteValue(Rp).deleteValue(Np).deleteValue(yp);
  GB(_,T);
  return super.with(T,o,s,...i);
}}return t}function aH(e){const t=new Map;for (const n of e) {
  cH(t,n);
}return Array.from(t,([n,r]) => r);}function gM(e){return e.attributes[BE]===true?void 0:HE(e);}function cH(e,t){
  const n=t.spanContext().spanId;
  const r=gM(t);
  if(!r){Op(e,{id:n,span:t,children:[]});return}
  const o=uH(e,r);
  const s=Op(e,{id:n,span:t,parentNode:o,children:[]});
  o.children.push(s)
}function uH(e,t){const n=e.get(t);return n||Op(e,{id:t,children:[]})}function Op(e,t){const n=e.get(t.id);return n?.span?n:n&&!n.span?(n.span=t.span,n.parentNode=t.parentNode,n):(e.set(t.id,t),t)}
const RM={1:"cancelled",2:"unknown_error",3:"invalid_argument",4:"deadline_exceeded",5:"not_found",6:"already_exists",7:"permission_denied",8:"resource_exhausted",9:"failed_precondition",10:"aborted",11:"out_of_range",12:"unimplemented",13:"internal_error",14:"unavailable",15:"data_loss",16:"unauthenticated"};

const lH=e => Object.values(RM).includes(e);

function NM(e){
  const t=FE(e)?e.attributes:{};
  const n=LB(e)?e.status:void 0;
  if(n){if (n.code===C.SpanStatusCode.OK) {
    return{code:Tu};
  }if(n.code===C.SpanStatusCode.ERROR){if(typeof n.message === "undefined"){const o=Qg(t);if (o) {
    return o
  }}return n.message&&lH(n.message)?{code:Ae,message:n.message}:{code:Ae,message:"internal_error"}}}const r=Qg(t);return r||(n?.code===C.SpanStatusCode.UNSET?{code:Tu}:{code:Ae,message:"unknown_error"})
}function Qg(e){
  const t=e[Q.ATTR_HTTP_RESPONSE_STATUS_CODE]||e[Q.SEMATTRS_HTTP_STATUS_CODE];
  const n=e[Q.SEMATTRS_RPC_GRPC_STATUS_CODE];
  const r=typeof t=="number"?t:typeof t=="string"?parseInt(t):void 0;
  if (typeof r=="number") {
    return lp(r);
  }if (typeof n=="string") {
    return{code:Ae,message:RM[n]||"unknown_error"}
  }
}
const Jg=1000/* 1e3 */;
const eR=300;
class dH{constructor(t){
  this._finishedSpanBucketSize=t?.timeout||eR;
  this._finishedSpanBuckets=new Array(this._finishedSpanBucketSize).fill(void 0);
  this._lastCleanupTimestampInS=Math.floor(Date.now()/1000/* 1e3 */);
  this._spansToBucketEntry=new WeakMap;
  this._sentSpans=new Map;
  this._debouncedFlush=qG(this.flush.bind(this),1,{maxWait:100});
}export(t){
  const n=Math.floor(Date.now()/1000/* 1e3 */);if(this._lastCleanupTimestampInS!==n){
    let i=0;
    this._finishedSpanBuckets.forEach((a,c)=>{
      if (a&&a.timestampInS<=n-this._finishedSpanBucketSize) {
        i+=a.spans.size;
        this._finishedSpanBuckets[c]=void 0;
      }
    });

    if (i>0&&Nn) {
      x.log(`SpanExporter dropped ${i} spans because they were pending for more than ${this._finishedSpanBucketSize} seconds.`);
    }

    this._lastCleanupTimestampInS=n;
  }
  const r=n%this._finishedSpanBucketSize;
  const o=this._finishedSpanBuckets[r]||{timestampInS:n,spans:new Set};
  this._finishedSpanBuckets[r]=o;
  o.spans.add(t);
  this._spansToBucketEntry.set(t,o);
  const s=gM(t);

  if ((!s || this._sentSpans.has(s))) {
    this._debouncedFlush();
  }
}flush(){
  const t=this._finishedSpanBuckets.flatMap(i => i?Array.from(i.spans):[]);this._flushSentSpanCache();
  const n=this._maybeSend(t);
  const r=n.size;
  const o=t.length-r;

  if (Nn) {
    x.log(`SpanExporter exported ${r} spans, ${o} spans are waiting for their parent spans to finish`);
  }

  const s=Date.now()+eR*1000/* 1e3 */;for(const i of n){
    this._sentSpans.set(i.spanContext().spanId,s);const a=this._spansToBucketEntry.get(i);

    if (a) {
      a.spans.delete(i);
    }
  }this._debouncedFlush.cancel()
}clear(){
  this._finishedSpanBuckets=this._finishedSpanBuckets.fill(void 0);
  this._sentSpans.clear();
  this._debouncedFlush.cancel();
}_maybeSend(t){
  const n=aH(t);
  const r=new Set;
  const o=this._getCompletedRootNodes(n);
  for(const s of o){
    const i=s.span;r.add(i);const a=_H(i);if(s.parentNode&&this._sentSpans.has(s.parentNode.id)){
      const f=a.contexts?.trace?.data;

      if (f) {
        (f["sentry.parent_span_already_sent"] = true);
      }
    }const c=a.spans||[];for (const f of s.children) {
        bp(f,c,r);
      }a.spans=c.length>Jg?c.sort((f, d) => f.start_timestamp-d.start_timestamp).slice(0,Jg):c;const l=mu(i.events);

    if (l) {
      (a.measurements = l);
    }

    K1(a);
  }return r
}_flushSentSpanCache(){const t=Date.now();for (const[n,r] of this._sentSpans.entries()) {
  if (r<=t) {
    this._sentSpans.delete(n);
  }
}}_nodeIsCompletedRootNodeOrHasSentParent(t){return!!t.span&&(!t.parentNode||this._sentSpans.has(t.parentNode.id))}_getCompletedRootNodes(t){return t.filter(n => this._nodeIsCompletedRootNodeOrHasSentParent(n));}}function fH(e){
  const t=e.attributes;
  const n=t[Ge];
  const r=t[Ee];
  const o=t[Kt];
  return{origin:n,op:r,source:o}
}function _H(e){
  const {op: op_1,description,data,origin="manual",source}=yM(e);
  const i=$o(e);
  const a=e.attributes[Vo];
  const c={[Kt]:source,[Vo]:a,[Ee]:op_1,[Ge]:origin,...data,...OM(e.attributes)};
  const {links}=e;
  const {traceId,spanId}=e.spanContext();
  const u=HE(e);
  const _=NM(e);
  const p={parent_span_id:u,span_id:spanId,trace_id:traceId,data:c,origin:origin,op:op_1,status:ul(_),links:cl(links)};
  const E=c[Q.ATTR_HTTP_RESPONSE_STATUS_CODE];
  const h=typeof E=="number"?{response:{status_code:E}}:void 0;
  return {contexts:{trace:p,otel:{resource:e.resource.attributes},...h},spans:[],start_timestamp:An(e.startTime),timestamp:An(e.endTime),transaction:description,type:"transaction",sdkProcessingMetadata:{capturedSpanScope:i.scope,capturedSpanIsolationScope:i.isolationScope,sampleRate:a,dynamicSamplingContext:xt(e)},...(source && {transaction_info:{source:source}})};
}function bp(e,t,n){
  const r=e.span;

  if (r) {
    n.add(r);
  }

  if (!r)
    {e.children.forEach(A=>{bp(A,t,n)});return}

  const s=r.spanContext().spanId;
  const i=r.spanContext().traceId;
  const a=HE(r);
  const {attributes,startTime,endTime,links}=r;
  const {op: op_1,description,data,origin="manual"}=yM(r);
  const h={[Ge]:origin,[Ee]:op_1,...OM(attributes),...data};
  const T=NM(r);
  const m={span_id:s,trace_id:i,data:h,description:description,parent_span_id:a,start_timestamp:An(startTime),timestamp:An(endTime)||void 0,status:ul(T),op:op_1,origin:origin,measurements:mu(r.events),links:cl(links)};
  t.push(m);
  e.children.forEach(A=>{bp(A,t,n)});
}function yM(e){
  const {op: op_1,source,origin}=fH(e);
  const {op: op_2,description,source: source_1,data}=cM(e);
  const c=op_1||op_2;
  const l=source||source_1;
  const f={...data,...pH(e)};
  return {op:c,description:description,source:l,origin:origin,data:f};
}function OM(e){
  const t={...e};
  delete t[Vo];
  delete t[BE];
  delete t[xo];
  return t;
}function pH(e){
  const t=e.attributes;
  const n={};

  if (e.kind!==C.SpanKind.INTERNAL) {
    (n["otel.kind"] = C.SpanKind[e.kind]);
  }

  const r=t[Q.SEMATTRS_HTTP_STATUS_CODE];

  if (r) {
    (n[Q.ATTR_HTTP_RESPONSE_STATUS_CODE] = r);
  }

  const o=wB(e);

  if (o.url) {
    (n.url = o.url);
  }

  if (o["http.query"]) {
    (n["http.query"] = o["http.query"].slice(1));
  }

  if (o["http.fragment"]) {
    (n["http.fragment"] = o["http.fragment"].slice(1));
  }

  return n;
}function EH(e,t){
  const n=C.trace.getSpan(t);let r=ts(t);

  if (n&&!n.spanContext().isRemote) {
    NE(n,e);
  }

  if (n?.spanContext().isRemote) {
    e.setAttribute(BE,true);
  }

  if (t===C.ROOT_CONTEXT) {
    (r = {scope:hE(),isolationScope:Xo()});
  }

  if (r) {
    YI(e,r.scope,r.isolationScope);
  }

  rP(e);
  he()?.emit("spanStart",e);
}function hH(e){
  oP(e);
  he()?.emit("spanEnd",e);
}class TH{constructor(t){
  Ol("SentrySpanProcessor");
  this._exporter=new dH(t);
}async forceFlush(){this._exporter.flush()}async shutdown(){this._exporter.clear()}onStart(t,n){EH(t,n)}onEnd(t){
  hH(t);
  this._exporter.export(t);
}}class SH{constructor(t){
  this._client=t;
  Ol("SentrySampler");
}shouldSample(t,n,r,o,s,i){
  const a=this._client.getOptions();
  const c=gH(t);
  const l=c?.spanContext();
  if (!zt(a)) {
    return go({decision:void 0,context:t,spanAttributes:s});
  }const f=s[Q.SEMATTRS_HTTP_METHOD]||s[Q.ATTR_HTTP_REQUEST_METHOD];if (o===C.SpanKind.CLIENT&&f&&(!c||l?.isRemote)) {
      return go({decision:void 0,context:t,spanAttributes:s});
    }const d=c?mH(c,n,r):void 0;if (!(!c||l?.isRemote)) {
      return go({decision:d?Dt.RECORD_AND_SAMPLED:Dt.NOT_RECORD,context:t,spanAttributes:s});
    }
  const {description,data,op: op_1}=aM(r,s,o);
  const h={...data,...s};

  if (op_1) {
    (h[Ee] = op_1);
  }

  const T={decision:true};
  this._client.emit("beforeSampling",{spanAttributes:h,spanName:description,parentSampled:d,parentContext:l},T);

  if (!T.decision) {
    return go({decision:void 0,context:t,spanAttributes:s});
  }

  const {isolationScope}=ts(t)??{};
  const A=l?.traceState?l.traceState.get(YE):void 0;
  const g=A?Rc(A):void 0;
  const R=ro(g?.sample_rand)??Math.random();
  const [O,I,b]=sP(a,{name:description,attributes:h,normalizedRequest:isolationScope?.getScopeData().sdkProcessingMetadata.normalizedRequest,parentSampled:d,parentSampleRate:ro(g?.sample_rate)},R);
  const L=`${f}`.toUpperCase();
  return L==="OPTIONS"||L==="HEAD"?(Nn&&x.log(`[Tracing] Not sampling span because HTTP method is '${L}' for ${r}`),go({decision:Dt.NOT_RECORD,context:t,spanAttributes:s,sampleRand:R,downstreamTraceSampleRate:0})):(!O&&d===void 0&&(Nn&&x.log("[Tracing] Discarding root span because its trace was not chosen to be sampled."),this._client.recordDroppedEvent("sample_rate","transaction")),{...go({decision:O?Dt.RECORD_AND_SAMPLED:Dt.NOT_RECORD,context:t,spanAttributes:s,sampleRand:R,downstreamTraceSampleRate:b?I:void 0}),attributes:{[Vo]:b?I:void 0}})
}toString(){return"SentrySampler"}}function mH(e,t,n){const r=e.spanContext();if(C.isSpanContextValid(r)&&r.traceId===t){
  if(r.isRemote){
    const s=Ho(e.spanContext());

    if (Nn) {
      x.log(`[Tracing] Inheriting remote parent's sampled decision for ${n}: ${s}`);
    }

    return s;
  }const o=Ho(r);

  if (Nn) {
    x.log(`[Tracing] Inheriting parent's sampled decision for ${n}: ${o}`);
  }

  return o;
}}function go({decision,context,spanAttributes,sampleRand,downstreamTraceSampleRate}){
  let s=AH(context,spanAttributes);

  if (downstreamTraceSampleRate!==void 0) {
    (s = s.set(kB,`${downstreamTraceSampleRate}`));
  }

  if (sampleRand!==void 0) {
    (s = s.set(UB,`${sampleRand}`));
  }

  if (decision==null) {
    return {decision:Dt.NOT_RECORD,traceState:s};
  }

  if (decision===Dt.NOT_RECORD) {
    return {decision:decision,traceState:s.set(jE,"1")};
  }

  return {decision:decision,traceState:s};
}function AH(e,t){
  let o=C.trace.getSpan(e)?.spanContext()?.traceState||new zo;const s=t[Q.SEMATTRS_HTTP_URL]||t[Q.ATTR_URL_FULL];

  if (s&&typeof s=="string") {
    (o = o.set(rM,s));
  }

  return o;
}function gH(e){const t=C.trace.getSpan(e);return t&&C.isSpanContextValid(t.spanContext())?t:void 0}function Cp(e,t){
  if (!e) {
    return t;
  }
  const n=Su(e);
  const r=Su(t);
  if (!r) {
    return e;
  }const o={...n};
  Object.entries(r).forEach(([s,i])=>{
    if (!o[s]) {
      (o[s] = i);
    }
  });
  return jI(o);
}function RH(e,t){
  const n=yH(e);
  const r=t?.statusCode;
  const o=qP(r);
  Bo({category:"http",data:{status_code:r,...n},type:"http",level:o},{event:"response",request:e,response:t})
}function NH(e,t){
  const n=bH(e);
  const r=he()?.getOptions().tracePropagationTargets;
  const o=qE(n,r,t)?bP():void 0;
  if (!o) {
    return;
  }const{"sentry-trace":s,baggage}=o;if (s&&!e.getHeader("sentry-trace")) {
    try{
      e.setHeader("sentry-trace",s);

      if (Ie) {
        x.log(Oo,"Added sentry-trace header to outgoing request");
      }
    }catch(a){
      if (Ie) {
        x.error(Oo,"Failed to add sentry-trace header to outgoing request:",_u(a)?a.message:"Unknown error");
      }
    }
  }if(baggage){const a=Cp(e.getHeader("baggage"),baggage);if (a) {
    try{
      e.setHeader("baggage",a);

      if (Ie) {
        x.log(Oo,"Added baggage header to outgoing request");
      }
    }catch(c){
      if (Ie) {
        x.error(Oo,"Failed to add baggage header to outgoing request:",_u(c)?c.message:"Unknown error");
      }
    }
  }}
}function yH(e){try{
  const t=e.getHeader("host")||e.host;
  const n=new URL(e.path,`${e.protocol}//${t}`);
  const r=_l(n.toString());
  const o={url:pl(r),"http.method":e.method||"GET"};

  if (r.search) {
    (o["http.query"] = r.search);
  }

  if (r.hash) {
    (o["http.fragment"] = r.hash);
  }

  return o;
}catch{return{}}}function OH(e){return{method:e.method,protocol:e.protocol,host:e.host,hostname:e.host,path:e.path,headers:e.getHeaders()}}function bH(e){
  const t=e.getHeader("host")||e.host;
  const n=e.protocol;
  const r=e.path;
  return`${n}//${t}${r}`
}class bM extends Ot{constructor(t={}){
  super(Oo,Ze,t);
  this._propagationDecisionMap=new es(100);
  this._ignoreOutgoingRequestsMap=new WeakMap;
}init(){
  let t=false;
  const n=(a=>{const c=a;this._onOutgoingRequestFinish(c.request,c.response)});
  const r=(a=>{const c=a;this._onOutgoingRequestFinish(c.request,void 0)});
  const o=(a=>{const c=a;this._onOutgoingRequestCreated(c.request)});

  const s=a => {
    if (!t) {
      t=true;
      Sn.subscribe("http.client.response.finish",n);
      Sn.subscribe("http.client.request.error",r);
      this.getConfig().propagateTraceInOutgoingRequests&&Sn.subscribe("http.client.request.created",o);
    }

    return a;
  };

  const i=()=>{
    Sn.unsubscribe("http.client.response.finish",n);
    Sn.unsubscribe("http.client.request.error",r);
    Sn.unsubscribe("http.client.request.created",o);
  };

  return[new ft("http",["*"],s,i),new ft("https",["*"],s,i)]
}_onOutgoingRequestFinish(t,n){
  if (Ie) {
    x.log(Oo,"Handling finished outgoing request");
  }

  const r=this.getConfig().breadcrumbs;
  const o=typeof r === "undefined"?true:r;
  const s=this._ignoreOutgoingRequestsMap.get(t)??this._shouldIgnoreOutgoingRequest(t);
  this._ignoreOutgoingRequestsMap.set(t,s);

  if (o&&!s) {
    RH(t,n);
  }
}_onOutgoingRequestCreated(t){
  const n=this._ignoreOutgoingRequestsMap.get(t)??this._shouldIgnoreOutgoingRequest(t);
  this._ignoreOutgoingRequestsMap.set(t,n);

  if (!n) {
    NH(t,this._propagationDecisionMap);
  }
}_shouldIgnoreOutgoingRequest(t){
  if (yn(C.context.active())) {
    return true;
  }const n=this.getConfig().ignoreOutgoingRequests;if (!n) {
    return false;
  }
  const r=OH(t);
  const o=ZP(t);
  return n(o,r)
}}
const CM="Http";

const CH=Ne(`${CM}.sentry`,e => new bM(e));

const IH=(e={})=>{
  const t={sessions:e.trackIncomingRequestsAsSessions,sessionFlushingDelayMS:e.sessionFlushingDelayMS,ignoreRequestBody:e.ignoreIncomingRequestBody,maxRequestBodySize:e.maxIncomingRequestBodySize};
  const n={ignoreIncomingRequests:e.ignoreIncomingRequests,ignoreStaticAssets:e.ignoreStaticAssets,ignoreStatusCodes:e.dropSpansForIncomingRequestStatusCodes};
  const r={breadcrumbs:e.breadcrumbs,propagateTraceInOutgoingRequests:true,ignoreOutgoingRequests:e.ignoreOutgoingRequests};
  const o=KP(t);
  const s=zP(n);
  const i=e.spans??false;
  const a=e.disableIncomingRequestSpans??false;
  const c=i&&!a;
  return {name:CM,setup(l){
    if (c) {
      s.setup(l);
    }
  },setupOnce(){
    o.setupOnce();
    CH(r);
  },processEvent(l){return s.processEvent(l)}};
};

const bl=Ak(process.versions.node);
const Do=bl.major;
const Ip=bl.minor;
const kc="sentry-trace";
const Id="baggage";
const tR=/baggage: (.*)\r\n/;
class IM extends Ot{constructor(t={}){
  super("@sentry/instrumentation-node-fetch",Ze,t);
  this._channelSubs=[];
  this._propagationDecisionMap=new es(100);
  this._ignoreOutgoingRequestsMap=new WeakMap;
}init(){}disable(){
  super.disable();

  this._channelSubs.forEach(t => t.unsubscribe());

  this._channelSubs=[];
}enable(){
  super.enable();
  this._channelSubs=this._channelSubs||[];

  if (!(this._channelSubs.length>0)) {
    this._subscribeToChannel("undici:request:create",this._onRequestCreated.bind(this));
    this._subscribeToChannel("undici:request:headers",this._onResponseHeaders.bind(this));
  }
}_onRequestCreated({request}){
  if (!(this.getConfig().enabled!==false)) {
    return;
  }const o=this._shouldIgnoreOutgoingRequest(request);
  this._ignoreOutgoingRequestsMap.set(request,o);

  if (o) {
    return;
  }

  const s=Pp(request.origin,request.path);
  const i=he()?.getOptions().tracePropagationTargets;
  const a=qE(s,i,this._propagationDecisionMap)?bP():void 0;
  if (!a) {
    return;
  }const{"sentry-trace":c,baggage}=a;if(Array.isArray(request.headers)){
  const f=request.headers;

  if (c&&!f.includes(kc)) {
    f.push(kc,c);
  }

  const d=f.findIndex(u => u===Id);if (baggage&&d===-1) {
      f.push(Id,baggage);
    } else if(baggage){
    const u=f[d+1];
    const _=Cp(u,baggage);

    if (_) {
      (f[d+1] = _);
    }
  }
}else{
  const f=request.headers;

  if (c&&!f.includes(`${kc}:`)) {
    (request.headers += `${kc}: ${c}\r
      `);
  }

  const d=request.headers.match(tR)?.[1];if (baggage&&!d) {
      request.headers+=`${Id}: ${baggage}\r
      `;
    } else if(baggage){
    const u=Cp(d,baggage);

    if (u) {
      (request.headers = request.headers.replace(tR,`baggage: ${u}\r
        `));
    }
  }
}
}_onResponseHeaders({request,response}){
  const r=this.getConfig();if (!(r.enabled!==false)) {
      return;
    }
  const s=r.breadcrumbs;
  const i=typeof s === "undefined"?true:s;
  const a=this._ignoreOutgoingRequestsMap.get(request);

  if (i&&!a) {
    PH(request,response);
  }
}_subscribeToChannel(t,n){const r=Do>18||Do===18&&Ip>=19;let o;if (r) {
  jl.subscribe?.(t,n);

  o=() => jl.unsubscribe?.(t,n);
} else {
  const s=jl.channel(t);
  s.subscribe(n);

  o=() => s.unsubscribe(n);
}this._channelSubs.push({name:t,unsubscribe:o})}_shouldIgnoreOutgoingRequest(t){
  if (yn(C.context.active())) {
    return true;
  }
  const n=Pp(t.origin,t.path);
  const r=this.getConfig().ignoreOutgoingRequests;
  return typeof r!="function"||!n?false:r(n);
}}function PH(e,t){
  const n=MH(e);
  const r=t.statusCode;
  const o=qP(r);
  Bo({category:"http",data:{status_code:r,...n},type:"http",level:o},{event:"response",request:e,response:t})
}function MH(e){try{
  const t=Pp(e.origin,e.path);
  const n=_l(t);
  const r={url:pl(n),"http.method":e.method||"GET"};

  if (n.search) {
    (r["http.query"] = n.search);
  }

  if (n.hash) {
    (r["http.fragment"] = n.hash);
  }

  return r;
}catch{return{}}}function Pp(e,t="/"){try{return new URL(t,e).toString()}catch{const n=`${e}`;return n.endsWith("/")&&t.startsWith("/")?`${n}${t.slice(1)}`:!n.endsWith("/")&&!t.startsWith("/")?`${n}/${t.slice(1)}`:`${n}${t}`}}
const vH="NodeFetch";

const LH=Ne(`${vH}.sentry`,IM,e => e);

const wH=((e={}) => ({
  name:"NodeFetch",
  setupOnce(){LH(e)}
}));

const DH=wH;
const UH=qo.promisify(de.readFile);
const kH=qo.promisify(de.readdir);
const GH="Context";

const VH=((e={})=>{let t;const n={app:true,os:true,device:true,culture:true,cloudResource:true,...e};async function r(s, t = o()) {
  const i=$H(await t);
  s.contexts={...s.contexts,app:{...i.app,...s.contexts?.app},os:{...i.os,...s.contexts?.os},device:{...i.device,...s.contexts?.device},culture:{...i.culture,...s.contexts?.culture},cloud_resource:{...i.cloud_resource,...s.contexts?.cloud_resource}};
  return s;
}async function o(){
  const s={};

  if (n.os) {
    (s.os = await BH());
  }

  if (n.app) {
    (s.app = FH());
  }

  if (n.device) {
    (s.device = YH(n.device));
  }

  if (n.culture)
    {
      const i=HH();

      if (i) {
        (s.culture = i);
      }
    }

  if (n.cloudResource) {
    (s.cloud_resource = ZH());
  }

  return s;
}return{name:GH,processEvent(s){return r(s)}}});

const xH=VH;
function $H(e){
  if (e.app?.app_memory) {
    (e.app.app_memory = process.memoryUsage().rss);
  }

  if (e.app?.free_memory&&typeof process.availableMemory=="function")
    {
      const t=process.availableMemory?.();

      if (t!=null) {
        (e.app.free_memory = t);
      }
    }

  if (e.device?.free_memory) {
    (e.device.free_memory = wt.freemem());
  }

  return e;
}async function BH(){const e=wt.platform();switch(e){case "darwin":
  {
    return KH();
  }case "linux":
  {
    return zH();
  }default:
  {
    return{name:jH[e]||e,version:wt.release()}
  }}}function HH(){try{if (typeof process.versions.icu!="string") {
  return;
}const e=new Date(900000000/* 9e8 */);if(new Intl.DateTimeFormat("es",{month:"long"}).format(e)==="enero"){const n=Intl.DateTimeFormat().resolvedOptions();return{locale:n.locale,timezone:n.timeZone}}}catch{}}function FH(){
  const e=process.memoryUsage().rss;
  const n={app_start_time:new Date(Date.now()-process.uptime()*1000/* 1e3 */).toISOString(),app_memory:e};
  if(typeof process.availableMemory=="function"){
    const r=process.availableMemory?.();

    if (r!=null) {
      (n.free_memory = r);
    }
  }return n
}function YH(e){
  const t={};let n;try{n=wt.uptime()}catch{}

  if (typeof n=="number") {
    (t.boot_time = new Date(Date.now()-n*1000/* 1e3 */).toISOString());
  }

  t.arch=wt.arch();

  if ((e===true || e.memory)) {
    t.memory_size=wt.totalmem();
    t.free_memory=wt.freemem();
  }

  if (e===true||e.cpu) {
    const r=wt.cpus();
    const o=r?.[0];

    if (o) {
      t.processor_count=r.length;
      t.cpu_description=o.model;
      t.processor_frequency=o.speed;
    }
  }

  return t
}
const jH={aix:"IBM AIX",freebsd:"FreeBSD",openbsd:"OpenBSD",sunos:"SunOS",win32:"Windows",ohos:"OpenHarmony",android:"Android"};
const qH=[{name:"fedora-release",distros:["Fedora"]},{name:"redhat-release",distros:["Red Hat Linux","Centos"]},{name:"redhat_version",distros:["Red Hat Linux"]},{name:"SuSE-release",distros:["SUSE Linux"]},{name:"lsb-release",distros:["Ubuntu Linux","Arch Linux"]},{name:"debian_version",distros:["Debian"]},{name:"debian_release",distros:["Debian"]},{name:"arch-release",distros:["Arch Linux"]},{name:"gentoo-release",distros:["Gentoo Linux"]},{name:"novell-release",distros:["SUSE Linux"]},{name:"alpine-release",distros:["Alpine Linux"]}];

const WH={alpine:e => e,arch:e => Tn(/distrib_release=(.*)/,e),centos:e => Tn(/release ([^ ]+)/,e),debian:e => e,fedora:e => Tn(/release (..)/,e),mint:e => Tn(/distrib_release=(.*)/,e),red:e => Tn(/release ([^ ]+)/,e),suse:e => Tn(/VERSION = (.*)\n/,e),ubuntu:e => Tn(/distrib_release=(.*)/,e)};

function Tn(e,t){const n=e.exec(t);return n?n[1]:void 0}async function KH(){const e={kernel_version:wt.release(),name:"Mac OS X",version:`10.${Number(wt.release().split(".")[0])-4}`};try{
  const t=await new Promise((n,r)=>{Tc.execFile("/usr/bin/sw_vers",(o,s)=>{if(o){r(o);return}n(s)})});
  e.name=Tn(/^ProductName:\s+(.*)$/m,t);
  e.version=Tn(/^ProductVersion:\s+(.*)$/m,t);
  e.build=Tn(/^BuildVersion:\s+(.*)$/m,t);
}catch{}return e}function nR(e){return e.split(" ")[0].toLowerCase()}async function zH(){const e={kernel_version:wt.release(),name:"Linux"};try{
  const t=await kH("/etc");

  const n=qH.find(a => t.includes(a.name));

  if (!n) {
    return e;
  }
  const r=ce.join("/etc",n.name);
  const o=(await UH(r,{encoding:"utf-8"})).toLowerCase();
  const {distros}=n;
  e.name=distros.find(a => o.includes(nR(a)))||distros[0];const i=nR(e.name);e.version=WH[i]?.(o)
}catch{}return e}function ZH(){
  if (process.env.VERCEL) {
    return {"cloud.provider":"vercel","cloud.region":process.env.VERCEL_REGION};
  }

  if (process.env.AWS_REGION) {
    return {"cloud.provider":"aws","cloud.region":process.env.AWS_REGION,"cloud.platform":process.env.AWS_EXECUTION_ENV};
  }

  if (process.env.GCP_PROJECT) {
    return {"cloud.provider":"gcp"};
  }

  if (process.env.ALIYUN_REGION_ID) {
    return {"cloud.provider":"alibaba_cloud","cloud.region":process.env.ALIYUN_REGION_ID};
  }

  if (process.env.WEBSITE_SITE_NAME&&process.env.REGION_NAME) {
    return {"cloud.provider":"azure","cloud.region":process.env.REGION_NAME};
  }

  if (process.env.IBM_CLOUD_REGION) {
    return {"cloud.provider":"ibm_cloud","cloud.region":process.env.IBM_CLOUD_REGION};
  }

  if (process.env.TENCENTCLOUD_REGION) {
    return {"cloud.provider":"tencent_cloud","cloud.region":process.env.TENCENTCLOUD_REGION,"cloud.account.id":process.env.TENCENTCLOUD_APPID,"cloud.availability_zone":process.env.TENCENTCLOUD_ZONE};
  }

  if (process.env.NETLIFY) {
    return {"cloud.provider":"netlify"};
  }

  if (process.env.FLY_REGION) {
    return {"cloud.provider":"fly.io","cloud.region":process.env.FLY_REGION};
  }

  if (process.env.DYNO) {
    return {"cloud.provider":"heroku"};
  }

  return void 0;
}
const Mp=new es(10);
const PM=new es(20);
const XH=7;
const QH="ContextLines";
const JH=1000/* 1e3 */;
const eF=10000/* 1e4 */;
function tF(e,t,n){const r=e.get(t);return r===void 0?(e.set(t,n),n):r}function nF(e){return!!(e.startsWith("node:")||e.endsWith(".min.js")||e.endsWith(".min.cjs")||e.endsWith(".min.mjs")||e.startsWith("data:"))}function rF(e){return e.lineno!==void 0&&e.lineno>eF||e.colno!==void 0&&e.colno>JH}function oF(e,t){const n=Mp.get(e);if (n===void 0) {
  return false;
}for (let r=t[0]; r<=t[1]; r++) {
  if (n[r]===void 0) {
    return false;
  }
}return true;}function sF(e,t){
  if (!e.length) {
    return[];
  }let n=0;const r=e[0];if (typeof r!="number") {
    return[];
  }let o=oR(r,t);const s=[];

  while (true) {
    if(n===e.length-1){s.push(o);break}const i=e[n+1];if (typeof i!="number") {
        break;
      }

    if (i<=o[1]) {
      o[1]=i+t;
    } else {
      s.push(o);
      o=oR(i,t);
    }

    n++;
  }

  return s
}function iF(e,t,n){return new Promise((r,o)=>{
  const s=de.createReadStream(e);
  const i=Lw.createInterface({input:s});
  function a(){
    s.destroy();
    r();
  }
  let c=0;
  let l=0;
  const f=t[l];if(f===void 0){a();return}
  let d=f[0];
  let u=f[1];
  function _(p){
    PM.set(e,1);

    if (Ie) {
      x.error(`Failed to read file: ${e}. Error: ${p}`);
    }

    i.close();
    i.removeAllListeners();
    a();
  }
  s.on("error",_);
  i.on("error",_);
  i.on("close",a);

  i.on("line",p=>{
    c++;

    if (!(c<d)&&(n[c]=pk(p,0),c>=u)) {
      if(l===t.length-1){
        i.close();
        i.removeAllListeners();
        return
      }l++;const E=t[l];if(E===void 0){
        i.close();
        i.removeAllListeners();
        return
      }
      d=E[0];
      u=E[1];
    }
  });
});}async function aF(e,t){
  const n={};if(t>0&&e.exception?.values){for (const s of e.exception.values) {
    if (s.stacktrace?.frames?.length) {
      for(let i=s.stacktrace.frames.length-1;i>=0;i--){
        const a=s.stacktrace.frames[i];
        const c=a?.filename;
        if (!a||typeof c!="string"||typeof a.lineno!="number"||nF(c)||rF(a)) {
          continue;
        }

        if (!n[c]) {
          (n[c] = []);
        }

        n[c].push(a.lineno);
      }
    }
  }}const r=Object.keys(n);if (r.length==0) {
    return e;
  }const o=[];for(const s of r){if (PM.get(s)) {
    continue;
  }const i=n[s];if (!i) {
    continue;
  }i.sort((l, f) => l-f);const a=sF(i,t);if (a.every(l => oF(s,l))) {
    continue;
  }const c=tF(Mp,s,{});o.push(iF(s,a,c))}
  await Promise.all(o).catch(()=>{
    if (Ie) {
      x.log("Failed to read one or more source files and resolve context lines");
    }
  });

  if (t>0&&e.exception?.values) {
    for (const s of e.exception.values) {
      if (s.stacktrace?.frames&&s.stacktrace.frames.length>0) {
        cF(s.stacktrace.frames,t,Mp);
      }
    }
  }

  return e
}function cF(e,t,n){for (const r of e) {
  if(r.filename&&r.context_line===void 0&&typeof r.lineno=="number"){const o=n.get(r.filename);if (o===void 0) {
    continue;
  }uF(r.lineno,r,t,o)}
}}function rR(e){
  delete e.pre_context;
  delete e.context_line;
  delete e.post_context;
}function uF(e,t,n,r){if(t.lineno===void 0||r===void 0){
  if (Ie) {
    x.error("Cannot resolve context for frame with no lineno or file contents");
  }

  return
}t.pre_context=[];for(let s=MM(e,n);s<e;s++){const i=r[s];if(i===void 0){
  rR(t);

  if (Ie) {
    x.error(`Could not find line ${s} in file ${t.filename}`);
  }

  return
}t.pre_context.push(i)}if(r[e]===void 0){
  rR(t);

  if (Ie) {
    x.error(`Could not find line ${e} in file ${t.filename}`);
  }

  return
}t.context_line=r[e];const o=vM(e,n);t.post_context=[];for(let s=e+1;s<=o;s++){const i=r[s];if (i===void 0) {
  break;
}t.post_context.push(i)}}function MM(e,t){return Math.max(1,e-t)}function vM(e,t){return e+t}function oR(e,t){return[MM(e,t),vM(e,t)]}
const lF=((e={})=>{const t=e.frameContextLines!==void 0?e.frameContextLines:XH;return{name:QH,processEvent(n){return aF(n,t)}}});
const dF=lF;
let Gc;async function LM(){if (Gc===void 0) {
  try{Gc=!!(await import("node:inspector")).url()}catch{Gc=false}
}return Gc}const Vc="__SENTRY_ERROR_LOCAL_VARIABLES__";function fF(e,t,n){
  let r=0;
  let o=5;
  let s=0;

  setInterval(()=>{
    if (s===0) {
      if (r>e) {
        o*=2;
        n(o);
        o>86400&&(o=86400);
        s=o;
      }
    } else {
      s-=1;
      s===0&&t();
    }

    r=0;
  },1000/* 1e3 */).unref();

  return ()=>{r+=1};
}function sR(e){return e!==void 0&&(e.length===0||e==="?"||e==="<anonymous>")}function wM(e,t){return e===t||`Object.${e}`===t||e===`Object.${t}`||sR(e)&&sR(t)}const _F="LyohIEBzZW50cnkvbm9kZS1jb3JlIDEwLjI5LjAgKDM1MjlkNDYpIHwgaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdCAqLwppbXBvcnR7U2Vzc2lvbiBhcyBlfWZyb20ibm9kZTppbnNwZWN0b3IvcHJvbWlzZXMiO2ltcG9ydHt3b3JrZXJEYXRhIGFzIHR9ZnJvbSJub2RlOndvcmtlcl90aHJlYWRzIjtjb25zdCBuPWdsb2JhbFRoaXMsaT17fTtjb25zdCBvPSJfX1NFTlRSWV9FUlJPUl9MT0NBTF9WQVJJQUJMRVNfXyI7Y29uc3QgYT10O2Z1bmN0aW9uIHMoLi4uZSl7YS5kZWJ1ZyYmZnVuY3Rpb24oZSl7aWYoISgiY29uc29sZSJpbiBuKSlyZXR1cm4gZSgpO2NvbnN0IHQ9bi5jb25zb2xlLG89e30sYT1PYmplY3Qua2V5cyhpKTthLmZvckVhY2goZT0+e2NvbnN0IG49aVtlXTtvW2VdPXRbZV0sdFtlXT1ufSk7dHJ5e3JldHVybiBlKCl9ZmluYWxseXthLmZvckVhY2goZT0+e3RbZV09b1tlXX0pfX0oKCk9PmNvbnNvbGUubG9nKCJbTG9jYWxWYXJpYWJsZXMgV29ya2VyXSIsLi4uZSkpfWFzeW5jIGZ1bmN0aW9uIGMoZSx0LG4saSl7Y29uc3Qgbz1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuZ2V0UHJvcGVydGllcyIse29iamVjdElkOnQsb3duUHJvcGVydGllczohMH0pO2lbbl09by5yZXN1bHQuZmlsdGVyKGU9PiJsZW5ndGgiIT09ZS5uYW1lJiYhaXNOYU4ocGFyc2VJbnQoZS5uYW1lLDEwKSkpLnNvcnQoKGUsdCk9PnBhcnNlSW50KGUubmFtZSwxMCktcGFyc2VJbnQodC5uYW1lLDEwKSkubWFwKGU9PmUudmFsdWU/LnZhbHVlKX1hc3luYyBmdW5jdGlvbiByKGUsdCxuLGkpe2NvbnN0IG89YXdhaXQgZS5wb3N0KCJSdW50aW1lLmdldFByb3BlcnRpZXMiLHtvYmplY3RJZDp0LG93blByb3BlcnRpZXM6ITB9KTtpW25dPW8ucmVzdWx0Lm1hcChlPT5bZS5uYW1lLGUudmFsdWU/LnZhbHVlXSkucmVkdWNlKChlLFt0LG5dKT0+KGVbdF09bixlKSx7fSl9ZnVuY3Rpb24gdShlLHQpe2UudmFsdWUmJigidmFsdWUiaW4gZS52YWx1ZT92b2lkIDA9PT1lLnZhbHVlLnZhbHVlfHxudWxsPT09ZS52YWx1ZS52YWx1ZT90W2UubmFtZV09YDwke2UudmFsdWUudmFsdWV9PmA6dFtlLm5hbWVdPWUudmFsdWUudmFsdWU6ImRlc2NyaXB0aW9uImluIGUudmFsdWUmJiJmdW5jdGlvbiIhPT1lLnZhbHVlLnR5cGU/dFtlLm5hbWVdPWA8JHtlLnZhbHVlLmRlc2NyaXB0aW9ufT5gOiJ1bmRlZmluZWQiPT09ZS52YWx1ZS50eXBlJiYodFtlLm5hbWVdPSI8dW5kZWZpbmVkPiIpKX1hc3luYyBmdW5jdGlvbiBsKGUsdCl7Y29uc3Qgbj1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuZ2V0UHJvcGVydGllcyIse29iamVjdElkOnQsb3duUHJvcGVydGllczohMH0pLGk9e307Zm9yKGNvbnN0IHQgb2Ygbi5yZXN1bHQpaWYodC52YWx1ZT8ub2JqZWN0SWQmJiJBcnJheSI9PT10LnZhbHVlLmNsYXNzTmFtZSl7Y29uc3Qgbj10LnZhbHVlLm9iamVjdElkO2F3YWl0IGMoZSxuLHQubmFtZSxpKX1lbHNlIGlmKHQudmFsdWU/Lm9iamVjdElkJiYiT2JqZWN0Ij09PXQudmFsdWUuY2xhc3NOYW1lKXtjb25zdCBuPXQudmFsdWUub2JqZWN0SWQ7YXdhaXQgcihlLG4sdC5uYW1lLGkpfWVsc2UgdC52YWx1ZSYmdSh0LGkpO3JldHVybiBpfWxldCBmOyhhc3luYyBmdW5jdGlvbigpe2NvbnN0IHQ9bmV3IGU7dC5jb25uZWN0VG9NYWluVGhyZWFkKCkscygiQ29ubmVjdGVkIHRvIG1haW4gdGhyZWFkIik7bGV0IG49ITE7dC5vbigiRGVidWdnZXIucmVzdW1lZCIsKCk9PntuPSExfSksdC5vbigiRGVidWdnZXIucGF1c2VkIixlPT57bj0hMCxhc3luYyBmdW5jdGlvbihlLHtyZWFzb246dCxkYXRhOntvYmplY3RJZDpufSxjYWxsRnJhbWVzOml9KXtpZigiZXhjZXB0aW9uIiE9PXQmJiJwcm9taXNlUmVqZWN0aW9uIiE9PXQpcmV0dXJuO2lmKGY/LigpLG51bGw9PW4pcmV0dXJuO2NvbnN0IGE9W107Zm9yKGxldCB0PTA7dDxpLmxlbmd0aDt0Kyspe2NvbnN0e3Njb3BlQ2hhaW46bixmdW5jdGlvbk5hbWU6byx0aGlzOnN9PWlbdF0sYz1uLmZpbmQoZT0+ImxvY2FsIj09PWUudHlwZSkscj0iZ2xvYmFsIiE9PXMuY2xhc3NOYW1lJiZzLmNsYXNzTmFtZT9gJHtzLmNsYXNzTmFtZX0uJHtvfWA6bztpZih2b2lkIDA9PT1jPy5vYmplY3Qub2JqZWN0SWQpYVt0XT17ZnVuY3Rpb246cn07ZWxzZXtjb25zdCBuPWF3YWl0IGwoZSxjLm9iamVjdC5vYmplY3RJZCk7YVt0XT17ZnVuY3Rpb246cix2YXJzOm59fX1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuY2FsbEZ1bmN0aW9uT24iLHtmdW5jdGlvbkRlY2xhcmF0aW9uOmBmdW5jdGlvbigpIHsgdGhpcy4ke299ID0gdGhpcy4ke299IHx8ICR7SlNPTi5zdHJpbmdpZnkoYSl9OyB9YCxzaWxlbnQ6ITAsb2JqZWN0SWQ6bn0pLGF3YWl0IGUucG9zdCgiUnVudGltZS5yZWxlYXNlT2JqZWN0Iix7b2JqZWN0SWQ6bn0pfSh0LGUucGFyYW1zKS50aGVuKGFzeW5jKCk9PntuJiZhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLnJlc3VtZSIpfSxhc3luYyBlPT57biYmYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5yZXN1bWUiKX0pfSksYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5lbmFibGUiKTtjb25zdCBpPSExIT09YS5jYXB0dXJlQWxsRXhjZXB0aW9ucztpZihhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLnNldFBhdXNlT25FeGNlcHRpb25zIix7c3RhdGU6aT8iYWxsIjoidW5jYXVnaHQifSksaSl7Y29uc3QgZT1hLm1heEV4Y2VwdGlvbnNQZXJTZWNvbmR8fDUwO2Y9ZnVuY3Rpb24oZSx0LG4pe2xldCBpPTAsbz01LGE9MDtyZXR1cm4gc2V0SW50ZXJ2YWwoKCk9PnswPT09YT9pPmUmJihvKj0yLG4obyksbz44NjQwMCYmKG89ODY0MDApLGE9byk6KGEtPTEsMD09PWEmJnQoKSksaT0wfSwxZTMpLnVucmVmKCksKCk9PntpKz0xfX0oZSxhc3luYygpPT57cygiUmF0ZS1saW1pdCBsaWZ0ZWQuIiksYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5zZXRQYXVzZU9uRXhjZXB0aW9ucyIse3N0YXRlOiJhbGwifSl9LGFzeW5jIGU9PntzKGBSYXRlLWxpbWl0IGV4Y2VlZGVkLiBEaXNhYmxpbmcgY2FwdHVyaW5nIG9mIGNhdWdodCBleGNlcHRpb25zIGZvciAke2V9IHNlY29uZHMuYCksYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5zZXRQYXVzZU9uRXhjZXB0aW9ucyIse3N0YXRlOiJ1bmNhdWdodCJ9KX0pfX0pKCkuY2F0Y2goZT0+e3MoIkZhaWxlZCB0byBzdGFydCBkZWJ1Z2dlciIsZSl9KSxzZXRJbnRlcnZhbCgoKT0+e30sMWU0KTs=";function iR(...e){x.log("[LocalVariables]",...e)}const pF=((e={})=>{function t(s,i){const a=(s.stacktrace?.frames||[]).filter(c => c.function!=="new Promise");for(let c=0;c<a.length;c++){
  const l=a.length-c-1;
  const f=i[c];
  const d=a[l];
  if (!d||!f) {
    break;
  }

  if (f.vars !== void 0 && (d.in_app !== false || e.includeOutOfAppFrames === true) && wM(d.function,f.function)) {
    (d.vars = f.vars);
  }
}}function n(s,i){if(i.originalException&&typeof i.originalException=="object"&&Vc in i.originalException&&Array.isArray(i.originalException[Vc])){for (const a of s.exception?.values||[]) {
  t(a,i.originalException[Vc]);
}i.originalException[Vc]=void 0}return s}async function r(){
  const s=await import("node:inspector");

  if (!s.url()) {
    s.open(0);
  }
}function o(s){
  const i=new Ku.Worker(new URL(`data:application/javascript;base64,${_F}`),{workerData:s,execArgv:[],env:{...process.env,NODE_OPTIONS:void 0}});
  process.on("exit",()=>{i.terminate()});
  i.once("error",a=>{iR("Worker error",a)});
  i.once("exit",a=>{iR("Worker exit",a)});
  i.unref();
}return {name:"LocalVariablesAsync",async setup(s){if (!s.getOptions().includeLocalVariables) {
  return;
}if(await LM()){x.warn("Local variables capture has been disabled because the debugger was already enabled");return}const a={...e,debug:x.isEnabled()};r().then(()=>{try{o(a)}catch(c){x.error("Failed to start worker",c)}},c=>{x.error("Failed to start inspector",c)})},processEvent(s,i){return n(s,i)}};});function DM(e){if (e!==void 0) {
  return e.slice(-10).reduce((t, n) => `${t},${n.function},${n.lineno},${n.colno}`,"");
}}function EF(e,t){if (t!==void 0) {
  return DM(e(t,1))
}}function UM(e){
  let t=[];
  let n=false;
  function r(i){
    t=[];

    if (!n) {
      n=true;
      e(i);
    }
  }t.push(r);function o(i){t.push(i)}function s(i){const a=t.pop()||r;try{a(i)}catch{r(i)}}return{add:o,next:s}
}class WE{constructor(t){this._session=t}static async create(t){if (t) {
  return t;
}const n=await import("node:inspector");return new WE(new n.Session)}configureAndConnect(t,n){
  this._session.connect();
  this._session.on("Debugger.paused",r=>{t(r,()=>{this._session.post("Debugger.resume")})});
  this._session.post("Debugger.enable");
  this._session.post("Debugger.setPauseOnExceptions",{state:n?"all":"uncaught"});
}setPauseOnExceptions(t){this._session.post("Debugger.setPauseOnExceptions",{state:t?"all":"uncaught"})}getLocalVariables(t,n){this._getProperties(t,r=>{const{add,next}=UM(n);for (const i of r) {
  if(i.value?.objectId&&i.value.className==="Array"){const a=i.value.objectId;add(c => this._unrollArray(a,i.name,c,next))}else if (i.value?.objectId&&i.value.className==="Object") {const a=i.value.objectId;add(c => this._unrollObject(a,i.name,c,next))} else {
    if (i.value) {
      add(a => this._unrollOther(i,a,next));
    }
  }
}next({})})}_getProperties(t,n){this._session.post("Runtime.getProperties",{objectId:t,ownProperties:true},(r,o)=>{n(r?[]:o.result)})}_unrollArray(t,n,r,o){this._getProperties(t,s=>{
  r[n]=s.filter(i => i.name!=="length"&&!isNaN(parseInt(i.name,10))).sort((i, a) => parseInt(i.name,10)-parseInt(a.name,10)).map(i => i.value?.value);

  o(r);
})}_unrollObject(t,n,r,o){this._getProperties(t,s=>{
  r[n]=s.map(i => [i.name,i.value?.value]).reduce((i, [a,c]) => {
    i[a]=c;
    return i;
  },{});

  o(r);
})}_unrollOther(t,n,r){
  if (t.value) {
    if ("value"in t.value) {
      if (t.value.value===void 0||t.value.value===null) {
        n[t.name]=`<${t.value.value}>`;
      } else {
        n[t.name]=t.value.value;
      }
    } else if ("description"in t.value&&t.value.type!=="function") {
      n[t.name]=`<${t.value.description}>`;
    } else if (t.value.type==="undefined") {
      (n[t.name] = "<undefined>");
    }
  }

  r(n);
}}
const hF="LocalVariables";

const TF=((e={},t)=>{
  const n=new es(20);
  let r;
  let o=false;
  function s(l){const f=DM(l.stacktrace?.frames);if (f===void 0) {
    return;
  }const d=n.remove(f);if (d===void 0) {
    return;
  }const u=(l.stacktrace?.frames||[]).filter(_ => _.function!=="new Promise");for(let _=0;_<u.length;_++){
    const p=u.length-_-1;
    const E=d[_];
    const h=u[p];
    if (!h||!E) {
      break;
    }

    if (E.vars !== void 0 && (h.in_app !== false || e.includeOutOfAppFrames === true) && wM(h.function,E.function)) {
      (h.vars = E.vars);
    }
  }}function i(l){for (const f of l.exception?.values||[]) {
    s(f);
  }return l}let a;async function c(){const f=he()?.getOptions();if (!f?.includeLocalVariables) {
    return;
  }if(Do<18){x.log("The `LocalVariables` integration is only supported on Node >= v18.");return}if(await LM()){x.warn("Local variables capture has been disabled because the debugger was already enabled");return}try{
    const u=await WE.create(t);

    const _=(E,{params:{reason:h,data:T,callFrames:m}},A)=>{if(h!=="exception"&&h!=="promiseRejection"){A();return}r?.();const g=EF(E,T.description);if(g==null){A();return}const{add,next}=UM(I=>{
      n.set(g,I);
      A();
    });for(let I=0;I<Math.min(m.length,5);I++){
      const {scopeChain,functionName,this: _this}=m[I];

      const q=scopeChain.find($ => $.type==="local");

      const H=_this.className==="global"||!_this.className?functionName:`${_this.className}.${functionName}`;
      if (q?.object.objectId===void 0) {
        add($=>{
          $[I]={function:H};
          next($);
        });
      } else {const $=q.object.objectId;add(B => u.getLocalVariables($,F=>{
        B[I]={function:H,vars:F};
        next(B);
      }))}
    }next([])};

    const p=e.captureAllExceptions!==false;

    u.configureAndConnect((E, h) => _(f.stackParser,E,h),p);

    if (p) {const E=e.maxExceptionsPerSecond||50;r=fF(E,()=>{
      x.log("Local variables rate-limit lifted.");
      u.setPauseOnExceptions(true);
    },h=>{
      x.log(`Local variables rate-limit exceeded. Disabling capturing of caught exceptions for ${h} seconds.`);
      u.setPauseOnExceptions(false);
    })}

    o=true
  }catch(u){x.log("The `LocalVariables` integration failed to start.",u)}}return {name:hF,setupOnce(){a=c()},async processEvent(l){
    await a;
    return o?i(l):l;
  },_getCachedFramesCount(){return n.size},_getFirstCachedFrame(){return n.values()[0]}};
});

const SF=TF;

const mF=(e={}) => bl.major<19?SF(e):pF(e);

function KE(){try{return typeof module !== "undefined"&&typeof module.exports !== "undefined";}catch{return false;}}let aR;function AF(){return KE()?false:Do>=21||Do===20&&Ip>=6||Do===18&&Ip>=19?true:(aR||(aR=true,an(()=>{console.warn(`[Sentry] You are using Node.js v${process.versions.node} in ESM mode ("import syntax"). The Sentry Node.js SDK is not compatible with ESM in Node.js versions before 18.19.0 or before 20.6.0. Please either build your application with CommonJS ("require() syntax"), or upgrade your Node.js version.`)})),false);}let Pd;
const gF="Modules";
const RF=typeof __SENTRY_SERVER_MODULES__ === "undefined"?{}:__SENTRY_SERVER_MODULES__;

const NF=(() => ({
  name:gF,

  processEvent(e){
    e.modules={...e.modules,...cR()};
    return e;
  },

  getModules:cR
}));

const yF=NF;
function OF(){try{return require.cache?Object.keys(require.cache):[]}catch{return[]}}function bF(){return {...RF,...PF(),...(KE() ? CF() : {})};}function CF(){
  const e=require.main?.paths||[];
  const t=OF();
  const n={};
  const r=new Set;

  t.forEach(o=>{let s=o;const i=()=>{
    const a=s;
    s=ce.dirname(a);

    if (!s||a===s||r.has(a)) {
      return;
    }

    if (!e.includes(s)) {
      return i();
    }const c=ce.join(a,"package.json");
    r.add(a);

    if (!de.existsSync(c)) {
      return i();
    }

    try{const l=JSON.parse(de.readFileSync(c,"utf8"));n[l.name]=l.version}catch{}
  };i()});

  return n;
}function cR(){
  if (!Pd) {
    (Pd = bF());
  }

  return Pd;
}function IF(){try{const e=ce.join(process.cwd(),"package.json");return JSON.parse(de.readFileSync(e,"utf8"))}catch{return{}}}function PF(){const e=IF();return{...e.dependencies,...e.devDependencies}}const MF=2000/* 2e3 */;function vp(e){
  an(()=>{console.error(e)});const t=he();if(t===void 0){
  if (Ie) {
    x.warn("No NodeClient was defined, we are exiting the process now.");
  }

  global.process.exit(1);
  return
}
  const n=t.getOptions();
  const r=n?.shutdownTimeout&&n.shutdownTimeout>0?n.shutdownTimeout:MF;
  t.close(r).then(o=>{
    if (!o) {
      if (Ie) {
        x.warn("We reached the timeout for emptying the request buffer, still exiting now!");
      }
    }

    global.process.exit(1);
  },o=>{
    if (Ie) {
      x.error(o);
    }
  })
}
const vF="OnUncaughtException";
const LF=(e={})=>{const t={exitEvenIfOtherHandlersAreRegistered:false,...e};return{name:vF,setup(n){global.process.on("uncaughtException",wF(n,t))}}};
function wF(e,t){
  let r=false;
  let o=false;
  let s=false;
  let i;
  const a=e.getOptions();return Object.assign(c=>{
  let l=vp;

  if (t.onFatalError) {
    l=t.onFatalError;
  } else if (a.onFatalError) {
    (l = a.onFatalError);
  }

  const d=global.process.listeners("uncaughtException").filter(_ => _.name!=="domainUncaughtExceptionClear"&&_.tag!=="sentry_tracingErrorCallback"&&_._errorHandler!==true).length===0;

  const u=t.exitEvenIfOtherHandlersAreRegistered||d;

  if (r) {
    if (u) {
      if (s) {
        Ie&&x.warn("uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown");
        vp(c);
      } else if (!o) {
        o=true;

        setTimeout(()=>{
          if (!s) {
            s=true;
            l(i,c);
          }
        },2000/* 2e3 */);
      }
    }
  } else {
    i=c;
    r=true;
    he()===e&&xe(c,{originalException:c,captureContext:{level:"fatal"},mechanism:{handled:false,type:"auto.node.onuncaughtexception"}});
    !s&&u&&(s=true,l(c));
  }
},{_errorHandler:true});
}
const DF="OnUnhandledRejection";
const UF=[{name:"AI_NoOutputGeneratedError"}];
const kF=((e={})=>{const t={mode:e.mode??"warn",ignore:[...UF,...(e.ignore ?? [])]};return{name:DF,setup(n){global.process.on("unhandledRejection",BF(n,t))}}});
const GF=kF;
function VF(e){
  if (typeof e!="object"||e===null) {
    return{name:"",message:String(e??"")};
  }
  const t=e;
  const n=typeof t.name=="string"?t.name:"";
  const r=typeof t.message=="string"?t.message:String(e);
  return{name:n,message:r}
}function xF(e,t){
  const n=e.name===void 0||Lo(t.name,e.name,true);
  const r=e.message===void 0||Lo(t.message,e.message);
  return n&&r
}function $F(e,t){const n=VF(t);return e.some(r => xF(r,n));}function BF(e,t){return (r, o) => {
  if (he()!==e||$F(t.ignore??[],r)) {
    return;
  }
  const s=t.mode==="strict"?"fatal":"error";
  const i=r&&typeof r=="object"?r._sentry_active_span:void 0;

  (i?c => iP(i,c):c => c())(()=>{xe(r,{originalException:o,captureContext:{extra:{unhandledPromiseRejection:true},level:s},mechanism:{handled:false,type:"auto.node.onunhandledrejection"}})});

  HF(r,t.mode);
};}function HF(e,t){
  const n="This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason:";

  if (t==="warn") {
    an(()=>{
      console.warn(n);
      console.error(e&&typeof e=="object"&&"stack"in e?e.stack:e);
    });
  } else if (t==="strict") {
    an(()=>{console.warn(n)});
    vp(e);
  }
}
const kM="Spotlight";
const FF=((e={})=>{const t={sidecarUrl:e.sidecarUrl||"http://localhost:8969/stream"};return {name:kM,setup(n){try{
  if (process.env.NODE_ENV&&process.env.NODE_ENV!=="development") {
    x.warn("[Spotlight] It seems you're not in dev mode. Do you really want to have Spotlight enabled?");
  }
}catch{}jF(n,t)}};});
const YF=FF;
function jF(e,t){const n=qF(t.sidecarUrl);if (!n) {
  return;
}let r=0;e.on("beforeEnvelope",o=>{if(r>3){x.warn("[Spotlight] Disabled Sentry -> Spotlight integration due to too many failed requests");return}const s=tP(o);aP(()=>{
  const i=su.request({method:"POST",path:n.pathname,hostname:n.hostname,port:n.port,headers:{"Content-Type":"application/x-sentry-envelope"}},a=>{
    if (a.statusCode&&a.statusCode>=200&&a.statusCode<400) {
      (r = 0);
    }

    a.on("data",()=>{});
    a.on("end",()=>{});
    a.setEncoding("utf8");
  });

  i.on("error",()=>{
    r++;
    x.warn("[Spotlight] Failed to send envelope to Spotlight Sidecar");
  });

  i.write(s);
  i.end();
})})}function qF(e){try{return new URL(`${e}`)}catch{x.warn(`[Spotlight] Invalid sidecar URL: ${e}`);return}}const WF="NodeSystemError";function KF(e){return !(e instanceof Error)||!("errno"in e)||typeof e.errno!="number"?false:Vw.getSystemErrorMap().has(e.errno);}

const zF=(e={}) => ({
  name:WF,

  processEvent:(t,n,r)=>{
    if (!KF(n.originalException)) {
      return t;
    }
    const o=n.originalException;
    const s={...o};

    if (!r.getOptions().sendDefaultPii&&e.includePaths!==true) {
      delete s.path;
      delete s.dest;
    }

    t.contexts={...t.contexts,node_system_error:s};
    for (const i of t.exception?.values||[]) {
      if (i.value) {
        o.path&&i.value.includes(o.path)&&(i.value=i.value.replace(`'${o.path}'`,"").trim());
        o.dest&&i.value.includes(o.dest)&&(i.value=i.value.replace(`'${o.dest}'`,"").trim());
      }
    }return t
  }
});

const ZF="ChildProcess";

const XF=(e={}) => ({
  name:ZF,

  setup(){
    ou.channel("child_process").subscribe(t=>{
      if (t&&typeof t=="object"&&"process"in t) {
        QF(t.process,e);
      }
    });
    ou.channel("worker_threads").subscribe(t=>{
      if (t&&typeof t=="object"&&"worker"in t) {
        JF(t.worker,e);
      }
    });
  }
});

function QF(e,t){
  let n=false;
  let r;
  e.on("spawn",()=>{
    if(e.spawnfile==="/usr/bin/sw_vers"){n=true;return}
    r={spawnfile:e.spawnfile};

    if (t.includeChildProcessArgs) {
      (r.spawnargs = e.spawnargs);
    }
  }).on("exit",o=>{
    if (!n) {
      n=true;
      o!==null&&o!==0&&Bo({category:"child_process",message:`Child process exited with code '${o}'`,level:o===0?"info":"warning",data:r});
    }
  }).on("error",o=>{
    if (!n) {
      n=true;
      Bo({category:"child_process",message:`Child process errored with '${o.message}'`,level:"error",data:r});
    }
  })
}function JF(e,t){let n;e.on("online",()=>{n=e.threadId}).on("error",r=>{
  if (t.captureWorkerErrors!==false) {
    xe(r,{mechanism:{type:"auto.child_process.worker_thread",handled:false,data:{threadId:String(n)}}});
  } else {
    Bo({category:"worker_thread",message:`Worker thread errored with '${r.message}'`,level:"error",data:{threadId:n}});
  }
})}
const Md={};
const oa={};
const sa={};
let uR;
function GM(...args) {
  if (uR) {
    return sa;
  }
  uR=1;
  Object.defineProperty(sa,"__esModule",{value:true});
  sa.AbstractAsyncHooksContextManager=void 0;
  const e=zu;
  const t=["addListener","on","once","prependListener","prependOnceListener"];
  let n=class{bind(o,s){return s instanceof e.EventEmitter?this._bindEventEmitter(o,s):typeof s=="function"?this._bindFunction(o,s):s}_bindFunction(o,s){
    const i=this;

    const a=function(...c){return i.with(o,() => s.apply(this,c));};

    Object.defineProperty(a,"length",{enumerable:false,configurable:true,writable:false,value:s.length});
    return a;
  }_bindEventEmitter(o,s){
    if (this._getPatchMap(s) === void 0) {
      this._createPatchMap(s);

      t.forEach(a=>{
        if (s[a]!==void 0) {
          (s[a] = this._patchAddListener(s,s[a],o));
        }
      });

      typeof s.removeListener=="function"&&(s.removeListener=this._patchRemoveListener(s,s.removeListener));
      typeof s.off=="function"&&(s.off=this._patchRemoveListener(s,s.off));
      typeof s.removeAllListeners=="function"&&(s.removeAllListeners=this._patchRemoveAllListeners(s,s.removeAllListeners));
    }

    return s;
  }_patchRemoveListener(o,s){const i=this;return function(a,c){const l=i._getPatchMap(o)?.[a];if (l===void 0) {
    return s.call(this,a,c);
  }const f=l.get(c);return s.call(this,a,f||c)};}_patchRemoveAllListeners(o,s){const i=this;return function(a){
    const c=i._getPatchMap(o);

    if (c!==void 0) {
      if (args.length===0) {
        i._createPatchMap(o);
      } else if (c[a]!==void 0) {
        delete c[a];
      }
    }

    return s.apply(this,args);
  };}_patchAddListener(o,s,i){const a=this;return function(c,l){
    if (a._wrapped) {
      return s.call(this,c,l);
    }let f=a._getPatchMap(o);

    if (f===void 0) {
      (f = a._createPatchMap(o));
    }

    let d=f[c];

    if (d===void 0) {
      d=new WeakMap;
      f[c]=d;
    }

    const u=a.bind(i,l);
    d.set(l,u);
    a._wrapped=true;
    try{return s.call(this,c,u)}finally{a._wrapped=false}
  };}_createPatchMap(o){
    const s=Object.create(null);
    o[this._kOtListeners]=s;
    return s;
  }_getPatchMap(o){return o[this._kOtListeners]}_kOtListeners=Symbol("OtListeners");_wrapped=false};
  sa.AbstractAsyncHooksContextManager=n;
  return sa;
}let lR;function eY(){
  if (lR) {
    return oa;
  }
  lR=1;
  Object.defineProperty(oa,"__esModule",{value:true});
  oa.AsyncHooksContextManager=void 0;
  const e=Pe();
  const t=HC;
  const n=GM();
  let r=class extends n.AbstractAsyncHooksContextManager{_asyncHook;_contexts=new Map;_stack=[];constructor(){
    super();
    this._asyncHook=t.createHook({init:this._init.bind(this),before:this._before.bind(this),after:this._after.bind(this),destroy:this._destroy.bind(this),promiseResolve:this._destroy.bind(this)});
  }active(){return this._stack[this._stack.length-1]??e.ROOT_CONTEXT}with(s,i,a,...c){this._enterContext(s);try{return i.call(a,...c)}finally{this._exitContext()}}enable(){
    this._asyncHook.enable();
    return this;
  }disable(){
    this._asyncHook.disable();
    this._contexts.clear();
    this._stack=[];
    return this;
  }_init(s,i){
    if (i==="TIMERWRAP") {
      return;
    }const a=this._stack[this._stack.length-1];

    if (a!==void 0) {
      this._contexts.set(s,a);
    }
  }_destroy(s){this._contexts.delete(s)}_before(s){
    const i=this._contexts.get(s);

    if (i!==void 0) {
      this._enterContext(i);
    }
  }_after(){this._exitContext()}_enterContext(s){this._stack.push(s)}_exitContext(){this._stack.pop()}};
  oa.AsyncHooksContextManager=r;
  return oa;
}
const ia={};
let dR;
function tY(){
  if (dR) {
    return ia;
  }
  dR=1;
  Object.defineProperty(ia,"__esModule",{value:true});
  ia.AsyncLocalStorageContextManager=void 0;
  const e=Pe();
  const t=HC;
  const n=GM();
  let r=class extends n.AbstractAsyncHooksContextManager{_asyncLocalStorage;constructor(){
    super();
    this._asyncLocalStorage=new t.AsyncLocalStorage;
  }active(){return this._asyncLocalStorage.getStore()??e.ROOT_CONTEXT}with(s,i,a,...c){const l=a==null?i:i.bind(a);return this._asyncLocalStorage.run(s,l,...c)}enable(){return this}disable(){
    this._asyncLocalStorage.disable();
    return this;
  }};
  ia.AsyncLocalStorageContextManager=r;
  return ia;
}let fR;function nY(){
  if (!fR) {
    fR=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.AsyncLocalStorageContextManager = void 0;
      e.AsyncHooksContextManager = void 0;
      const t=eY();Object.defineProperty(e,"AsyncHooksContextManager",{enumerable:true,get() {return t.AsyncHooksContextManager}});const n=tY();Object.defineProperty(e,"AsyncLocalStorageContextManager",{enumerable:true,get() {return n.AsyncLocalStorageContextManager}})
    })(Md);
  }

  return Md;
}const rY=nY();const oY=iH(rY.AsyncLocalStorageContextManager);function sY(){
  C.diag.disable();
  C.diag.setLogger({error:x.error,warn:x.warn,info:x.log,debug:x.log,verbose:x.log},C.DiagLogLevel.DEBUG);
}
const iY="ProcessSession";

const aY=() => ({
  name:iY,

  setupOnce(){
    Q1();
    process.on("beforeExit",()=>{
      if (je().getSession()?.status!=="ok") {
        fP();
      }
    });
  }
});

const _n=Symbol("AgentBaseInternalState");
class cY extends su.Agent{constructor(t){
  super(t);
  this[_n]={};
}isSecureEndpoint(t){if(t){if (typeof t.secureEndpoint=="boolean") {
  return t.secureEndpoint;
}if (typeof t.protocol=="string") {
  return t.protocol==="https:"
}}const{stack}=new Error;return typeof stack!="string"?false:stack.split(`
`).some(r => r.includes("(https.js:")||r.includes("node:https:"));}createSocket(t,n,r){const o={...n,secureEndpoint:this.isSecureEndpoint(n)};Promise.resolve().then(() => this.connect(t,o)).then(s=>{
  if (s instanceof su.Agent) {
    return s.addRequest(t,o);
  }
  this[_n].currentSocket=s;
  super.createSocket(t,n,r);
},r)}createConnection(){
  const t=this[_n].currentSocket;
  this[_n].currentSocket=void 0;

  if (!t) {
    throw new Error("No socket was returned in the `connect()` function");
  }

  return t
}get defaultPort(){return this[_n].defaultPort??(this.protocol==="https:"?443:80)}set defaultPort(t){
  if (this[_n]) {
    (this[_n].defaultPort = t);
  }
}get protocol(){return this[_n].protocol??(this.isSecureEndpoint()?"https:":"http:")}set protocol(t){
  if (this[_n]) {
    (this[_n].protocol = t);
  }
}}function xc(...e){x.log("[https-proxy-agent:parse-proxy-response]",...e)}function uY(e){return new Promise((t,n)=>{
  let r=0;const o=[];function s(){
  const f=e.read();

  if (f) {
    l(f);
  } else {
    e.once("readable",s);
  }
}function i(){
    e.removeListener("end",a);
    e.removeListener("error",c);
    e.removeListener("readable",s);
  }function a(){
    i();
    xc("onend");
    n(new Error("Proxy connection ended before receiving CONNECT response"));
  }function c(f){
    i();
    xc("onerror %o",f);
    n(f);
  }function l(f){
    o.push(f);
    r+=f.length;
    const d=Buffer.concat(o,r);

    const u=d.indexOf(`\r
    \r
    `);

    if(u===-1){
      xc("have not received end of HTTP headers yet...");
      s();
      return
    }

    const _=d.subarray(0,u).toString("ascii").split(`\r
    `);

    const p=_.shift();
    if (!p) {
      e.destroy();
      return n(new Error("No header received from proxy CONNECT response"));
    }
    const E=p.split(" ");
    const h=+(E[1]||0);
    const T=E.slice(2).join(" ");
    const m={};
    for(const A of _){
      if (!A) {
        continue;
      }const g=A.indexOf(":");if (g===-1) {
          e.destroy();
          return n(new Error(`Invalid header from proxy CONNECT response: "${A}"`));
        }
      const R=A.slice(0,g).toLowerCase();
      const O=A.slice(g+1).trimStart();
      const I=m[R];

      if (typeof I=="string") {
        m[R]=[I,O];
      } else if (Array.isArray(I)) {
        I.push(O);
      } else {
        m[R]=O;
      }
    }
    xc("got proxy server response: %o %o",p,m);
    i();
    t({connect:{statusCode:h,statusText:T,headers:m},buffered:d});
  }
  e.on("error",c);
  e.on("end",a);
  s();
});}function aa(...e){x.log("[https-proxy-agent]",...e)}class VM extends cY{static __initStatic(){this.protocols=["http","https"]}constructor(t,n){
  super(n);
  this.options={};
  this.proxy=typeof t=="string"?new URL(t):t;
  this.proxyHeaders=n?.headers??{};
  aa("Creating new HttpsProxyAgent instance: %o",this.proxy.href);
  const r=(this.proxy.hostname||this.proxy.host).replace(/^\[|\]$/g,"");
  const o=this.proxy.port?parseInt(this.proxy.port,10):this.proxy.protocol==="https:"?443:80;
  this.connectOpts={ALPNProtocols:["http/1.1"],...(n ? _R(n,"headers") : null),host:r,port:o}
}async connect(t,n){
  const{proxy}=this;if (!n.host) {
      throw new TypeError('No "host" provided');
    }let o;if (proxy.protocol==="https:")
      {aa("Creating `tls.Socket`: %o",this.connectOpts);const u=this.connectOpts.servername||this.connectOpts.host;o=em.connect({...this.connectOpts,servername:u&&No.isIP(u)?void 0:u})} else {
      aa("Creating `net.Socket`: %o",this.connectOpts);
      o=No.connect(this.connectOpts);
    }
  const s=typeof this.proxyHeaders=="function"?this.proxyHeaders():{...this.proxyHeaders};
  const i=No.isIPv6(n.host)?`[${n.host}]`:n.host;
  let a=`CONNECT ${i}:${n.port} HTTP/1.1\r
  `;if(proxy.username||proxy.password){const u=`${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;s["Proxy-Authorization"]=`Basic ${Buffer.from(u).toString("base64")}`}
  s.Host=`${i}:${n.port}`;

  if (!s["Proxy-Connection"]) {
    (s["Proxy-Connection"] = this.keepAlive?"Keep-Alive":"close");
  }

  for (const u of Object.keys(s)) {
    a+=`${u}: ${s[u]}\r
    `;
  }const c=uY(o);o.write(`${a}\r
    `);const{connect,buffered}=await c;
  t.emit("proxyConnect",connect);
  this.emit("proxyConnect",connect,t);

  if (connect.statusCode===200) {
    t.once("socket",lY);

    if (n.secureEndpoint)
      {aa("Upgrading socket connection to TLS");const u=n.servername||n.host;return em.connect({..._R(n,"host","path","port"),socket:o,servername:No.isIP(u)?void 0:u})}

    return o
  }

  o.destroy();const d=new No.Socket({writable:false});
  d.readable=true;

  t.once("socket",u=>{
    aa("Replaying proxy buffer for failed request");
    u.push(buffered);
    u.push(null);
  });

  return d;
}}VM.__initStatic();function lY(e){e.resume()}function _R(e,...t){const n={};let r;for (r in e) {
  if (!t.includes(r)) {
    (n[r] = e[r]);
  }
}return n}const dY=1024*32;function fY(e){return new Uw.Readable({read(){
  this.push(e);
  this.push(null);
}});}function _Y(e){
  let t;try{t=new URL(e.url)}catch{
    an(()=>{console.warn("[@sentry/node]: Invalid dsn or tunnel option, will not send any events. The tunnel option must be a full URL when used.")});

    return fg(e,() => Promise.resolve({}));
  }
  const n=t.protocol==="https:";
  const r=pY(t,e.proxy||(n?process.env.https_proxy:void 0)||process.env.http_proxy);
  const o=n?$w:su;
  const s=e.keepAlive===void 0?false:e.keepAlive;
  const i=r?new VM(r):new o.Agent({keepAlive:s,maxSockets:30,timeout:2000/* 2e3 */});
  const a=EY(e,e.httpModule??o,i);
  return fg(e,a)
}function pY(e,t){const{no_proxy}=process.env;if (!no_proxy?.split(",").some(o => e.host.endsWith(o)||e.hostname.endsWith(o))) {
  return t
}}function EY(e,t,n){const{hostname,pathname,port,protocol,search}=new URL(e.url);return l => new Promise((f,d)=>{aP(()=>{
  let u=fY(l.body);const _={...e.headers};

  if (l.body.length>dY) {
    _["content-encoding"]="gzip";
    u=u.pipe(kw.createGzip());
  }

  const p=t.request({method:"POST",agent:n,headers:_,hostname:hostname,path:`${pathname}${search}`,port:port,protocol:protocol,ca:e.caCerts},E=>{
      E.on("data",()=>{});
      E.on("end",()=>{});
      E.setEncoding("utf8");
      const h=E.headers["retry-after"]??null;
      const T=E.headers["x-sentry-rate-limits"]??null;
      f({statusCode:E.statusCode,headers:{"retry-after":h,"x-sentry-rate-limits":Array.isArray(T)?T[0]||null:T}})
    });
  p.on("error",d);
  u.pipe(p);
})});}
const hY=new Set(["false","f","n","no","off","0"]);
const TY=new Set(["true","t","y","yes","on","1"]);
function Lp(e,t){const n=String(e).toLowerCase();return hY.has(n)?false:TY.has(n)?true:t?.strict?null:!!e;}function pR(e){return e.replace(/^[A-Z]:/,"").replace(/\\/g,"/");}function SY(e=process.argv[1]?kV(process.argv[1]):process.cwd(),t=ce.sep==="\\"){const n=t?pR(e):e;return r=>{
  if (!r) {
    return;
  }const o=t?pR(r):r;let{dir,base,ext}=ce.posix.parse(o);

  if ((ext===".js"||ext===".mjs" || ext===".cjs")) {
    (base = base.slice(0,ext.length*-1));
  }

  const c=decodeURIComponent(base);

  if (!dir) {
    (dir = ".");
  }

  const l=dir.lastIndexOf("/node_modules");if (l>-1) {
    return `${dir.slice(l+14).replace(/\//g,".")}:${c}`;
  }if(dir.startsWith(n)){const f=dir.slice(n.length+1).replace(/\//g,".");return f?`${f}:${c}`:c}return c
};}function mY(e){
  if (process.env.SENTRY_RELEASE) {
    return process.env.SENTRY_RELEASE;
  }if (ye.SENTRY_RELEASE?.id) {
    return ye.SENTRY_RELEASE.id;
  }
  const t=process.env.GITHUB_SHA||process.env.CI_MERGE_REQUEST_SOURCE_BRANCH_SHA||process.env.CI_BUILD_REF||process.env.CI_COMMIT_SHA||process.env.BITBUCKET_COMMIT;
  const n=process.env.APPVEYOR_PULL_REQUEST_HEAD_COMMIT||process.env.APPVEYOR_REPO_COMMIT||process.env.CODEBUILD_RESOLVED_SOURCE_VERSION||process.env.AWS_COMMIT_ID||process.env.BUILD_SOURCEVERSION||process.env.GIT_CLONE_COMMIT_HASH||process.env.BUDDY_EXECUTION_REVISION||process.env.BUILDKITE_COMMIT||process.env.CIRCLE_SHA1||process.env.CIRRUS_CHANGE_IN_REPO||process.env.CF_REVISION||process.env.CM_COMMIT||process.env.CF_PAGES_COMMIT_SHA||process.env.DRONE_COMMIT_SHA||process.env.FC_GIT_COMMIT_SHA||process.env.HEROKU_TEST_RUN_COMMIT_VERSION||process.env.HEROKU_SLUG_COMMIT||process.env.RAILWAY_GIT_COMMIT_SHA||process.env.RENDER_GIT_COMMIT||process.env.SEMAPHORE_GIT_SHA||process.env.TRAVIS_PULL_REQUEST_SHA||process.env.VERCEL_GIT_COMMIT_SHA||process.env.VERCEL_GITHUB_COMMIT_SHA||process.env.VERCEL_GITLAB_COMMIT_SHA||process.env.VERCEL_BITBUCKET_COMMIT_SHA||process.env.ZEIT_GITHUB_COMMIT_SHA||process.env.ZEIT_GITLAB_COMMIT_SHA||process.env.ZEIT_BITBUCKET_COMMIT_SHA;
  const r=process.env.CI_COMMIT_ID||process.env.SOURCE_COMMIT||process.env.SOURCE_VERSION||process.env.GIT_COMMIT||process.env.COMMIT_REF||process.env.BUILD_VCS_NUMBER||process.env.CI_COMMIT_SHA;
  return t||n||r||e
}
const AY=wI(Q$(SY()));
const gY=60000/* 6e4 */;
class RY extends xG{constructor(t){
  const n=t.includeServerName===false?void 0:t.serverName||global.process.env.SENTRY_NAME||wt.hostname();
  const r={...t,platform:"node",runtime:{name:"node",version:global.process.version},serverName:n};

  if (t.openTelemetryInstrumentations) {
    rl({instrumentations:t.openTelemetryInstrumentations});
  }

  ME(r,"node");
  x.log(`Initializing Sentry: process: ${process.pid}, thread: ${np.isMainThread?"main":`worker-${np.threadId}`}.`);
  super(r);

  if (this.getOptions().enableLogs) {
    this._logOnExitFlushListener=()=>{pP(this)};
    n&&this.on("beforeCaptureLog",o=>{o.attributes={...o.attributes,"server.address":n}});
    process.on("beforeExit",this._logOnExitFlushListener);
  }
}get tracer(){
  if (this._tracer) {
    return this._tracer;
  }
  const t="@sentry/node";
  const n=Ze;
  const r=C.trace.getTracer(t,n);
  this._tracer=r;
  return r;
}async flush(t){
  await this.traceProvider?.forceFlush();

  if (this.getOptions().sendClientReports) {
    this._flushOutcomes();
  }

  return super.flush(t);
}async close(t){
  if (this._clientReportInterval) {
    clearInterval(this._clientReportInterval);
  }

  if (this._clientReportOnExitFlushListener) {
    process.off("beforeExit",this._clientReportOnExitFlushListener);
  }

  if (this._logOnExitFlushListener) {
    process.off("beforeExit",this._logOnExitFlushListener);
  }

  const n=await super.close(t);

  if (this.traceProvider) {
    (await this.traceProvider.shutdown());
  }

  return n;
}startClientReportTracking(){
  const t=this.getOptions();

  if (t.sendClientReports) {
    this._clientReportOnExitFlushListener=()=>{this._flushOutcomes()};

    this._clientReportInterval=setInterval(()=>{
      if (Ie) {
        x.log("Flushing client reports based on interval.");
      }

      this._flushOutcomes();
    },t.clientReportFlushInterval??gY).unref();

    process.on("beforeExit",this._clientReportOnExitFlushListener);
  }
}_setupIntegrations(){
  BG();
  super._setupIntegrations();
}_getTraceInfoFromScope(t){return t?tH(this,t):[void 0,void 0]}}function NY(){if(AF()&&!ye._sentryEsmLoaderHookRegistered){ye._sentryEsmLoaderHookRegistered=true;try{const{addHookMessagePort}=II.createAddHookMessageChannel();xw.register("import-in-the-middle/hook.mjs",typeof document === "undefined"?require("url").pathToFileURL(__filename).href:Yl&&Yl.tagName.toUpperCase()==="SCRIPT"&&Yl.src||new URL("worker.js",document.baseURI).href,{data:{addHookMessagePort:addHookMessagePort,include:[]},transferList:[addHookMessagePort]})}catch(e){x.warn("Failed to register 'import-in-the-middle' hook",e)}}}function xM(){return[iV(),nV(),mV(),CV(),zF(),HV(),IH(),DH(),LF(),GF(),dF(),mF(),xH(),XF(),aY(),yF()]}function yY(e={}){return OY(e,xM)}function OY(e={},t){
  const n=CY(e,t);

  if (n.debug===true) {
    if (Ie) {
      x.enable();
    } else {
      an(()=>{console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.")});
    }
  }

  if (n.registerEsmLoaderHooks!==false) {
    NY();
  }

  sH();
  Ke().update(n.initialScope);

  if (n.spotlight&&!n.integrations.some(({name}) => name===kM)) {
    n.integrations.push(YF({sidecarUrl:typeof n.spotlight=="string"?n.spotlight:void 0}));
  }

  ME(n,"node-core");
  const o=new RY(n);
  Ke().setClient(o);
  o.init();
  ye._sentryInjectLoaderHookRegister?.();
  x.log(`SDK initialized from ${KE()?"CommonJS":"ESM"}`);
  o.startClientReportTracking();
  MY();
  HB(o);
  rH(o);
  return o;
}function bY(){
  if (!Ie) {
    return;
  }
  const e=FB();
  const t=["SentryContextManager","SentryPropagator"];

  if (zt()) {
    t.push("SentrySpanProcessor");
  }

  for (const n of t) {
    if (!e.includes(n)) {
      x.error(`You have to set up the ${n}. Without this, the OpenTelemetry & Sentry integration will not work properly.`);
    }
  }

  if (!e.includes("SentrySampler")) {
    x.warn("You have to set up the SentrySampler. Without this, the OpenTelemetry & Sentry integration may still work, but sample rates set for the Sentry SDK will not be respected. If you use a custom sampler, make sure to use `wrapSamplingDecision`.");
  }
}function CY(e,t){
  const n=IY(e.release);let r;if (e.spotlight===false) {
    r=false;
  } else if (typeof e.spotlight=="string") {
    r=e.spotlight;
  } else {
    const c=Lp(process.env.SENTRY_SPOTLIGHT,{strict:true});
    const l=c===null&&process.env.SENTRY_SPOTLIGHT?process.env.SENTRY_SPOTLIGHT:void 0;
    r=e.spotlight===true?l??true:c??l
  }
  const o=PY(e.tracesSampleRate);
  const s={...e,dsn:e.dsn??process.env.SENTRY_DSN,environment:e.environment??process.env.SENTRY_ENVIRONMENT,sendClientReports:e.sendClientReports??true,transport:e.transport??_Y,stackParser:zU(e.stackParser||AY),release:n,tracesSampleRate:o,spotlight:r,debug:Lp(e.debug??process.env.SENTRY_DEBUG)};
  const i=e.integrations;
  const a=e.defaultIntegrations??t(s);
  return{...s,integrations:iG({defaultIntegrations:a,integrations:i})}
}function IY(e){if (e!==void 0) {
  return e;
}const t=mY();if (t!==void 0) {
  return t
}}function PY(e){if (e!==void 0) {
  return e;
}const t=process.env.SENTRY_TRACES_SAMPLE_RATE;if (!t) {
  return;
}const n=parseFloat(t);return isFinite(n)?n:void 0}function MY(){if(Lp(process.env.SENTRY_USE_ENVIRONMENT)!==false){
  const e=process.env.SENTRY_TRACE;
  const t=process.env.SENTRY_BAGGAGE;
  const n=zI(e,t);
  Ke().setPropagationContext(n)
}}function yt(e,t){e.setAttribute(Ge,t)}
const zE="Http";
const ER="@opentelemetry_sentry-patched/instrumentation-http";

const vY=Ne(`${zE}.sentry`,e => new bM(e));

const LY=Ne(zE,e=>{const t=new HU.HttpInstrumentation({...e,disableIncomingRequestInstrumentation:true});try{
  t._diag=C.diag.createComponentLogger({namespace:ER});
  t.instrumentationName=ER;
}catch{}return t});

function wY(e,t={}){return typeof e.spans=="boolean"?e.spans:!(t.skipOpenTelemetrySetup||!zt(t)&&bl.major>=22)}const DY=(e={})=>{
  const t=e.spans??true;
  const n=e.disableIncomingRequestSpans;
  const r={sessions:e.trackIncomingRequestsAsSessions,sessionFlushingDelayMS:e.sessionFlushingDelayMS,ignoreRequestBody:e.ignoreIncomingRequestBody,maxRequestBodySize:e.maxIncomingRequestBodySize};
  const o={ignoreIncomingRequests:e.ignoreIncomingRequests,ignoreStaticAssets:e.ignoreStaticAssets,ignoreStatusCodes:e.dropSpansForIncomingRequestStatusCodes,instrumentation:e.instrumentation,onSpanCreated:e.incomingRequestSpanHook};
  const s=KP(r);
  const i=zP(o);
  const a=t&&!n;
  return {name:zE,setup(c){
    const l=c.getOptions();

    if (a&&zt(l)) {
      i.setup(c);
    }
  },setupOnce(){
    const c=he()?.getOptions()||{};
    const l=wY(e,c);
    s.setupOnce();const f={breadcrumbs:e.breadcrumbs,propagateTraceInOutgoingRequests:!l,ignoreOutgoingRequests:e.ignoreOutgoingRequests};
    vY(f);

    if (l)
      {const d=UY(e);LY(d)}
  },processEvent(c){return i.processEvent(c)}};
};function UY(e={}){return {ignoreOutgoingRequestHook:n=>{const r=ZP(n);if (!r) {
  return false;
}const o=e.ignoreOutgoingRequests;return!!o?.(r,n)},requireParentforOutgoingSpans:false,requestHook:(n,r)=>{
  yt(n,"auto.http.otel.http");
  e.instrumentation?.requestHook?.(n,r);
},responseHook:(n,r)=>{e.instrumentation?.responseHook?.(n,r)},applyCustomAttributesOnSpan:(n,r,o)=>{e.instrumentation?.applyCustomAttributesOnSpan?.(n,r,o)}};}
const vd={};
const ca={};
const yr={};
let hR;
function kY(){
  if (!hR) {
    hR=1;
    Object.defineProperty(yr,"__esModule",{value:true});
    yr.PACKAGE_NAME=yr.PACKAGE_VERSION=void 0;
    yr.PACKAGE_VERSION="0.19.0";
    yr.PACKAGE_NAME="@opentelemetry/instrumentation-undici";
  }

  return yr;
}let TR;function GY(){
  if (TR) {
    return ca;
  }
  TR=1;
  Object.defineProperty(ca,"__esModule",{value:true});
  ca.UndiciInstrumentation=void 0;
  const e=BC;
  const t=Zu;
  const n=Le;
  const r=Pe();
  const o=dn;
  const s=pt();
  const i=kY();
  class a extends n.InstrumentationBase{_recordFromReq=new WeakMap;constructor(l={}){super(i.PACKAGE_NAME,i.PACKAGE_VERSION,l)}init(){}disable(){
    super.disable();

    this._channelSubs.forEach(l => l.unsubscribe());

    this._channelSubs.length=0;
  }enable(){
    super.enable();
    this._channelSubs=this._channelSubs||[];

    if (!(this._channelSubs.length>0)) {
      this.subscribeToChannel("undici:request:create",this.onRequestCreated.bind(this));
      this.subscribeToChannel("undici:client:sendHeaders",this.onRequestHeaders.bind(this));
      this.subscribeToChannel("undici:request:headers",this.onResponseHeaders.bind(this));
      this.subscribeToChannel("undici:request:trailers",this.onDone.bind(this));
      this.subscribeToChannel("undici:request:error",this.onError.bind(this));
    }
  }_updateMetricInstruments(){this._httpClientDurationHistogram=this.meter.createHistogram(s.METRIC_HTTP_CLIENT_REQUEST_DURATION,{description:"Measures the duration of outbound HTTP requests.",unit:"s",valueType:r.ValueType.DOUBLE,advice:{explicitBucketBoundaries:[0.005/* .005 */,0.01/* .01 */,0.025/* .025 */,0.05/* .05 */,0.075/* .075 */,0.1/* .1 */,0.25/* .25 */,0.5/* .5 */,0.75/* .75 */,1,2.5,5,7.5,10]}})}subscribeToChannel(l,f){
    const [d,u]=process.version.replace("v","").split(".").map(E => Number(E));

    const _=d>18||d===18&&u>=19;
    let p;if (_) {
      e.subscribe?.(l,f);

      p=() => e.unsubscribe?.(l,f);
    } else {
      const E=e.channel(l);
      E.subscribe(f);

      p=() => E.unsubscribe(f);
    }this._channelSubs.push({name:l,unsubscribe:p})
  }parseRequestHeaders(l){const f=new Map;if (Array.isArray(l.headers)) {
    for(let d=0;d<l.headers.length;d+=2){
      const u=l.headers[d];
      const _=l.headers[d+1];

      if (typeof u=="string") {
        f.set(u.toLowerCase(),_);
      }
    }
  } else if(typeof l.headers=="string"){const d=l.headers.split(`\r
  `);for(const u of d){
    if (!u) {
      continue;
    }const _=u.indexOf(":");if (_===-1) {
        continue;
      }
    const p=u.substring(0,_).toLowerCase();
    const E=u.substring(_+1).trim();
    const h=f.get(p);

    if (h&&Array.isArray(h)) {
      h.push(E);
    } else if (h) {
      f.set(p,[h,E]);
    } else {
      f.set(p,E);
    }
  }}return f}onRequestCreated({request}){
    const f=this.getConfig();
    const d=f.enabled!==false;
    if ((0,n.safeExecuteInTheMiddle)(() => !d||request.method==="CONNECT"||f.ignoreRequestHook?.(request),B => B&&this._diag.error("caught ignoreRequestHook error: ",B),true)) {
      return;
    }const _=(0,o.hrTime)();let p;try{p=new t.URL(request.path,request.origin)}catch(B){this._diag.warn("could not determine url.full:",B);return}
    const E=p.protocol.replace(":","");
    const h=this.getRequestMethod(request.method);
    const T={[s.ATTR_HTTP_REQUEST_METHOD]:h,[s.ATTR_HTTP_REQUEST_METHOD_ORIGINAL]:request.method,[s.ATTR_URL_FULL]:p.toString(),[s.ATTR_URL_PATH]:p.pathname,[s.ATTR_URL_QUERY]:p.search,[s.ATTR_URL_SCHEME]:E};
    const m={https:"443",http:"80"};
    const A=p.hostname;
    const g=p.port||m[E];
    T[s.ATTR_SERVER_ADDRESS]=A;

    if (g&&!isNaN(Number(g))) {
      (T[s.ATTR_SERVER_PORT] = Number(g));
    }

    const O=this.parseRequestHeaders(request).get("user-agent");if(O){const B=Array.isArray(O)?O[O.length-1]:O;T[s.ATTR_USER_AGENT_ORIGINAL]=B}const I=(0,n.safeExecuteInTheMiddle)(() => f.startSpanHook?.(request),B => B&&this._diag.error("caught startSpanHook error: ",B),true);

    if (I) {
      Object.entries(I).forEach(([B,F])=>{T[B]=F});
    }

    const b=r.context.active();
    const L=r.trace.getSpan(b);
    let U;

    if (f.requireParentforSpans&&(!L||!r.trace.isSpanContextValid(L.spanContext()))) {
      U=r.trace.wrapSpanContext(r.INVALID_SPAN_CONTEXT);
    } else {
      U=this.tracer.startSpan(h==="_OTHER"?"HTTP":h,{kind:r.SpanKind.CLIENT,attributes:T},b);
    }

    (0,n.safeExecuteInTheMiddle)(() => f.requestHook?.(U,request),B => B&&this._diag.error("caught requestHook error: ",B),true);

    const q=r.trace.setSpan(r.context.active(),U);
    const H={};
    r.propagation.inject(q,H);const $=Object.entries(H);for(let B=0;B<$.length;B++){
      const[F,D]=$[B];

      if (typeof request.addHeader=="function") {
        request.addHeader(F,D);
      } else if (typeof request.headers=="string") {
        request.headers+=`${F}: ${D}\r
          `;
      } else if (Array.isArray(request.headers)) {
        request.headers.push(F,D);
      }
    }this._recordFromReq.set(request,{span:U,attributes:T,startTime:_})
  }onRequestHeaders({request,socket}){
    const d=this._recordFromReq.get(request);if (!d) {
      return;
    }
    const u=this.getConfig();
    const {span}=d;
    const {remoteAddress,remotePort}=socket;
    const h={[s.ATTR_NETWORK_PEER_ADDRESS]:remoteAddress,[s.ATTR_NETWORK_PEER_PORT]:remotePort};
    if(u.headersToSpanAttributes?.requestHeaders){
      const T=new Set(u.headersToSpanAttributes.requestHeaders.map(A => A.toLowerCase()));

      const m=this.parseRequestHeaders(request);
      for (const[A,g] of m.entries()) {
        if(T.has(A)){const R=Array.isArray(g)?g.join(", "):g;h[`http.request.header.${A}`]=R}
      }
    }span.setAttributes(h)
  }onResponseHeaders({request,response}){
    const d=this._recordFromReq.get(request);if (!d) {
        return;
      }
    const {span,attributes}=d;
    const p={[s.ATTR_HTTP_RESPONSE_STATUS_CODE]:response.statusCode};
    const E=this.getConfig();
    (0,n.safeExecuteInTheMiddle)(() => E.responseHook?.(span,{request:request,response:response}),T => T&&this._diag.error("caught responseHook error: ",T),true);const h=new Set;

    if (E.headersToSpanAttributes?.responseHeaders) {
      E.headersToSpanAttributes?.responseHeaders.forEach(T => h.add(T.toLowerCase()));
    }

    for(let T=0;T<response.headers.length;T=T+2){
      const m=response.headers[T].toString().toLowerCase();
      const A=response.headers[T+1];

      if (h.has(m)) {
        (p[`http.response.header.${m}`] = A.toString());
      }

      if (m==="content-length")
        {
          const g=Number(A.toString());

          if (!isNaN(g)) {
            (p["http.response.header.content-length"] = g);
          }
        }
    }
    span.setAttributes(p);
    span.setStatus({code:response.statusCode>=400?r.SpanStatusCode.ERROR:r.SpanStatusCode.UNSET});
    d.attributes=Object.assign(attributes,p);
  }onDone({request}){
    const f=this._recordFromReq.get(request);if (!f) {
      return;
    }const{span,attributes,startTime}=f;
    span.end();
    this._recordFromReq.delete(request);
    this.recordRequestDuration(attributes,startTime);
  }onError({request,error}){
    const d=this._recordFromReq.get(request);if (!d) {
      return;
    }const{span,attributes,startTime}=d;
    span.recordException(error);
    span.setStatus({code:r.SpanStatusCode.ERROR,message:error.message});
    span.end();
    this._recordFromReq.delete(request);
    attributes[s.ATTR_ERROR_TYPE]=error.message;
    this.recordRequestDuration(attributes,startTime);
  }recordRequestDuration(l,f){const d={};[s.ATTR_HTTP_RESPONSE_STATUS_CODE,s.ATTR_HTTP_REQUEST_METHOD,s.ATTR_SERVER_ADDRESS,s.ATTR_SERVER_PORT,s.ATTR_URL_SCHEME,s.ATTR_ERROR_TYPE].forEach(p=>{
    if (p in l) {
      (d[p] = l[p]);
    }
  });const _=(0,o.hrTimeToMilliseconds)((0,o.hrTimeDuration)(f,(0,o.hrTime)()))/1000/* 1e3 */;this._httpClientDurationHistogram.record(_,d)}getRequestMethod(l){const f={CONNECT:true,OPTIONS:true,HEAD:true,GET:true,POST:true,PUT:true,PATCH:true,DELETE:true,TRACE:true};return l.toUpperCase()in f?l.toUpperCase():"_OTHER"}}
  ca.UndiciInstrumentation=a;
  return ca;
}let SR;function VY(){
  if (!SR) {
    SR=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.UndiciInstrumentation=void 0;
      const t=GY();Object.defineProperty(e,"UndiciInstrumentation",{enumerable:true,get() {return t.UndiciInstrumentation}})
    })(vd);
  }

  return vd;
}const xY=VY();
const $M="NodeFetch";

const $Y=Ne($M,xY.UndiciInstrumentation,e => qY(e));

const BY=Ne(`${$M}.sentry`,IM,e => e);

const HY=((e={}) => ({
  name:"NodeFetch",

  setupOnce(){
    if (jY(e,he()?.getOptions())) {
      $Y(e);
    }

    BY(e);
  }
}));

const FY=HY;
function YY(e,t="/"){const n=`${e}`;return n.endsWith("/")&&t.startsWith("/")?`${n}${t.slice(1)}`:!n.endsWith("/")&&!t.startsWith("/")?`${n}/${t.slice(1)}`:`${n}${t}`}function jY(e,t={}){
  if (typeof e.spans=="boolean") {
    return e.spans;
  }

  if (!t.skipOpenTelemetrySetup) {
    return zt(t);
  }
}function qY(e={}){return {requireParentforSpans:false,ignoreRequestHook:n=>{
  const r=YY(n.origin,n.path);
  const o=e.ignoreOutgoingRequests;
  return!!(o&&r&&o(r))
},startSpanHook:() => ({
  [Ge]:"auto.http.otel.node_fetch"
}),requestHook:e.requestHook,responseHook:e.responseHook};}
const Ld={};
const ua={};
const wd={};
let mR;
function ZE(){
  if (!mR) {
    mR=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.ExpressLayerType=void 0;

      (t => {
        t.ROUTER="router";
        t.MIDDLEWARE="middleware";
        t.REQUEST_HANDLER="request_handler";
      })(e.ExpressLayerType||(e.ExpressLayerType={}));
    })(wd);
  }

  return wd;
}
const Dd={};
let AR;
function XE(){
  if (!AR) {
    AR=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.AttributeNames=void 0;

      (t => {
        t.EXPRESS_TYPE="express.type";
        t.EXPRESS_NAME="express.name";
      })(e.AttributeNames||(e.AttributeNames={}));
    })(Dd);
  }

  return Dd;
}
const Ud={};
const Or={};
let gR;
function BM(){
  if (!gR) {
    gR=1;
    Object.defineProperty(Or,"__esModule",{value:true});
    Or._LAYERS_STORE_PROPERTY=Or.kLayerPatched=void 0;
    Or.kLayerPatched=Symbol("express-layer-patched");
    Or._LAYERS_STORE_PROPERTY="__ot_middlewares";
  }

  return Or;
}let RR;function WY(){
  if (!RR) {
    RR=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.getActualMatchedRoute = void 0;
      e.getConstructedRoute = void 0;
      e.getLayerPath = void 0;
      e.asErrorAndMessage = void 0;
      e.isLayerIgnored = void 0;
      e.getLayerMetadata = void 0;
      e.getRouterPath = void 0;
      e.storeLayerPath = void 0;
      const t=ZE();
      const n=XE();
      const r=BM();

      const o=(E, h) => {
        if (Array.isArray(E[r._LAYERS_STORE_PROPERTY])===false) {
          Object.defineProperty(E,r._LAYERS_STORE_PROPERTY,{enumerable:false,value:[]});
        }

        return h===void 0?{isLayerPathStored:false}:(E[r._LAYERS_STORE_PROPERTY].push(h),{isLayerPathStored:true});
      };

      e.storeLayerPath=o;const s=(E,h)=>{const T=h.handle?.stack?.[0];return T?.route?.path?`${E}${T.route.path}`:T?.handle?.stack?(0,e.getRouterPath)(E,T):E};e.getRouterPath=s;const i=(E,h,T)=>{if (h.name==="router") {
        const m=(0,e.getRouterPath)("",h);
        const A=m||T||E||"/";
        return{attributes:{[n.AttributeNames.EXPRESS_NAME]:A,[n.AttributeNames.EXPRESS_TYPE]:t.ExpressLayerType.ROUTER},name:`router - ${A}`}
      } else {
        return h.name==="bound dispatch"||h.name==="handle"?{attributes:{[n.AttributeNames.EXPRESS_NAME]:(E||T)??"request handler",[n.AttributeNames.EXPRESS_TYPE]:t.ExpressLayerType.REQUEST_HANDLER},name:`request handler${h.path?` - ${E||T}`:""}`}:{attributes:{[n.AttributeNames.EXPRESS_NAME]:h.name,[n.AttributeNames.EXPRESS_TYPE]:t.ExpressLayerType.MIDDLEWARE},name:`middleware - ${h.name}`}
      }};e.getLayerMetadata=i;

      const a=(E,h)=>{if (typeof h=="string") {
        return h===E;
      }if (h instanceof RegExp) {
        return h.test(E);
      }if (typeof h=="function") {
        return h(E);
      }throw new TypeError("Pattern is in unsupported datatype")};

      const c=(E,h,T)=>{if (Array.isArray(T?.ignoreLayersType)&&T?.ignoreLayersType?.includes(h)) {
        return true;
      }if (Array.isArray(T?.ignoreLayers)===false) {
        return false;
      }try{for (const m of T.ignoreLayers) {
        if (a(E,m)) {
          return true;
        }
      }}catch{}return false;};

      e.isLayerIgnored=c;const l=E => E instanceof Error?[E,E.message]:[String(E),String(E)];e.asErrorAndMessage=l;const f=E=>{const h=E[0];return Array.isArray(h)?h.map(T => d(T)||"").join(","):d(h);};e.getLayerPath=f;const d=E=>{if (typeof E=="string") {
        return E;
      }if (E instanceof RegExp||typeof E=="number") {
        return E.toString()
      }};function u(E){const T=(Array.isArray(E[r._LAYERS_STORE_PROPERTY])?E[r._LAYERS_STORE_PROPERTY]:[]).filter(m => m!=="/"&&m!=="/*");return T.length===1&&T[0]==="*"?"*":T.join("").replace(/\/{2,}/g,"/");}e.getConstructedRoute=u;function _(E){const h=Array.isArray(E[r._LAYERS_STORE_PROPERTY])?E[r._LAYERS_STORE_PROPERTY]:[];if (h.length===0) {
        return;
      }if (h.every(g => g==="/")) {
        return E.originalUrl==="/"?"/":void 0;
      }const T=u(E);if (T==="*"||T.includes("/")&&(T.includes(",")||T.includes("\\")||T.includes("*")||T.includes("["))) {
        return T;
      }const m=T.startsWith("/")?T:`/${T}`;return m.length>0&&(E.originalUrl===m||E.originalUrl.startsWith(m)||p(m))?m:void 0}e.getActualMatchedRoute=_;function p(E){return E.includes(":")||E.includes("*")}
    })(Ud);
  }

  return Ud;
}
const br={};
let NR;
function KY(){
  if (!NR) {
    NR=1;
    Object.defineProperty(br,"__esModule",{value:true});
    br.PACKAGE_NAME=br.PACKAGE_VERSION=void 0;
    br.PACKAGE_VERSION="0.57.0";
    br.PACKAGE_NAME="@opentelemetry/instrumentation-express";
  }

  return br;
}let yR;function zY(...args) {
  if (yR) {
    return ua;
  }
  yR=1;
  Object.defineProperty(ua,"__esModule",{value:true});
  ua.ExpressInstrumentation=void 0;
  const e=dn;
  const t=Pe();
  const n=ZE();
  const r=XE();
  const o=WY();
  const s=KY();
  const i=Le;
  const a=pt();
  const c=BM();
  class l extends i.InstrumentationBase{constructor(d={}){super(s.PACKAGE_NAME,s.PACKAGE_VERSION,d)}init(){return [new i.InstrumentationNodeModuleDefinition("express",[">=4.0.0 <6"],d=>{
    const u=typeof d?.Router?.prototype?.route=="function";
    const _=u?d.Router.prototype:d.Router;

    if ((0,i.isWrapped)(_.route)) {
      this._unwrap(_,"route");
    }

    this._wrap(_,"route",this._getRoutePatch());

    if ((0,i.isWrapped)(_.use)) {
      this._unwrap(_,"use");
    }

    this._wrap(_,"use",this._getRouterUsePatch());

    if ((0,i.isWrapped)(d.application.use)) {
      this._unwrap(d.application,"use");
    }

    this._wrap(d.application,"use",this._getAppUsePatch(u));
    return d;
  },d=>{
    if (d===void 0) {
      return;
    }const _=typeof d?.Router?.prototype?.route=="function"?d.Router.prototype:d.Router;
    this._unwrap(_,"route");
    this._unwrap(_,"use");
    this._unwrap(d.application,"use");
  })];}_getRoutePatch(){const d=this;return u => (function(...p) {
    const E=u.apply(this,p);
    const h=this.stack[this.stack.length-1];
    d._applyPatch(h,(0,o.getLayerPath)(p));
    return E;
  });}_getRouterUsePatch(){const d=this;return u => (function(...p) {
    const E=u.apply(this,p);
    const h=this.stack[this.stack.length-1];
    d._applyPatch(h,(0,o.getLayerPath)(p));
    return E;
  });}_getAppUsePatch(d){const u=this;return _ => (function(...E) {
    const h=d?this.router:this._router;
    const T=_.apply(this,E);
    if(h){const m=h.stack[h.stack.length-1];u._applyPatch(m,(0,o.getLayerPath)(E))}return T
  });}_applyPatch(d,u){
    const _=this;

    if (d[c.kLayerPatched]!==true) {
      d[c.kLayerPatched]=true;

      this._wrap(d,"handle",p=>{if (p.length===4) {
        return p;
      }const E=function(h,T){
        const {isLayerPathStored}=(0,o.storeLayerPath)(h,u);
        const A=(0,o.getConstructedRoute)(h);
        const g=(0,o.getActualMatchedRoute)(h);
        const R={[a.ATTR_HTTP_ROUTE]:g};
        const O=(0,o.getLayerMetadata)(A,d,u);
        const I=O.attributes[r.AttributeNames.EXPRESS_TYPE];
        const b=(0,e.getRPCMetadata)(t.context.active());

        if (b?.type===e.RPCType.HTTP) {
          (b.route = g);
        }

        if ((0,o.isLayerIgnored)(O.name,I,_.getConfig())) {
          if (I===n.ExpressLayerType.MIDDLEWARE) {
            h[c._LAYERS_STORE_PROPERTY].pop();
          }

          return p.apply(this,args);
        }

        if (t.trace.getSpan(t.context.active())===void 0) {
          return p.apply(this,args);
        }
        const L=_._getSpanName({request:h,layerType:I,route:A},O.name);
        const U=_.tracer.startSpan(L,{attributes:Object.assign(R,O.attributes)});
        const q=t.context.active();
        let H=t.trace.setSpan(q,U);const{requestHook}=_.getConfig();

        if (requestHook) {
          (0,i.safeExecuteInTheMiddle)(() => requestHook(U,{request:h,layerType:I,route:A}),Y=>{
            if (Y) {
              t.diag.error("express instrumentation: request hook failed",Y);
            }
          },true);
        }

        let B=false;

        if (O.attributes[r.AttributeNames.EXPRESS_TYPE]===n.ExpressLayerType.ROUTER) {
          U.end();
          B=true;
          H=q;
        }

        const F=()=>{
          if (B===false) {
            B=true;
            U.end();
          }
        };
        const D=Array.from(args);

        const k=D.findIndex(Y => typeof Y=="function");

        if (k>=0) {
          (args[k] = function(...args) {
            const Y=args[0];
            const oe=![void 0,null,"route","router"].includes(Y);
            if(!B&&oe){
              const[ne,P]=(0,o.asErrorAndMessage)(Y);
              U.recordException(ne);
              U.setStatus({code:t.SpanStatusCode.ERROR,message:P});
            }

            if (B===false) {
              B=true;
              h.res?.removeListener("finish",F);
              U.end();
            }

            if (!(h.route&&oe)&&isLayerPathStored) {
              h[c._LAYERS_STORE_PROPERTY].pop();
            }

            const ae=D[k];return t.context.bind(q,ae).apply(this,args);
          });
        }

        try{return t.context.bind(H,p).apply(this,args);}catch(Y){
            const[oe,ae]=(0,o.asErrorAndMessage)(Y);
            U.recordException(oe);
            U.setStatus({code:t.SpanStatusCode.ERROR,message:ae});
            throw Y;
          }finally{
          if (!B) {
            T.once("finish",F);
          }
        }
      };for (const h in p) {
        Object.defineProperty(E,h,{get(){return p[h]},set(T){p[h]=T}});
      }return E});
    }
  }_getSpanName(d,u){const{spanNameHook}=this.getConfig();if (!(spanNameHook instanceof Function)) {
    return u;
  }try{return spanNameHook(d,u)??u;}catch(p){
    t.diag.error("express instrumentation: error calling span name rewrite hook",p);
    return u;
  }}}
  ua.ExpressInstrumentation=l;
  return ua;
}let OR;function ZY(){
  if (!OR) {
    OR=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.AttributeNames = void 0;
      e.ExpressLayerType = void 0;
      e.ExpressInstrumentation = void 0;
      const t=zY();Object.defineProperty(e,"ExpressInstrumentation",{enumerable:true,get() {return t.ExpressInstrumentation}});const n=ZE();Object.defineProperty(e,"ExpressLayerType",{enumerable:true,get() {return n.ExpressLayerType}});const r=XE();Object.defineProperty(e,"AttributeNames",{enumerable:true,get() {return r.AttributeNames}})
    })(Ld);
  }

  return Ld;
}const XY=ZY();
const io=typeof __SENTRY_DEBUG__ === "undefined"||__SENTRY_DEBUG__;
const HM="Express";
function QY(e){
  yt(e,"auto.http.otel.express");
  const t=Re(e).data;
  const n=t["express.type"];

  if (n) {
    e.setAttribute(Ee,`${n}.express`);
  }

  const r=t["express.name"];

  if (typeof r=="string") {
    e.updateName(r);
  }
}function JY(e,t){if (je()===Xo()) {
  if (io) {
    x.warn("Isolation scope is still default isolation scope - skipping setting transactionName");
  }

  return t;
}if(e.layerType==="request_handler"){
  const n=e.request;
  const r=n.method?n.method.toUpperCase():"GET";
  je().setTransactionName(`${r} ${e.route}`)
}return t}

const ej=Ne(HM,() => new XY.ExpressInstrumentation({requestHook:e => QY(e),spanNameHook:(e, t) => JY(e,t)}));

const tj=(() => ({
  name:HM,
  setupOnce(){ej()}
}));

const nj=tj;
let kd;
let bR;
function rj(){
  if (bR) {
    return kd;
  }
  bR=1;
  kd=e;
  function e(r,o,s){
    if (r instanceof RegExp) {
      (r = t(r,s));
    }

    if (o instanceof RegExp) {
      (o = t(o,s));
    }

    const i=n(r,o,s);return i&&{start:i[0],end:i[1],pre:s.slice(0,i[0]),body:s.slice(i[0]+r.length,i[1]),post:s.slice(i[1]+o.length)}
  }function t(r,o){const s=o.match(r);return s?s[0]:null}e.range=n;function n(r,o,s){
    let i;
    let a;
    let c;
    let l;
    let f;
    let d=s.indexOf(r);
    let u=s.indexOf(o,d+1);
    let _=d;
    if(d>=0&&u>0){
      if (r===o) {
        return[d,u];
      }
      i=[];

      for (c=s.length; _>=0&&!f; ) {
        if (_==d) {
          i.push(_);
          d=s.indexOf(r,_+1);
        } else if (i.length==1) {
          f=[i.pop(),u];
        } else {
          a=i.pop();
          a<c&&(c=a,l=u);
          u=s.indexOf(o,_+1);
        }

        _=d<u&&d>=0?d:u;
      }

      if (i.length) {
        (f = [c,l]);
      }
    }return f
  }return kd
}
let Gd;
let CR;
function oj(){
  if (CR) {
    return Gd;
  }CR=1;const e=rj();Gd=f;
  const t=`\0SLASH${Math.random()}\0`;
  const n=`\0OPEN${Math.random()}\0`;
  const r=`\0CLOSE${Math.random()}\0`;
  const o=`\0COMMA${Math.random()}\0`;
  const s=`\0PERIOD${Math.random()}\0`;
  function i(h){return parseInt(h,10)==h?parseInt(h,10):h.charCodeAt(0)}function a(h){return h.split("\\\\").join(t).split("\\{").join(n).split("\\}").join(r).split("\\,").join(o).split("\\.").join(s)}function c(h){return h.split(t).join("\\").split(n).join("{").split(r).join("}").split(o).join(",").split(s).join(".")}function l(h){
  if (!h) {
    return[""];
  }
  const T=[];
  const m=e("{","}",h);
  if (!m) {
    return h.split(",");
  }
  const A=m.pre;
  const g=m.body;
  const R=m.post;
  const O=A.split(",");
  O[O.length-1]+=`{${g}}`;const I=l(R);

  if (R.length) {
    O[O.length-1]+=I.shift();
    O.push(...I);
  }

  T.push(...O);
  return T;
}function f(h){return h?(h.substr(0,2)==="{}"&&(h=`\\{\\}${h.substr(2)}`),E(a(h),true).map(c)):[];}function d(h){return `{${h}}`;}function u(h){return /^-?0\d/.test(h);}function _(h,T){return h<=T}function p(h,T){return h>=T}function E(h,T){
    const m=[];
    const A=e("{","}",h);
    if (!A) {
      return[h];
    }
    const g=A.pre;
    const R=A.post.length?E(A.post,false):[""];
    if (/\$$/.test(A.pre)) {
      for(var O=0;O<R.length;O++){var I=`${g}{${A.body}}${R[O]}`;m.push(I)}
    } else {
      const b=/^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(A.body);
      const L=/^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(A.body);
      const U=b||L;
      const q=A.body.includes(",");
      if (!U&&!q) {
        return A.post.match(/,(?!,).*\}/)?(h=`${A.pre}{${A.body}${r}${A.post}`,E(h)):[h];
      }let H;if (U) {
        H=A.body.split(/\.\./);
      } else {
        H=l(A.body);

        if (H.length===1&&(H=E(H[0],false).map(d),H.length===1)) {
          return R.map(K => A.pre+H[0]+K);
        }
      }let $;if(U){
      const B=i(H[0]);
      const F=i(H[1]);
      const D=Math.max(H[0].length,H[1].length);
      let k=H.length==3?Math.abs(i(H[2])):1;
      let Y=_;
      const oe=F<B;

      if (oe) {
        k*=-1;
        Y=p;
      }

      const ae=H.some(u);$=[];for(let ne=B;Y(ne,F);ne+=k){let P;if (L) {
        P=String.fromCharCode(ne);

        if (P==="\\") {
          (P = "");
        }
      } else {
            P=String(ne);

            if (ae)
              {const M=D-P.length;if(M>0){
                const G=new Array(M+1).join("0");

                if (ne<0) {
                  P=`-${G}${P.slice(1)}`;
                } else {
                  P=G+P;
                }
              }}
          }$.push(P)}
    }else{$=[];for (var V=0; V<H.length; V++) {
        $.push(...E(H[V],false))
      }}for (var V=0; V<$.length; V++) {
        for(var O=0;O<R.length;O++){
          var I=g+$[V]+R[O];

          if ((!T||U || I)) {
            m.push(I);
          }
        }
      }
    }return m
  }return Gd
}const sj=oj();
const ij=zp(sj);
const aj=1024*64;

const Pu=e=>{if (typeof e!="string") {
  throw new TypeError("invalid pattern");
}if (e.length>aj) {
  throw new TypeError("pattern is too long")
}};

const cj={"[:alnum:]":["\\p{L}\\p{Nl}\\p{Nd}",true],"[:alpha:]":["\\p{L}\\p{Nl}",true],"[:ascii:]":["\\x00-\\x7f",false],"[:blank:]":["\\p{Zs}\\t",true],"[:cntrl:]":["\\p{Cc}",true],"[:digit:]":["\\p{Nd}",true],"[:graph:]":["\\p{Z}\\p{C}",true,true],"[:lower:]":["\\p{Ll}",true],"[:print:]":["\\p{C}",true],"[:punct:]":["\\p{P}",true],"[:space:]":["\\p{Z}\\t\\r\\n\\v\\f",true],"[:upper:]":["\\p{Lu}",true],"[:word:]":["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}",true],"[:xdigit:]":["A-Fa-f0-9",false]};

const la=e => e.replace(/[[\]\\-]/g,"\\$&");

const uj=e => e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&");

const IR=e => e.join("");

const lj=(e,t)=>{
  const n=t;if (e.charAt(n)!=="[") {
    throw new Error("not in a brace expression");
  }
  const r=[];
  const o=[];
  let s=n+1;
  let i=false;
  let a=false;
  let c=false;
  let l=false;
  let f=n;
  let d="";
  e:
  while (s<e.length) {
    const E=e.charAt(s);if((E==="!"||E==="^")&&s===n+1){
      l=true;
      s++;
      continue
    }if(E==="]"&&i&&!c){f=s+1;break}
    i=true;

    if (E==="\\"&&!c) {
      c=true;
      s++;
      continue
    }

    if(E==="["&&!c){for (const[h,[T,m,A]] of Object.entries(cj)) {
      if(e.startsWith(h,s)){
        if (d) {
          return ["$.",false,e.length-n,true];
        }
        s+=h.length;

        if (A) {
          o.push(T);
        } else {
          r.push(T);
        }

        a=a||m;
        continue e
      }
    }}
    c=false;

    if (d) {
      if (E>d) {
        r.push(`${la(d)}-${la(E)}`);
      } else if (E===d) {
        r.push(la(E));
      }

      d="";
      s++;
      continue
    }

    if(e.startsWith("-]",s+1)){
      r.push(la(`${E}-`));
      s+=2;
      continue
    }if(e.startsWith("-",s+1)){
      d=E;
      s+=2;
      continue
    }
    r.push(la(E));
    s++;
  }if (f<s) {
    return ["",false,0,false];
  }if (!r.length&&!o.length) {
    return ["$.",false,e.length-n,true];
  }if(o.length===0&&r.length===1&&/^\\?.$/.test(r[0])&&!l){const E=r[0].length===2?r[0].slice(-1):r[0];return [uj(E),false,f-n,false];}
  const u=`[${l?"^":""}${IR(r)}]`;
  const _=`[${l?"":"^"}${IR(o)}]`;
  return [r.length&&o.length?`(${u}|${_})`:r.length?u:_,a,f-n,true];
};

const Ya=(e, {windowsPathsNoEscape:t=false}={}) => t?e.replace(/\[([^\/\\])\]/g,"$1"):e.replace(/((?!\\).|^)\[([^\/\\])\]/g,"$1$2").replace(/\\([^\/])/g,"$1");

const dj=new Set(["!","?","+","*","@"]);

const PR=e => dj.has(e);

const fj="(?!(?:^|/)\\.\\.?(?:$|/))";
const $c="(?!\\.)";
const _j=new Set(["[","."]);
const pj=new Set(["..","."]);
const Ej=new Set("().*{}+?[]^$\\!");

const hj=e => e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&");

const QE="[^/]";
const MR=`${QE}*?`;
const vR=`${QE}+?`;
class At{type;#e;#t;#r=false;#n=[];#o;#i;#c;#a=false;#s;#u;#d=false;constructor(t,n,r={}){
  this.type=t;

  if (t) {
    (this.#t = true);
  }

  this.#o=n;
  this.#e=this.#o?this.#o.#e:this;
  this.#s=this.#e===this?r:this.#e.#s;
  this.#c=this.#e===this?[]:this.#e.#c;

  if (t==="!"&&!this.#e.#a) {
    this.#c.push(this);
  }

  this.#i=this.#o?this.#o.#n.length:0;
}get hasMagic(){if (this.#t!==void 0) {
  return this.#t;
}for (const t of this.#n) {
  if (typeof t!="string"&&(t.type||t.hasMagic)) {
    return this.#t=true;
  }
}return this.#t}toString(){
  if (this.#u!==void 0) {
    return this.#u;
  }

  if (this.type) {
    return this.#u=`${this.type}(${this.#n.map(t => String(t)).join("|")})`;
  }

  return this.#u=this.#n.map(t => String(t)).join("");
}#_(){
  if (this!==this.#e) {
    throw new Error("should only call on root");
  }if (this.#a) {
      return this;
    }
  this.toString();
  this.#a=true;
  let t;

  while (t=this.#c.pop()) {
    if (t.type!=="!") {
      continue;
    }
    let n=t;
    let r=n.#o;

    while (r) {
      for (let o=n.#i+1; !r.type&&o<r.#n.length; o++) {
        for(const s of t.#n){if (typeof s=="string") {
          throw new Error("string part in extglob AST??");
        }s.copyIn(r.#n[o])}
      }
      n=r;
      r=n.#o;
    }
  }

  return this
}push(...t){for (const n of t) {
  if(n!==""){if (typeof n!="string"&&!(n instanceof At&&n.#o===this)) {
    throw new Error(`invalid part: ${n}`);
  }this.#n.push(n)}
}}toJSON(){
  const t=this.type===null?this.#n.slice().map(n => typeof n=="string"?n:n.toJSON()):[this.type,...this.#n.map(n => n.toJSON())];

  if (this.isStart()&&!this.type) {
    t.unshift([]);
  }

  if (this.isEnd()&&(this===this.#e||this.#e.#a&&this.#o?.type==="!")) {
    t.push({});
  }

  return t;
}isStart(){if (this.#e===this) {
  return true;
}if (!this.#o?.isStart()) {
  return false;
}if (this.#i===0) {
  return true;
}const t=this.#o;for(let n=0;n<this.#i;n++){const r=t.#n[n];if (!(r instanceof At&&r.type==="!")) {
  return false;
}}return true;}isEnd(){if (this.#e===this||this.#o?.type==="!") {
  return true;
}if (!this.#o?.isEnd()) {
  return false;
}if (!this.type) {
  return this.#o?.isEnd();
}const t=this.#o?this.#o.#n.length:0;return this.#i===t-1}copyIn(t){
  if (typeof t=="string") {
    this.push(t);
  } else {
    this.push(t.clone(this));
  }
}clone(t){const n=new At(this.type,t);for (const r of this.#n) {
  n.copyIn(r);
}return n}static#l(t,n,r,o){
  let s=false;
  let i=false;
  let a=-1;
  let c=false;
  if(n.type===null){
    let _=r;
    let p="";

    while (_<t.length) {const E=t.charAt(_++);if(s||E==="\\"){
      s=!s;
      p+=E;
      continue
    }if(i){
      if (_===a+1) {
        if ((E==="^" || E==="!")) {
          (c = true);
        }
      } else if (E==="]"&&!(_===a+2&&c)) {
        (i = false);
      }

      p+=E;
      continue
    }else if(E==="["){
      i=true;
      a=_;
      c=false;
      p+=E;
      continue
    }if(!o.noext&&PR(E)&&t.charAt(_)==="("){
      n.push(p);
      p="";
      const h=new At(E,n);
      _=At.#l(t,h,_,o);
      n.push(h);
      continue
    }p+=E}

    n.push(p);
    return _;
  }
  let l=r+1;
  let f=new At(null,n);
  const d=[];let u="";

  while (l<t.length) {const _=t.charAt(l++);if(s||_==="\\"){
      s=!s;
      u+=_;
      continue
    }if(i){
    if (l===a+1) {
      if ((_==="^" || _==="!")) {
        (c = true);
      }
    } else if (_==="]"&&!(l===a+2&&c)) {
      (i = false);
    }

    u+=_;
    continue
  }else if(_==="["){
      i=true;
      a=l;
      c=false;
      u+=_;
      continue
    }if(PR(_)&&t.charAt(l)==="("){
      f.push(u);
      u="";
      const p=new At(_,f);
      f.push(p);
      l=At.#l(t,p,l,o);
      continue
    }if(_==="|"){
      f.push(u);
      u="";
      d.push(f);
      f=new At(null,n);
      continue
    }if (_===")") {
    if (u===""&&n.#n.length===0) {
      (n.#d = true);
    }

    f.push(u);
    u="";
    n.push(...d,f);
    return l;
  }u+=_}

  n.type=null;
  n.#t=void 0;
  n.#n=[t.substring(r-1)];
  return l;
}static fromGlob(t,n={}){
  const r=new At(null,void 0,n);
  At.#l(t,r,0,n);
  return r;
}toMMPattern(){
  if (this!==this.#e) {
    return this.#e.toMMPattern();
  }
  const t=this.toString();
  const [n,r,o,s]=this.toRegExpSource();
  if (!(o||this.#t||this.#s.nocase&&!this.#s.nocaseMagicOnly&&t.toUpperCase()!==t.toLowerCase())) {
    return r;
  }const a=(this.#s.nocase?"i":"")+(s?"u":"");return Object.assign(new RegExp(`^${n}$`,a),{_src:n,_glob:t})
}get options(){return this.#s}toRegExpSource(t){
  const n=t??!!this.#s.dot;

  if (this.#e===this) {
    this.#_();
  }

  if (!this.type) {
    const c=this.isStart()&&this.isEnd();

    const l=this.#n.map(_=>{
      const[p,E,h,T]=typeof _=="string"?At.#p(_,this.#t,c):_.toRegExpSource(t);
      this.#t=this.#t||h;
      this.#r=this.#r||T;
      return p;
    }).join("");

    let f="";if(this.isStart()&&typeof this.#n[0]=="string"&&!(this.#n.length===1&&pj.has(this.#n[0]))){
        const p=_j;
        const E=n&&p.has(l.charAt(0))||l.startsWith("\\.")&&p.has(l.charAt(2))||l.startsWith("\\.\\.")&&p.has(l.charAt(4));
        const h=!n&&!t&&p.has(l.charAt(0));
        f=E?fj:h?$c:""
      }let d="";

    if (this.isEnd()&&this.#e.#a&&this.#o?.type==="!") {
      (d = "(?:$|\\/)");
    }

    return [f+l+d,Ya(l),this.#t=!!this.#t,this.#r];
  }

  const r=this.type==="*"||this.type==="+";
  const o=this.type==="!"?"(?:(?!(?:":"(?:";
  let s=this.#f(n);if(this.isStart()&&this.isEnd()&&!s&&this.type!=="!"){
      const c=this.toString();
      this.#n=[c];
      this.type=null;
      this.#t=void 0;
      return [c,Ya(this.toString()),false,false];
    }let i=!r||t||n||!$c?"":this.#f(true);

  if (i===s) {
    (i = "");
  }

  if (i) {
    (s = `(?:${s})(?:${i})*?`);
  }

  let a="";if (this.type==="!"&&this.#d) {
      a=(this.isStart()&&!n?$c:"")+vR;
    } else
      {const c=this.type==="!"?`))${this.isStart()&&!n&&!t?$c:""}${MR})`:this.type==="@"?")":this.type==="?"?")?":this.type==="+"&&i?")":this.type==="*"&&i?")?":`)${this.type}`;a=o+s+c}return[a,Ya(s),this.#t=!!this.#t,this.#r]
}#f(t){return this.#n.map(n=>{
  if (typeof n=="string") {
    throw new Error("string type in extglob ast??");
  }const[r,o,s,i]=n.toRegExpSource(t);
  this.#r=this.#r||i;
  return r;
}).filter(n => !(this.isStart()&&this.isEnd())||!!n).join("|");}static#p(t,n,r=false){
  let o=false;
  let s="";
  let i=false;
  for(let a=0;a<t.length;a++){const c=t.charAt(a);if(o){
    o=false;
    s+=(Ej.has(c)?"\\":"")+c;
    continue
  }if(c==="\\"){
    if (a===t.length-1) {
      s+="\\\\";
    } else {
      o=true;
    }

    continue
  }if(c==="["){const[l,f,d,u]=lj(t,a);if(d){
    s+=l;
    i=i||f;
    a+=d-1;
    n=n||u;
    continue
  }}if(c==="*"){
    if (r&&t==="*") {
      s+=vR;
    } else {
      s+=MR;
    }

    n=true;
    continue
  }if(c==="?"){
    s+=QE;
    n=true;
    continue
  }s+=hj(c)}return[s,Ya(t),!!n,i]
}}

const Tj=(e, {windowsPathsNoEscape:t=false}={}) => t?e.replace(/[?*()[\]]/g,"[$&]"):e.replace(/[?*()[\]\\]/g,"\\$&");

const _t=(e, t, n={}) => {
  Pu(t);
  return !n.nocomment&&t.charAt(0)==="#"?false:new Cl(t,n).match(e);
};

const Sj=/^\*+([^+@!?\*\[\(]*)$/;

const mj=e => t => !t.startsWith(".")&&t.endsWith(e);

const Aj=e => t => t.endsWith(e);

const gj=e => {
  e=e.toLowerCase();

  return t => !t.startsWith(".")&&t.toLowerCase().endsWith(e);
};

const Rj=e => {
  e=e.toLowerCase();

  return t => t.toLowerCase().endsWith(e);
};

const Nj=/^\*+\.\*+$/;

const yj=e => !e.startsWith(".")&&e.includes(".");

const Oj=e => e!=="."&&e!==".."&&e.includes(".");

const bj=/^\.\*+$/;

const Cj=e => e!=="."&&e!==".."&&e.startsWith(".");

const Ij=/^\*+$/;

const Pj=e => e.length!==0&&!e.startsWith(".");

const Mj=e => e.length!==0&&e!=="."&&e!=="..";

const vj=/^\?+([^+@!?\*\[\(]*)?$/;

const Lj=([e,t=""])=>{const n=FM([e]);return t?(t=t.toLowerCase(),r => n(r)&&r.toLowerCase().endsWith(t)):n;};

const wj=([e,t=""])=>{const n=YM([e]);return t?(t=t.toLowerCase(),r => n(r)&&r.toLowerCase().endsWith(t)):n;};

const Dj=([e,t=""])=>{const n=YM([e]);return t?r => n(r)&&r.endsWith(t):n;};

const Uj=([e,t=""])=>{const n=FM([e]);return t?r => n(r)&&r.endsWith(t):n;};

const FM=([e])=>{const t=e.length;return n => n.length===t&&!n.startsWith(".");};

const YM=([e])=>{const t=e.length;return n => n.length===t&&n!=="."&&n!=="..";};

const jM=typeof process=="object"&&process?typeof process.env=="object"&&process.env&&process.env.__MINIMATCH_TESTING_PLATFORM__||process.platform:"posix";
const LR={win32:{sep:"\\"},posix:{sep:"/"}};
const kj=jM==="win32"?LR.win32.sep:LR.posix.sep;
_t.sep=kj;const Bt=Symbol("globstar **");_t.GLOBSTAR=Bt;
const Gj="[^/]";
const Vj=`${Gj}*?`;
const xj="(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
const $j="(?:(?!(?:\\/|^)\\.).)*?";

const Bj=(e, t={}) => n => _t(n,e,t);

_t.filter=Bj;

const $t=(e, t={}) => Object.assign({},e,t);

const Hj=e=>{if (!e||typeof e!="object"||!Object.keys(e).length) {
  return _t;
}const t=_t;return Object.assign((r, o, s={}) => t(r,o,$t(e,s)),{Minimatch:class extends t.Minimatch{constructor(o,s={}){super(o,$t(e,s))}static defaults(o){return t.defaults($t(e,o)).Minimatch}},AST:class extends t.AST{constructor(o,s,i={}){super(o,s,$t(e,i))}static fromGlob(o,s={}){return t.AST.fromGlob(o,$t(e,s))}},unescape:(r, o={}) => t.unescape(r,$t(e,o)),escape:(r, o={}) => t.escape(r,$t(e,o)),filter:(r, o={}) => t.filter(r,$t(e,o)),defaults:r => t.defaults($t(e,r)),makeRe:(r, o={}) => t.makeRe(r,$t(e,o)),braceExpand:(r, o={}) => t.braceExpand(r,$t(e,o)),match:(r, o, s={}) => t.match(r,o,$t(e,s)),sep:t.sep,GLOBSTAR:Bt});};

_t.defaults=Hj;const qM=(e, t={}) => {
  Pu(e);
  return t.nobrace||!/\{(?:(?!\{).)*\}/.test(e)?[e]:ij(e);
};_t.braceExpand=qM;const Fj=(e, t={}) => new Cl(e,t).makeRe();_t.makeRe=Fj;const Yj=(e,t,n={})=>{
  const r=new Cl(t,n);

  e=e.filter(o => r.match(o));

  if (r.options.nonull&&!e.length) {
    e.push(t);
  }

  return e;
};_t.match=Yj;
const wR=/[?*]|[+@!]\(.*?\)|\[|\]/;

const jj=e => e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&");

class Cl{options;set;pattern;windowsPathsNoEscape;nonegate;negate;comment;empty;preserveMultipleSlashes;partial;globSet;globParts;nocase;isWindows;platform;windowsNoMagicRoot;regexp;constructor(t,n={}){
  Pu(t);
  n=n||{};
  this.options=n;
  this.pattern=t;
  this.platform=n.platform||jM;
  this.isWindows=this.platform==="win32";
  this.windowsPathsNoEscape=!!n.windowsPathsNoEscape||n.allowWindowsEscape===false;

  if (this.windowsPathsNoEscape) {
    (this.pattern = this.pattern.replace(/\\/g,"/"));
  }

  this.preserveMultipleSlashes=!!n.preserveMultipleSlashes;
  this.regexp=null;
  this.negate=false;
  this.nonegate=!!n.nonegate;
  this.comment=false;
  this.empty=false;
  this.partial=!!n.partial;
  this.nocase=!!this.options.nocase;
  this.windowsNoMagicRoot=n.windowsNoMagicRoot!==void 0?n.windowsNoMagicRoot:!!(this.isWindows&&this.nocase);
  this.globSet=[];
  this.globParts=[];
  this.set=[];
  this.make();
}hasMagic(){if (this.options.magicalBraces&&this.set.length>1) {
  return true;
}for (const t of this.set) {
  for (const n of t) {
    if (typeof n!="string") {
      return true;
    }
  }
}return false;}debug(...t){}make(){
  const t=this.pattern;
  const n=this.options;
  if(!n.nocomment&&t.charAt(0)==="#"){this.comment=true;return}if(!t){this.empty=true;return}
  this.parseNegate();
  this.globSet=[...new Set(this.braceExpand())];

  if (n.debug) {
    (this.debug = (...s) => console.error(...s));
  }

  this.debug(this.pattern,this.globSet);
  const r=this.globSet.map(s => this.slashSplit(s));
  this.globParts=this.preprocess(r);
  this.debug(this.pattern,this.globParts);
  let o=this.globParts.map((s,i,a)=>{if(this.isWindows&&this.windowsNoMagicRoot){
    const c=s[0]===""&&s[1]===""&&(s[2]==="?"||!wR.test(s[2]))&&!wR.test(s[3]);
    const l=/^[a-z]:/i.test(s[0]);
    if (c) {
      return [...s.slice(0,4),...s.slice(4).map(f => this.parse(f))];
    }if (l) {
      return [s[0],...s.slice(1).map(f => this.parse(f))];
    }
  }return s.map(c => this.parse(c));});
  this.debug(this.pattern,o);

  this.set=o.filter(s => !s.includes(false));

  if (this.isWindows) {
    this.set.forEach((i, s) => {
      if (i[0]===""&&i[1]===""&&this.globParts[s][2]==="?"&&typeof i[3]=="string"&&/^[a-z]:$/i.test(i[3])) {
        (i[2] = "?");
      }
    });
  }

  this.debug(this.pattern,this.set)
}preprocess(t){
  if (this.options.noglobstar) {
    for (let r=0; r<t.length; r++) {
      for (let o=0; o<t[r].length; o++) {
        if (t[r][o]==="**") {
          (t[r][o] = "*");
        }
      }
    }
  }const{optimizationLevel=1}=this.options;

  if (optimizationLevel>=2) {
    t=this.firstPhasePreProcess(t);
    t=this.secondPhasePreProcess(t);
  } else if (optimizationLevel>=1) {
    t=this.levelOneOptimize(t);
  } else {
    t=this.adjascentGlobstarOptimize(t);
  }

  return t;
}adjascentGlobstarOptimize(t){return t.map(n=>{
  let r=-1;

  while ((r=n.indexOf("**",r+1))!==-1) {
    let o=r;

    while (n[o+1]==="**") {
      o++;
    }

    if (o!==r) {
      n.splice(r,o-r);
    }
  }

  return n
});}levelOneOptimize(t){return t.map(n => {
  n=n.reduce((r,o)=>{const s=r[r.length-1];return o==="**"&&s==="**"?r:o===".."&&s&&s!==".."&&s!=="."&&s!=="**"?(r.pop(),r):(r.push(o),r)},[]);
  return n.length===0?[""]:n;
});}levelTwoFileOptimize(t){
  if (!Array.isArray(t)) {
    (t = this.slashSplit(t));
  }

  let n=false;do{
    n=false;

    if (!this.preserveMultipleSlashes)
      {
        for(let o=1;o<t.length-1;o++){
          const s=t[o];

          if (o !== 1 || s !== "" || t[0] !== "") {
            if ((s==="." || s==="")) {
              n=true;
              t.splice(o,1);
              o--;
            }
          }
        }

        if (t[0]==="."&&t.length===2&&(t[1]==="."||t[1]==="")) {
          n=true;
          t.pop();
        }
      }

    let r=0;

    while ((r=t.indexOf("..",r+1))!==-1) {
      const o=t[r-1];

      if (o&&o!=="."&&o!==".."&&o!=="**") {
        n=true;
        t.splice(r-1,2);
        r-=2;
      }
    }
  }while(n);return t.length===0?[""]:t
}firstPhasePreProcess(t){let n=false;do{n=false;for(let r of t){
  let o=-1;

  while ((o=r.indexOf("**",o+1))!==-1) {
    let i=o;

    while (r[i+1]==="**") {
        i++;
      }

    if (i>o) {
      r.splice(o+1,i-o);
    }

    let a=r[o+1];
    const c=r[o+2];
    const l=r[o+3];
    if (a!==".."||!c||c==="."||c===".."||!l||l==="."||l==="..") {
      continue;
    }
    n=true;
    r.splice(o,1);
    const f=r.slice(0);
    f[o]="**";
    t.push(f);
    o--;
  }

  if(!this.preserveMultipleSlashes){
    for(let i=1;i<r.length-1;i++){
      const a=r[i];

      if (i !== 1 || a !== "" || r[0] !== "") {
        if ((a==="." || a==="")) {
          n=true;
          r.splice(i,1);
          i--;
        }
      }
    }

    if (r[0]==="."&&r.length===2&&(r[1]==="."||r[1]==="")) {
      n=true;
      r.pop();
    }
  }let s=0;

  while ((s=r.indexOf("..",s+1))!==-1) {const i=r[s-1];if(i&&i!=="."&&i!==".."&&i!=="**"){
    n=true;const c=s===1&&r[s+1]==="**"?["."]:[];
    r.splice(s-1,2,...c);

    if (r.length===0) {
      r.push("");
    }

    s-=2;
  }}
}}while(n);return t}secondPhasePreProcess(t){for (let n=0; n<t.length-1; n++) {
  for(let r=n+1;r<t.length;r++){const o=this.partsMatch(t[n],t[r],!this.preserveMultipleSlashes);if(o){
    t[n]=[];
    t[r]=o;
    break
  }}
}return t.filter(n => n.length);}partsMatch(t,n,r=false){
  let o=0;
  let s=0;
  let i=[];
  let a="";

  while (o<t.length&&s<n.length) {
    if (t[o]===n[s]) {
      i.push(a==="b"?n[s]:t[o]);
      o++;
      s++;
    } else if (r&&t[o]==="**"&&n[s]===t[o+1]) {
      i.push(t[o]);
      o++;
    } else if (r&&n[s]==="**"&&t[o]===n[s+1]) {
      i.push(n[s]);
      s++;
    } else if(t[o]==="*"&&n[s]&&(this.options.dot||!n[s].startsWith("."))&&n[s]!=="**"){
      if (a==="b") {
        return false;
      }
      a="a";
      i.push(t[o]);
      o++;
      s++;
    }else if (n[s]==="*"&&t[o]&&(this.options.dot||!t[o].startsWith("."))&&t[o]!=="**") {
      if (a==="a") {
        return false;
      }
      a="b";
      i.push(n[s]);
      o++;
      s++;
    } else {
      return false;
    }
  }

  return t.length===n.length&&i
}parseNegate(){
  if (this.nonegate) {
    return;
  }const t=this.pattern;
  let n=false;
  let r=0;
  for (let o=0; o<t.length&&t.charAt(o)==="!"; o++) {
    n=!n;
    r++;
  }

  if (r) {
    (this.pattern = t.slice(r));
  }

  this.negate=n;
}matchOne(t,n,r=false){
  const o=this.options;if(this.isWindows){
      const E=typeof t[0]=="string"&&/^[a-z]:$/i.test(t[0]);
      const h=!E&&t[0]===""&&t[1]===""&&t[2]==="?"&&/^[a-z]:$/i.test(t[3]);
      const T=typeof n[0]=="string"&&/^[a-z]:$/i.test(n[0]);
      const m=!T&&n[0]===""&&n[1]===""&&n[2]==="?"&&typeof n[3]=="string"&&/^[a-z]:$/i.test(n[3]);
      const A=h?3:E?0:void 0;
      const g=m?3:T?0:void 0;
      if(typeof A=="number"&&typeof g=="number"){
        const[R,O]=[t[A],n[g]];

        if (R.toLowerCase()===O.toLowerCase()) {
          n[g]=R;
          g>A?n=n.slice(g):A>g&&(t=t.slice(A));
        }
      }
    }const{optimizationLevel=1}=this.options;

  if (optimizationLevel>=2) {
    (t = this.levelTwoFileOptimize(t));
  }

  this.debug("matchOne",this,{file:t,pattern:n});
  this.debug("matchOne",t.length,n.length);
  for(var i=0,a=0,c=t.length,l=n.length;i<c&&a<l;i++,a++){
    this.debug("matchOne loop");
    const f=n[a];
    const d=t[i];
    this.debug(n,f,d);

    if (f===false) {
      return false;
    }

    if(f===Bt){
      this.debug("GLOBSTAR",[n,f,d]);
      let u=i;
      const _=a+1;
      if(_===l){for (this.debug("** at the end"); i<c; i++) {
        if (t[i]==="."||t[i]===".."||!o.dot&&t[i].charAt(0)===".") {
          return false;
        }
      }return true;}

      while (u<c) {
          const p=t[u];

          this.debug(`
          globstar while`,t,u,n,_,p);

          if (this.matchOne(t.slice(u),n.slice(_),r)) {
            this.debug("globstar found match!",u,c,p);
            return true;
          }

          if(p==="."||p===".."||!o.dot&&p.charAt(0)==="."){this.debug("dot detected!",t,u,n,_);break}
          this.debug("globstar swallow a segment, and continue");
          u++;
        }

      return!!(r&&(this.debug(`
        >>> no match, partial?`,t,u,n,_),u===c))
    }let E;

    if (typeof f=="string") {
      E=d===f;
      this.debug("string match",f,d,E);
    } else {
      E=f.test(d);
      this.debug("pattern match",f,d,E);
    }

    if (!E) {
      return false;
    }
  }if (i===c&&a===l) {
      return true;
    }if (i===c) {
      return r;
    }if (a===l) {
      return i===c-1&&t[i]==="";
    }throw new Error("wtf?")
}braceExpand(){return qM(this.pattern,this.options)}parse(t){
  Pu(t);const n=this.options;if (t==="**") {
      return Bt;
    }if (t==="") {
      return"";
    }
  let r;
  let o=null;

  if ((r = t.match(Ij))) {
    o=n.dot?Mj:Pj;
  } else if ((r = t.match(Sj))) {
    o=(n.nocase?n.dot?Rj:gj:n.dot?Aj:mj)(r[1]);
  } else if ((r = t.match(vj))) {
    o=(n.nocase?n.dot?wj:Lj:n.dot?Dj:Uj)(r);
  } else if ((r = t.match(Nj))) {
    o=n.dot?Oj:yj;
  } else if ((r = t.match(bj))) {
    (o = Cj);
  }

  const s=At.fromGlob(t,this.options).toMMPattern();

  if (o&&typeof s=="object") {
    Reflect.defineProperty(s,"test",{value:o});
  }

  return s;
}makeRe(){
  if (this.regexp||this.regexp===false) {
    return this.regexp;
  }const t=this.set;if (!t.length) {
      this.regexp=false;
      return this.regexp;
    }
  const n=this.options;
  const r=n.noglobstar?Vj:n.dot?xj:$j;
  const o=new Set(n.nocase?["i"]:[]);
  let s=t.map(c=>{
    const l=c.map(f=>{if (f instanceof RegExp) {
      for (const d of f.flags.split("")) {
        o.add(d);
      }
    }return typeof f=="string"?jj(f):f===Bt?Bt:f._src});

    l.forEach((f,d)=>{
      const u=l[d+1];
      const _=l[d-1];

      if (f === Bt && _ !== Bt) {
        if (_===void 0) {
          if (u!==void 0&&u!==Bt) {
            l[d+1]=`(?:\\/|${r}\\/)?${u}`;
          } else {
            l[d]=r;
          }
        } else if (u===void 0) {
          l[d-1]=`${_}(?:\\/|${r})?`;
        } else if (u!==Bt) {
          l[d-1]=`${_}(?:\\/|\\/${r}\\/)${u}`;
          l[d+1]=Bt;
        }
      }
    });

    return l.filter(f => f!==Bt).join("/");
  }).join("|");const[i,a]=t.length>1?["(?:",")"]:["",""];
  s=`^${i}${s}${a}$`;

  if (this.negate) {
    (s = `^(?!${s}).+$`);
  }

  try{this.regexp=new RegExp(s,[...o].join(""))}catch{this.regexp=false}return this.regexp
}slashSplit(t){
  if (this.preserveMultipleSlashes) {
    return t.split("/");
  }

  if (this.isWindows&&/^\/\/[^\/]+/.test(t)) {
    return ["",...t.split(/\/+/)];
  }

  return t.split(/\/+/);
}match(t,n=this.partial){
  this.debug("match",t,this.pattern);

  if (this.comment) {
    return false;
  }

  if (this.empty) {
    return t==="";
  }if (t==="/"&&n) {
        return true;
      }const r=this.options;

  if (this.isWindows) {
    (t = t.split("\\").join("/"));
  }

  const o=this.slashSplit(t);this.debug(this.pattern,"split",o);const s=this.set;this.debug(this.pattern,"set",s);let i=o[o.length-1];if (!i) {
        for (let a=o.length-2; !i&&a>=0; a--) {
          i=o[a];
        }
      }

  for (const c of s) {
    let l=o;

    if (r.matchBase&&c.length===1) {
      (l = [i]);
    }

    if (this.matchOne(l,c,n)) {
      return r.flipNegate?true:!this.negate;
    }
  }

  return r.flipNegate?false:this.negate;
}static defaults(t){return _t.defaults(t).Minimatch}}_t.AST=At;_t.Minimatch=Cl;_t.escape=Tj;_t.unescape=Ya;
const DR="@fastify/otel";
const qj="0.8.0";
const Wj=">=4.0.0 <6";
const UR=["onRequest","preParsing","preValidation","preHandler","preSerialization","onSend","onResponse","onError"];
const Ve={HOOK_NAME:"hook.name",FASTIFY_TYPE:"fastify.type",HOOK_CALLBACK_NAME:"hook.callback.name",ROOT:"fastify.root"};
const Kn={ROUTE:"route-hook",INSTANCE:"hook",HANDLER:"request-handler"};
const In="anonymous";
const ht=Symbol("fastify otel instance");
const zn=Symbol("fastify otel request spans");
const da=Symbol("fastify otel request context");
const kR=Symbol("fastify otel addhook original");
const GR=Symbol("fastify otel setnotfound original");
const Bc=Symbol("fastify otel ignore path");
class Kj extends Ot{constructor(t){
  super(DR,qj,t);
  this.servername=t?.servername??process.env.OTEL_SERVICE_NAME??"fastify";
  this[Bc]=null;
  this._logger=C.diag.createComponentLogger({namespace:DR});

  if (t?.ignorePaths!=null||process.env.OTEL_FASTIFY_IGNORE_PATHS!=null) {const n=t?.ignorePaths??process.env.OTEL_FASTIFY_IGNORE_PATHS;if ((typeof n!="string"||n.length===0)&&typeof n!="function") {
    throw new TypeError("ignorePaths must be a string or a function");
  }const r=_t;this[Bc]=o => typeof n=="function"?n(o):r(o.url,n)}
}enable(){if(this._handleInitialization===void 0&&this.getConfig().registerOnInitialization){
  const t=this.plugin();
  this._handleInitialization=n=>{n.fastify.register(t)};
  Sn.subscribe("fastify.initialization",this._handleInitialization);
}return super.enable()}disable(){
  if (this._handleInitialization) {
    Sn.unsubscribe("fastify.initialization",this._handleInitialization);
    this._handleInitialization=void 0;
  }

  return super.disable();
}init(){return[]}plugin(){
  const t=this;
  n[Symbol.for("skip-override")]=true;
  n[Symbol.for("fastify.display-name")]="@fastify/otel";
  n[Symbol.for("plugin-meta")]={fastify:Wj,name:"@fastify/otel"};
  return n;
  function n(r,o,s){
    r.decorate(ht,t);
    r.decorate(kR,r.addHook);
    r.decorate(GR,r.setNotFoundHandler);

    r.decorateRequest("opentelemetry",function(){const u=this[da];return {span:this[zn],tracer:t.tracer,context:u,inject:(p, E) => C.propagation.inject(u,p,E),extract:(p, E) => C.propagation.extract(u,p,E)};});

    r.decorateRequest(zn,null);
    r.decorateRequest(da,null);

    r.addHook("onRoute",function(d){
      if(t[Bc]?.(d)===true){t._logger.debug(`Ignoring route instrumentation ${d.method} ${d.url} because it matches the ignore path`);return}for (const u of UR) {
          if(d[u]!=null){const _=d[u];if (typeof _=="function") {
            d[u]=f(_,{[Q.ATTR_SERVICE_NAME]:r[ht].servername,[Ve.HOOK_NAME]:`${this.pluginName} - route -> ${u}`,[Ve.FASTIFY_TYPE]:Kn.ROUTE,[Q.ATTR_HTTP_ROUTE]:d.url,[Ve.HOOK_CALLBACK_NAME]:_.name?.length>0?_.name:In});
          } else if(Array.isArray(_)){const p=[];for (const E of _) {
            p.push(f(E,{[Q.ATTR_SERVICE_NAME]:r[ht].servername,[Ve.HOOK_NAME]:`${this.pluginName} - route -> ${u}`,[Ve.FASTIFY_TYPE]:Kn.ROUTE,[Q.ATTR_HTTP_ROUTE]:d.url,[Ve.HOOK_CALLBACK_NAME]:E.name?.length>0?E.name:In}));
          }d[u]=p}}
        }

      if (d.onSend!=null) {
        d.onSend=Array.isArray(d.onSend)?[...d.onSend,i]:[d.onSend,i];
      } else {
        d.onSend=i;
      }

      if (d.onError!=null) {
        d.onError=Array.isArray(d.onError)?[...d.onError,a]:[d.onError,a];
      } else {
        d.onError=a;
      }

      d.handler=f(d.handler,{[Q.ATTR_SERVICE_NAME]:r[ht].servername,[Ve.HOOK_NAME]:`${this.pluginName} - route-handler`,[Ve.FASTIFY_TYPE]:Kn.HANDLER,[Q.ATTR_HTTP_ROUTE]:d.url,[Ve.HOOK_CALLBACK_NAME]:d.handler.name.length>0?d.handler.name:In});
    });

    r.addHook("onRequest",function(d,u,_){
      if (this[ht].isEnabled()===false) {
        return _();
      }if (this[ht][Bc]?.({url:d.url,method:d.method})===true) {
          this[ht]._logger.debug(`Ignoring request ${d.method} ${d.url} because it matches the ignore path`);
          return _();
        }let p=C.context.active();

      if (C.trace.getSpan(p)==null) {
        (p = C.propagation.extract(p,d.headers));
      }

      const E=tl(p);

      if (d.routeOptions.url!=null&&E?.type===Jr.HTTP) {
        (E.route = d.routeOptions.url);
      }

      const h=this[ht].tracer.startSpan("request",{attributes:{[Q.ATTR_SERVICE_NAME]:r[ht].servername,[Ve.ROOT]:"@fastify/otel",[Q.ATTR_HTTP_ROUTE]:d.url,[Q.ATTR_HTTP_REQUEST_METHOD]:d.method}},p);
      d[da]=C.trace.setSpan(p,h);
      d[zn]=h;
      C.context.with(d[da],()=>{_()});
    });

    r.addHook("onResponse",(d, u, _) => {
      const p=d[zn];

      if (p!=null) {
        p.setStatus({code:C.SpanStatusCode.OK,message:"OK"});
        p.setAttributes({[Q.ATTR_HTTP_RESPONSE_STATUS_CODE]:404});
        p.end();
      }

      d[zn]=null;
      _();
    });

    r.addHook=c;
    r.setNotFoundHandler=l;
    s();
    function i(d,u,_,p){
      const E=d[zn];

      if (E!=null) {
        u.statusCode<500&&E.setStatus({code:C.SpanStatusCode.OK,message:"OK"});
        E.setAttributes({[Q.ATTR_HTTP_RESPONSE_STATUS_CODE]:u.statusCode});
        E.end();
      }

      d[zn]=null;
      p(null,_);
    }function a(d,u,_,p){
    const E=d[zn];

    if (E!=null) {
      E.setStatus({code:C.SpanStatusCode.ERROR,message:_.message});
      E.recordException(_);
    }

    p();
  }function c(d,u){const _=this[kR];return UR.includes(d)?_.call(this,d,f(u,{[Q.ATTR_SERVICE_NAME]:r[ht].servername,[Ve.HOOK_NAME]:`${this.pluginName} - ${d}`,[Ve.FASTIFY_TYPE]:Kn.INSTANCE,[Ve.HOOK_CALLBACK_NAME]:u.name?.length>0?u.name:In})):_.call(this,d,u)}function l(d,u){
    const _=this[GR];

    if (typeof d=="function") {
      u=f(d,{[Q.ATTR_SERVICE_NAME]:r[ht].servername,[Ve.HOOK_NAME]:`${this.pluginName} - not-found-handler`,[Ve.FASTIFY_TYPE]:Kn.INSTANCE,[Ve.HOOK_CALLBACK_NAME]:d.name?.length>0?d.name:In});
      _.call(this,u);
    } else {
      d.preValidation!=null&&(d.preValidation=f(d.preValidation,{[Q.ATTR_SERVICE_NAME]:r[ht].servername,[Ve.HOOK_NAME]:`${this.pluginName} - not-found-handler - preValidation`,[Ve.FASTIFY_TYPE]:Kn.INSTANCE,[Ve.HOOK_CALLBACK_NAME]:d.preValidation.name?.length>0?d.preValidation.name:In}));
      d.preHandler!=null&&(d.preHandler=f(d.preHandler,{[Q.ATTR_SERVICE_NAME]:r[ht].servername,[Ve.HOOK_NAME]:`${this.pluginName} - not-found-handler - preHandler`,[Ve.FASTIFY_TYPE]:Kn.INSTANCE,[Ve.HOOK_CALLBACK_NAME]:d.preHandler.name?.length>0?d.preHandler.name:In}));
      u=f(u,{[Q.ATTR_SERVICE_NAME]:r[ht].servername,[Ve.HOOK_NAME]:`${this.pluginName} - not-found-handler`,[Ve.FASTIFY_TYPE]:Kn.INSTANCE,[Ve.HOOK_CALLBACK_NAME]:u.name?.length>0?u.name:In});
      _.call(this,d,u);
    }
  }function f(d,u={}){return function(...p){
      const E=this[ht];
      const [h]=p;
      if (E.isEnabled()===false) {
        return d.call(this,...p);
      }
      const T=h[da]??C.context.active();
      const m=E.tracer.startSpan(`handler - ${d.name?.length>0?d.name:this.pluginName??In}`,{attributes:u},T);
      return C.context.with(C.trace.setSpan(T,m),function(){try{const A=d.call(this,...p);return typeof A?.then=="function"?A.then(g => {
        m.end();
        return g;
      },g => {
        m.setStatus({code:C.SpanStatusCode.ERROR,message:g.message});
        m.recordException(g);
        m.end();
        return Promise.reject(g);
      }):(m.end(),A);}catch(A){
        m.setStatus({code:C.SpanStatusCode.ERROR,message:A.message});
        m.recordException(A);
        m.end();
        throw A;
      }},this);
    };}
  }
}}let Xn;(e => {const t="fastify.name";e.FASTIFY_NAME=t;const n="fastify.type";e.FASTIFY_TYPE=n;const r="hook.name";e.HOOK_NAME=r;const o="plugin.name";e.PLUGIN_NAME=o})(Xn||(Xn={}));let Mu;(e => {const t="middleware";e.MIDDLEWARE=t;const n="request_handler";e.REQUEST_HANDLER=n})(Mu||(Mu={}));let vu;(e => {const t="middleware";e.MIDDLEWARE=t;const n="request handler";e.REQUEST_HANDLER=n})(vu||(vu={}));const Lu=Symbol("opentelemetry.instrumentation.fastify.request_active_span");function VR(e,t,n,r={}){
  const o=t.startSpan(n,{attributes:r});
  const s=e[Lu]||[];
  s.push(o);
  Object.defineProperty(e,Lu,{enumerable:false,configurable:true,value:s});
  return o;
}function Vd(e,t){
  const n=e[Lu]||[];

  if (n.length) {
    n.forEach(r=>{
      if (t) {
        r.setStatus({code:C.SpanStatusCode.ERROR,message:t.message});
        r.recordException(t);
      }

      r.end();
    });

    delete e[Lu];
  }
}function zj(e,t,n){
  let r;
  let o;
  try{
    o=e();

    if (xR(o)) {
      o.then(s => t(void 0,s),s => t(s));
    }
  }catch(s){r=s}finally{if (!xR(o)&&(t(r,o),r)) {
    throw r;
  }return o}
}function xR(e){return typeof e=="object"&&e&&typeof Object.getOwnPropertyDescriptor(e,"then")?.value=="function"||false;}
const Zj="0.1.0";
const Xj="@sentry/instrumentation-fastify-v3";
const $R="anonymous";
const Qj=new Set(["onTimeout","onRequest","preParsing","preValidation","preSerialization","preHandler","onSend","onResponse","onError"]);
class Jj extends Ot{constructor(t={}){super(Xj,Zj,t)}init(){return [new ft("fastify",[">=3.0.0 <4"],t => this._patchConstructor(t))];}_hookOnRequest(){const t=this;return (r, o, s) => {
  if (!t.isEnabled()) {
    return s();
  }t._wrap(o,"send",t._patchSend());
  const i=r;
  const a=tl(C.context.active());
  const c=i.routeOptions?i.routeOptions.url:r.routerPath;

  if (c&&a?.type===Jr.HTTP) {
    (a.route = c);
  }

  const l=r.method||"GET";
  je().setTransactionName(`${l} ${c}`);
  s();
};}_wrapHandler(t,n,r,o){
  const s=this;
  this._diag.debug("Patching fastify route.handler function");

  return function(...i){
    if (!s.isEnabled()) {
      return r.apply(this,i);
    }
    const a=r.name||t||$R;
    const c=`${vu.MIDDLEWARE} - ${a}`;
    const l=i[1];
    const f=VR(l,s.tracer,c,{[Xn.FASTIFY_TYPE]:Mu.MIDDLEWARE,[Xn.PLUGIN_NAME]:t,[Xn.HOOK_NAME]:n});
    const d=o&&i[i.length-1];

    if (d) {
      (i[i.length-1] = function(...u){
        Vd(l);
        d.apply(this,u);
      });
    }

    return C.context.with(C.trace.setSpan(C.context.active(),f),() => zj(() => r.apply(this,i),u=>{
      if (u instanceof Error) {
        f.setStatus({code:C.SpanStatusCode.ERROR,message:u.message});
        f.recordException(u);
      }

      if (!o) {
        Vd(l);
      }
    }));
  };
}_wrapAddHook(){
  const t=this;
  this._diag.debug("Patching fastify server.addHook function");

  return n => (function(...o) {
    const s=o[0];
    const i=o[1];
    const a=this.pluginName;
    if (!Qj.has(s)) {
      return n.apply(this,o);
    }const c=typeof o[o.length-1]=="function"&&i.constructor.name!=="AsyncFunction";return n.apply(this,[s,t._wrapHandler(a,s,i,c)])
  });
}_patchConstructor(t){
  const n=this;function r(...o){
      const s=t.fastify.apply(this,o);
      s.addHook("onRequest",n._hookOnRequest());
      s.addHook("preHandler",n._hookPreHandler());
      eq();
      n._wrap(s,"addHook",n._wrapAddHook());
      return s;
    }

  if (t.errorCodes!==void 0) {
    (r.errorCodes = t.errorCodes);
  }

  r.fastify=r;
  r.default=r;
  return r;
}_patchSend(){
  const t=this;
  this._diag.debug("Patching fastify reply.send function");

  return r => (function(...s) {const i=s[0];return t.isEnabled()?tr(() => r.apply(this,s),a=>{
    if (!a&&i instanceof Error) {
      (a = i);
    }

    Vd(this,a);
  }):r.apply(this,s);});
}_hookPreHandler(){
  const t=this;
  this._diag.debug("Patching fastify preHandler function");

  return function(r,o,s){
    if (!t.isEnabled()) {
      return s();
    }
    const i=r;
    const a=i.routeOptions?.handler||i.context?.handler;
    const c=a?.name.startsWith("bound ")?a.name.substring(6):a?.name;
    const l=`${vu.REQUEST_HANDLER} - ${c||this.pluginName||$R}`;
    const f={[Xn.PLUGIN_NAME]:this.pluginName,[Xn.FASTIFY_TYPE]:Mu.REQUEST_HANDLER,[Q.SEMATTRS_HTTP_ROUTE]:i.routeOptions?i.routeOptions.url:r.routerPath};

    if (c) {
      (f[Xn.FASTIFY_NAME] = c);
    }

    const d=VR(o,t.tracer,l,f);WM(d);const{requestHook}=t.getConfig();

    if (requestHook) {
      tr(() => requestHook(d,{request:r}),_=>{
        if (_) {
          t._diag.error("request hook failed",_);
        }
      },true);
    }

    return C.context.with(C.trace.setSpan(C.context.active(),d),()=>{s()});
  };
}}function eq(){
  const e=he();

  if (e) {
    e.on("spanStart",t=>{WM(t)});
  }
}function WM(e){
  const t=Re(e).data;
  const n=t["fastify.type"];
  if (t[Ee]||!n) {
    return;
  }e.setAttributes({[Ge]:"auto.http.otel.fastify",[Ee]:`${n}.fastify`});const r=t["fastify.name"]||t["plugin.name"]||t["hook.name"];if(typeof r=="string"){const o=r.replace(/^fastify -> /,"").replace(/^@fastify\/otel -> /,"");e.updateName(o)}
}
const Il="Fastify";

const tq=Ne(`${Il}.v3`,() => new Jj);

function nq(){const e=he();if (e) {
  return e.getIntegrationByName(Il)
}}function BR(e,t,n,r){
  const o=nq()?.getShouldHandleError()||KM;

  if (r==="diagnostics-channel") {
    (this.diagnosticsChannelExists = true);
  }

  if (this.diagnosticsChannelExists&&r==="onError-hook")
    {
      if (io) {
        x.warn("Fastify error handler was already registered via diagnostics channel.","You can safely remove `setupFastifyErrorHandler` call and set `shouldHandleError` on the integration options.");
      }

      return
    }

  if (o(e,t,n)) {
    xe(e,{mechanism:{handled:false,type:"auto.function.fastify"}});
  }
}

const rq=Ne(`${Il}.v5`,()=>{
  const e=new Kj;
  const t=e.plugin();
  ou.subscribe("fastify.initialization",n=>{const r=n.fastify;r?.register(t).after(o=>{
    if (o) {
      if (io) {
        x.error("Failed to setup Fastify instrumentation",o);
      }
    } else {
      iq();
      r&&aq(r);
    }
  })});
  ou.subscribe("tracing:fastify.request.handler:error",n=>{const{error,request,reply}=n;BR.call(BR,error,request,reply,"diagnostics-channel")});
  return e;
});

const oq=(({shouldHandleError})=>{let t;return {name:Il,setupOnce(){
  t=shouldHandleError||KM;
  tq();
  rq();
},getShouldHandleError(){return t},setShouldHandleError(n){t=n}};});

const sq=(e={}) => oq(e);

function KM(e,t,n){const r=n.statusCode;return r>=500||r<=299}function zM(e){
  const t=Re(e);
  const n=t.description;
  const r=t.data;
  const o=r["fastify.type"];
  const s=o==="hook";
  const i=o===n?.startsWith("handler -");
  const a=n==="request"||o==="request-handler";
  if (r[Ee]||!i&&!a&&!s) {
    return;
  }const c=s?"hook":i?"middleware":a?"request-handler":"<unknown>";e.setAttributes({[Ge]:"auto.http.otel.fastify",[Ee]:`${c}.fastify`});const l=r["fastify.name"]||r["plugin.name"]||r["hook.name"];if(typeof l=="string"){const f=l.replace(/^fastify -> /,"").replace(/^@fastify\/otel -> /,"");e.updateName(f)}
}function iq(){
  const e=he();

  if (e) {
    e.on("spanStart",t=>{zM(t)});
  }
}function aq(e){e.addHook("onRequest",async(t,n)=>{
  if(t.opentelemetry){
    const{span}=t.opentelemetry();

    if (span) {
      zM(span);
    }
  }
  const r=t.routeOptions?.url;
  const o=t.method||"GET";
  je().setTransactionName(`${o} ${r}`)
})}
const xd={};
const fa={};
const $d={};
let HR;
function ZM(){
  if (!HR) {
    HR=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.SpanNames = void 0;
      e.TokenKind = void 0;
      e.AllowedOperationTypes = void 0;

      (t => {
        t.QUERY="query";
        t.MUTATION="mutation";
        t.SUBSCRIPTION="subscription";
      })(e.AllowedOperationTypes||(e.AllowedOperationTypes={}));

      (t => {
        t.SOF="<SOF>";
        t.EOF="<EOF>";
        t.BANG="!";
        t.DOLLAR="$";
        t.AMP="&";
        t.PAREN_L="(";
        t.PAREN_R=")";
        t.SPREAD="...";
        t.COLON=":";
        t.EQUALS="=";
        t.AT="@";
        t.BRACKET_L="[";
        t.BRACKET_R="]";
        t.BRACE_L="{";
        t.PIPE="|";
        t.BRACE_R="}";
        t.NAME="Name";
        t.INT="Int";
        t.FLOAT="Float";
        t.STRING="String";
        t.BLOCK_STRING="BlockString";
        t.COMMENT="Comment";
      })(e.TokenKind||(e.TokenKind={}));

      (t => {
        t.EXECUTE="graphql.execute";
        t.PARSE="graphql.parse";
        t.RESOLVE="graphql.resolve";
        t.VALIDATE="graphql.validate";
        t.SCHEMA_VALIDATE="graphql.validateSchema";
        t.SCHEMA_PARSE="graphql.parseSchema";
      })(e.SpanNames||(e.SpanNames={}));
    })($d);
  }

  return $d;
}
const Bd={};
let FR;
function XM(){
  if (!FR) {
    FR=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.AttributeNames=void 0;

      (t => {
        t.SOURCE="graphql.source";
        t.FIELD_NAME="graphql.field.name";
        t.FIELD_PATH="graphql.field.path";
        t.FIELD_TYPE="graphql.field.type";
        t.OPERATION_TYPE="graphql.operation.type";
        t.OPERATION_NAME="graphql.operation.name";
        t.VARIABLES="graphql.variables.";
        t.ERROR_VALIDATION_NAME="graphql.validation.error";
      })(e.AttributeNames||(e.AttributeNames={}));
    })(Bd);
  }

  return Bd;
}
const Cr={};
let YR;
function JE(){
  if (!YR) {
    YR=1;
    Object.defineProperty(Cr,"__esModule",{value:true});
    Cr.OTEL_GRAPHQL_DATA_SYMBOL=Cr.OTEL_PATCHED_SYMBOL=void 0;
    Cr.OTEL_PATCHED_SYMBOL=Symbol.for("opentelemetry.patched");
    Cr.OTEL_GRAPHQL_DATA_SYMBOL=Symbol.for("opentelemetry.graphql_data");
  }

  return Cr;
}
const _a={};
let jR;
function cq(){
  if (!jR) {
    jR=1;
    Object.defineProperty(_a,"__esModule",{value:true});
    _a.OPERATION_NOT_SUPPORTED=void 0;
    JE();
    _a.OPERATION_NOT_SUPPORTED="Operation$operationName$not supported";
  }

  return _a;
}
const Hd={};
let qR;
function uq(){
  if (!qR) {
    qR=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.wrapFieldResolver = void 0;
      e.wrapFields = void 0;
      e.getSourceFromLocation = void 0;
      e.getOperation = void 0;
      e.endSpan = void 0;
      e.addSpanSource = void 0;
      e.addInputVariableAttributes = void 0;
      e.isPromise = void 0;
      const t=Pe();
      const n=ZM();
      const r=XM();
      const o=JE();
      const s=Object.values(n.AllowedOperationTypes);

      const i=D => typeof D?.then=="function";

      e.isPromise=i;const a=D => typeof D=="object"&&D!==null;function c(D,k,Y){
      if (Array.isArray(Y)) {
        Y.forEach((oe,ae)=>{c(D,`${k}.${ae}`,oe)});
      } else if (Y instanceof Object) {
        Object.entries(Y).forEach(([oe,ae])=>{c(D,`${k}.${oe}`,ae)});
      } else {
        D.setAttribute(`${r.AttributeNames.VARIABLES}${String(k)}`,Y);
      }
    }function l(D,k){Object.entries(k).forEach(([Y,oe])=>{c(D,Y,oe)})}e.addInputVariableAttributes=l;function f(D,k,Y,oe,ae){const ne=b(k,Y,oe,ae);D.setAttribute(r.AttributeNames.SOURCE,ne)}e.addSpanSource=f;function d(D,k,Y,oe,ae){
        let ne=h(Y,ae);if (ne) {
          return {field:ne,spanAdded:false};
        }const M=k().flatResolveSpans?m(Y):T(Y,ae);
        ne={span:u(D,k,Y,oe,ae,M)};
        E(Y,ae,ne);
        return {field:ne,spanAdded:true};
      }function u(D,k,Y,oe,ae,ne){
      const P={[r.AttributeNames.FIELD_NAME]:oe.fieldName,[r.AttributeNames.FIELD_PATH]:ae.join("."),[r.AttributeNames.FIELD_TYPE]:oe.returnType.toString()};
      const M=D.startSpan(`${n.SpanNames.RESOLVE} ${P[r.AttributeNames.FIELD_PATH]}`,{attributes:P},ne?t.trace.setSpan(t.context.active(),ne):void 0);
      const G=Y[o.OTEL_GRAPHQL_DATA_SYMBOL].source;

      const V=oe.fieldNodes.find(K => K.kind==="Field");

      if (V) {
        f(M,G.loc,k().allowValues,V.loc?.start,V.loc?.end);
      }

      return M;
    }function _(D,k){
      if (k) {
        D.recordException(k);
      }

      D.end();
    }e.endSpan=_;function p(D,k){if (!(!D||!Array.isArray(D.definitions))) {
        return k?D.definitions.filter(Y => s.includes(Y?.operation)).find(Y => k===Y?.name?.value):D.definitions.find(Y => s.includes(Y?.operation));
      }}e.getOperation=p;function E(D,k,Y){return D[o.OTEL_GRAPHQL_DATA_SYMBOL].fields[k.join(".")]=Y}function h(D,k){return D[o.OTEL_GRAPHQL_DATA_SYMBOL].fields[k.join(".")]}function T(D,k){for(let Y=k.length-1;Y>0;Y--){const oe=h(D,k.slice(0,Y));if (oe) {
        return oe.span
      }}return m(D)}function m(D){return D[o.OTEL_GRAPHQL_DATA_SYMBOL].span}function A(D,k){
      const Y=[];let oe=k;

      while (oe) {
        let ae=oe.key;

        if (D&&typeof ae=="number") {
          (ae = "*");
        }

        Y.push(String(ae));
        oe=oe.prev;
      }

      return Y.reverse()
    }function g(D){return O(`
      `,D)}function R(D){return O(" ",D)}function O(D,k){let Y="";for (let oe=0; oe<k; oe++) {
        Y+=D;
      }return Y}const I=[n.TokenKind.FLOAT,n.TokenKind.STRING,n.TokenKind.INT,n.TokenKind.BLOCK_STRING];function b(D,k=false,Y,oe){let ae="";if(D?.startToken){
      const ne=typeof Y=="number"?Y:D.start;
      const P=typeof oe=="number"?oe:D.end;
      let M=D.startToken.next;
      let G=1;

      while (M) {
        if(M.start<ne){
          M=M.next;
          G=M?.line;
          continue
        }if(M.end>P){
            M=M.next;
            G=M?.line;
            continue
          }
        let V=M.value||M.kind;
        let K="";

        if (!k&&I.includes(M.kind)) {
          (V = "*");
        }

        if (M.kind===n.TokenKind.STRING) {
          (V = `"${V}"`);
        }

        if (M.kind===n.TokenKind.EOF) {
          (V = "");
        }

        if (M.line>G) {
          ae+=g(M.line-G);
          G=M.line;
          K=R(M.column-1);
        } else if (M.line===M.prev?.line) {
          (K = R(M.start-(M.prev?.end||0)));
        }

        ae+=K+V;

        if (M) {
          (M = M.next);
        }
      }
    }return ae}e.getSourceFromLocation=b;function L(D,k,Y){
        if (!D||D[o.OTEL_PATCHED_SYMBOL]) {
          return;
        }const oe=D.getFields();
        D[o.OTEL_PATCHED_SYMBOL]=true;

        Object.keys(oe).forEach(ae=>{const ne=oe[ae];if(ne&&(ne.resolve&&(ne.resolve=F(k,Y,ne.resolve)),ne.type)){const P=U(ne.type);for (const M of P) {
          L(M,k,Y)
        }}});
      }e.wrapFields=L;function U(D){
      if ("ofType"in D) {
        return U(D.ofType);
      }

      if (q(D)) {
        return D.getTypes();
      }

      if (H(D)) {
        return [D];
      }

      return [];
    }function q(D){return"getTypes"in D&&typeof D.getTypes=="function"}function H(D){return"getFields"in D&&typeof D.getFields=="function"}
      const $=(D,k,Y)=>{
        if (Y) {
          D.recordException(k);
          D.setStatus({code:t.SpanStatusCode.ERROR,message:k.message});
          D.end();
        }
      };
      const B=(D,k)=>{
        if (k) {
          D.end();
        }
      };
      function F(D,k,Y,oe=false){
        if (ae[o.OTEL_PATCHED_SYMBOL]||typeof Y!="function") {
          return Y;
        }function ae(ne,P,M,G){
          if (!Y) {
            return;
          }const V=k();if (V.ignoreTrivialResolveSpans&&oe&&(a(ne)||typeof ne=="function")&&typeof ne[G.fieldName]!="function") {
            return Y.call(this,ne,P,M,G);
          }if (!M[o.OTEL_GRAPHQL_DATA_SYMBOL]) {
            return Y.call(this,ne,P,M,G);
          }
          const K=A(V.mergeItems,G&&G.path);

          const X=K.filter(z => typeof z=="string").length;

          let v;
          let w=false;
          if (V.depth>=0&&V.depth<X) {
            v=T(M,K);
          } else {
            const{field,spanAdded}=d(D,k,M,G,K);
            v=field.span;
            w=spanAdded;
          }return t.context.with(t.trace.setSpan(t.context.active(),v),()=>{try{const z=Y.call(this,ne,P,M,G);return (0,e.isPromise)(z)?z.then(j => {
            B(v,w);
            return j;
          },j=>{
            $(v,j,w);
            throw j;
          }):(B(v,w),z);}catch(z){
            $(v,z,w);
            throw z;
          }});
        }
        ae[o.OTEL_PATCHED_SYMBOL]=true;
        return ae;
      }e.wrapFieldResolver=F
    })(Hd);
  }

  return Hd;
}
const Ir={};
let WR;
function lq(){
  if (!WR) {
    WR=1;
    Object.defineProperty(Ir,"__esModule",{value:true});
    Ir.PACKAGE_NAME=Ir.PACKAGE_VERSION=void 0;
    Ir.PACKAGE_VERSION="0.56.0";
    Ir.PACKAGE_NAME="@opentelemetry/instrumentation-graphql";
  }

  return Ir;
}let KR;function dq(){
  if (KR) {
    return fa;
  }
  KR=1;
  Object.defineProperty(fa,"__esModule",{value:true});
  fa.GraphQLInstrumentation=void 0;
  const e=Pe();
  const t=Le;
  const n=ZM();
  const r=XM();
  const o=JE();
  const s=cq();
  const i=uq();
  const a=lq();
  const c={mergeItems:false,depth:-1,allowValues:false,ignoreResolveSpans:false};
  const l=[">=14.0.0 <17"];
  class f extends t.InstrumentationBase{constructor(u={}){super(a.PACKAGE_NAME,a.PACKAGE_VERSION,{...c,...u})}setConfig(u={}){super.setConfig({...c,...u})}init(){
    const u=new t.InstrumentationNodeModuleDefinition("graphql",l);
    u.files.push(this._addPatchingExecute());
    u.files.push(this._addPatchingParser());
    u.files.push(this._addPatchingValidate());
    return u;
  }_addPatchingExecute(){return new t.InstrumentationNodeModuleFile("graphql/execution/execute.js",l,u => {
    if ((0,t.isWrapped)(u.execute)) {
      this._unwrap(u,"execute");
    }

    this._wrap(u,"execute",this._patchExecute(u.defaultFieldResolver));
    return u;
  },u=>{
    if (u) {
      this._unwrap(u,"execute");
    }
  });}_addPatchingParser(){return new t.InstrumentationNodeModuleFile("graphql/language/parser.js",l,u => {
    if ((0,t.isWrapped)(u.parse)) {
      this._unwrap(u,"parse");
    }

    this._wrap(u,"parse",this._patchParse());
    return u;
  },u=>{
    if (u) {
      this._unwrap(u,"parse");
    }
  });}_addPatchingValidate(){return new t.InstrumentationNodeModuleFile("graphql/validation/validate.js",l,u => {
    if ((0,t.isWrapped)(u.validate)) {
      this._unwrap(u,"validate");
    }

    this._wrap(u,"validate",this._patchValidate());
    return u;
  },u=>{
    if (u) {
      this._unwrap(u,"validate");
    }
  });}_patchExecute(u){const _=this;return E => (function(...args) {
    let T;if(args.length>=2){const g=args;T=_._wrapExecuteArgs(g[0],g[1],g[2],g[3],g[4],g[5],g[6],g[7],u)}else{const g=args[0];T=_._wrapExecuteArgs(g.schema,g.document,g.rootValue,g.contextValue,g.variableValues,g.operationName,g.fieldResolver,g.typeResolver,u)}
    const m=(0,i.getOperation)(T.document,T.operationName);
    const A=_._createExecuteSpan(m,T);
    T.contextValue[o.OTEL_GRAPHQL_DATA_SYMBOL]={source:T.document?T.document||T.document[o.OTEL_GRAPHQL_DATA_SYMBOL]:void 0,span:A,fields:{}};

    return e.context.with(e.trace.setSpan(e.context.active(),A),() => (0,t.safeExecuteInTheMiddle)(() => E.apply(this,[T]),(g,R)=>{_._handleExecutionResult(A,g,R)}));
  });}_handleExecutionResult(u,_,p){const E=this.getConfig();if(p===void 0||_){(0,i.endSpan)(u,_);return}if ((0,i.isPromise)(p)) {
    p.then(h=>{if(typeof E.responseHook!="function"){(0,i.endSpan)(u);return}this._executeResponseHook(u,h)},h=>{(0,i.endSpan)(u,h)});
  } else
    {if(typeof E.responseHook!="function"){(0,i.endSpan)(u);return}this._executeResponseHook(u,p)}}_executeResponseHook(u,_){
    const{responseHook}=this.getConfig();

    if (responseHook) {
      (0,t.safeExecuteInTheMiddle)(()=>{responseHook(u,_)},E=>{
        if (E) {
          this._diag.error("Error running response hook",E);
        }

        (0,i.endSpan)(u,void 0);
      },true);
    }
  }_patchParse(){const u=this;return p => (function(h, T) {return u._parse(this,p,h,T)});}_patchValidate(){const u=this;return p => (function(h, T, m, A, g) {return u._validate(this,p,h,T,m,g,A)});}_parse(u,_,p,E){
    const h=this.getConfig();
    const T=this.tracer.startSpan(n.SpanNames.PARSE);
    return e.context.with(e.trace.setSpan(e.context.active(),T),() => (0,t.safeExecuteInTheMiddle)(() => _.call(u,p,E),(m,A)=>{
      if (A) {
        if ((0,i.getOperation)(A)) {
          if (A.loc) {
            (0,i.addSpanSource)(T,A.loc,h.allowValues);
          }
        } else {
          T.updateName(n.SpanNames.SCHEMA_PARSE);
        }
      }

      (0,i.endSpan)(T,m);
    }));
  }_validate(u,_,p,E,h,T,m){const A=this.tracer.startSpan(n.SpanNames.VALIDATE,{});return e.context.with(e.trace.setSpan(e.context.active(),A),() => (0,t.safeExecuteInTheMiddle)(() => _.call(u,p,E,h,m,T),(g,R)=>{
    if (!E.loc) {
      A.updateName(n.SpanNames.SCHEMA_VALIDATE);
    }

    if (R&&R.length) {
      A.recordException({name:r.AttributeNames.ERROR_VALIDATION_NAME,message:JSON.stringify(R)});
    }

    (0,i.endSpan)(A,g);
  }));}_createExecuteSpan(u,_){
    const p=this.getConfig();
    const E=this.tracer.startSpan(n.SpanNames.EXECUTE,{});
    if(u){
      const{operation,name}=u;E.setAttribute(r.AttributeNames.OPERATION_TYPE,operation);const m=name?.value;

      if (m) {
        E.setAttribute(r.AttributeNames.OPERATION_NAME,m);
        E.updateName(`${operation} ${m}`);
      } else {
        E.updateName(operation);
      }
    }else{
      let h=" ";

      if (_.operationName) {
        (h = ` "${_.operationName}" `);
      }

      h=s.OPERATION_NOT_SUPPORTED.replace("$operationName$",h);
      E.setAttribute(r.AttributeNames.OPERATION_NAME,h);
    }

    if (_.document?.loc) {
      (0,i.addSpanSource)(E,_.document.loc,p.allowValues);
    }

    if (_.variableValues&&p.allowValues) {
      (0,i.addInputVariableAttributes)(E,_.variableValues);
    }

    return E;
  }_wrapExecuteArgs(u,_,p,E,h,T,m,A,g){
    if (!E) {
      (E = {});
    }

    if (E[o.OTEL_GRAPHQL_DATA_SYMBOL]||this.getConfig().ignoreResolveSpans) {
      return{schema:u,document:_,rootValue:p,contextValue:E,variableValues:h,operationName:T,fieldResolver:m,typeResolver:A};
    }

    const R=m==null;
    const O=m??g;

    m=(0,i.wrapFieldResolver)(this.tracer,() => this.getConfig(),O,R);

    if (u) {
      (0,i.wrapFields)(u.getQueryType(),this.tracer,() => this.getConfig());
      (0,i.wrapFields)(u.getMutationType(),this.tracer,() => this.getConfig());
    }

    return {schema:u,document:_,rootValue:p,contextValue:E,variableValues:h,operationName:T,fieldResolver:m,typeResolver:A};
  }}
  fa.GraphQLInstrumentation=f;
  return fa;
}let zR;function fq(){
  if (!zR) {
    zR=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.GraphQLInstrumentation=void 0;
      const t=dq();Object.defineProperty(e,"GraphQLInstrumentation",{enumerable:true,get() {return t.GraphQLInstrumentation}})
    })(xd);
  }

  return xd;
}const _q=fq();
const QM="Graphql";

const pq=Ne(QM,_q.GraphQLInstrumentation,e=>{const t=JM(e);return {...t,responseHook(n,r){
  yt(n,"auto.graphql.otel.graphql");

  if (r.errors?.length&&!Re(n).status) {
    n.setStatus({code:C.SpanStatusCode.ERROR});
  }

  const s=Re(n).data;
  const i=s["graphql.operation.type"];
  const a=s["graphql.operation.name"];
  if(t.useOperationNameForRootSpan&&i){
    const c=Yt(n);
    const f=Re(c).data[Fa]||[];
    const d=a?`${i} ${a}`:`${i}`;

    if (Array.isArray(f)) {
      f.push(d);
      c.setAttribute(Fa,f);
    } else if (typeof f=="string") {
      c.setAttribute(Fa,[f,d]);
    } else {
      c.setAttribute(Fa,d);
    }

    if (!Re(c).data["original-description"]) {
      c.setAttribute("original-description",Re(c).description);
    }

    c.updateName(`${Re(c).data["original-description"]} (${Tq(f)})`);
  }
}};});

const Eq=((e={}) => ({
  name:QM,
  setupOnce(){pq(JM(e))}
}));

const hq=Eq;
function JM(e){return {ignoreResolveSpans:true,ignoreTrivialResolveSpans:true,useOperationNameForRootSpan:true,...e};}function Tq(e){if(Array.isArray(e)){const t=e.slice().sort();return t.length<=5?t.join(", "):`${t.slice(0,5).join(", ")}, +${t.length-5}`}return`${e}`}
const Fd={};
const pa={};
const Ea={};
let ZR;
function Sq(){
  if (!ZR) {
    ZR=1;
    Object.defineProperty(Ea,"__esModule",{value:true});
    Ea.EVENT_LISTENERS_SET=void 0;
    Ea.EVENT_LISTENERS_SET=Symbol("opentelemetry.instrumentation.kafkajs.eventListenersSet");
  }

  return Ea;
}
const ha={};
let XR;
function mq(){
  if (!XR) {
    XR=1;
    Object.defineProperty(ha,"__esModule",{value:true});
    ha.bufferTextMapGetter=void 0;

    ha.bufferTextMapGetter={get(e,t){if (!e) {
      return;
    }const n=Object.keys(e);for (const r of n) {
      if (r===t||r.toLowerCase()===t) {
        return e[r]?.toString()
      }
    }},keys(e){return e?Object.keys(e):[]}};
  }

  return ha;
}
const Se={};
let QR;
function Aq(){
  if (!QR) {
    QR=1;
    Object.defineProperty(Se,"__esModule",{value:true});
    Se.METRIC_MESSAGING_PROCESS_DURATION=Se.METRIC_MESSAGING_CLIENT_SENT_MESSAGES=Se.METRIC_MESSAGING_CLIENT_OPERATION_DURATION=Se.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES=Se.MESSAGING_SYSTEM_VALUE_KAFKA=Se.MESSAGING_OPERATION_TYPE_VALUE_SEND=Se.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE=Se.MESSAGING_OPERATION_TYPE_VALUE_PROCESS=Se.ATTR_MESSAGING_SYSTEM=Se.ATTR_MESSAGING_OPERATION_TYPE=Se.ATTR_MESSAGING_OPERATION_NAME=Se.ATTR_MESSAGING_KAFKA_OFFSET=Se.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE=Se.ATTR_MESSAGING_KAFKA_MESSAGE_KEY=Se.ATTR_MESSAGING_DESTINATION_PARTITION_ID=Se.ATTR_MESSAGING_DESTINATION_NAME=Se.ATTR_MESSAGING_BATCH_MESSAGE_COUNT=void 0;
    Se.ATTR_MESSAGING_BATCH_MESSAGE_COUNT="messaging.batch.message_count";
    Se.ATTR_MESSAGING_DESTINATION_NAME="messaging.destination.name";
    Se.ATTR_MESSAGING_DESTINATION_PARTITION_ID="messaging.destination.partition.id";
    Se.ATTR_MESSAGING_KAFKA_MESSAGE_KEY="messaging.kafka.message.key";
    Se.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE="messaging.kafka.message.tombstone";
    Se.ATTR_MESSAGING_KAFKA_OFFSET="messaging.kafka.offset";
    Se.ATTR_MESSAGING_OPERATION_NAME="messaging.operation.name";
    Se.ATTR_MESSAGING_OPERATION_TYPE="messaging.operation.type";
    Se.ATTR_MESSAGING_SYSTEM="messaging.system";
    Se.MESSAGING_OPERATION_TYPE_VALUE_PROCESS="process";
    Se.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE="receive";
    Se.MESSAGING_OPERATION_TYPE_VALUE_SEND="send";
    Se.MESSAGING_SYSTEM_VALUE_KAFKA="kafka";
    Se.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES="messaging.client.consumed.messages";
    Se.METRIC_MESSAGING_CLIENT_OPERATION_DURATION="messaging.client.operation.duration";
    Se.METRIC_MESSAGING_CLIENT_SENT_MESSAGES="messaging.client.sent.messages";
    Se.METRIC_MESSAGING_PROCESS_DURATION="messaging.process.duration";
  }

  return Se;
}
const Pr={};
let JR;
function gq(){
  if (!JR) {
    JR=1;
    Object.defineProperty(Pr,"__esModule",{value:true});
    Pr.PACKAGE_NAME=Pr.PACKAGE_VERSION=void 0;
    Pr.PACKAGE_VERSION="0.18.0";
    Pr.PACKAGE_NAME="@opentelemetry/instrumentation-kafkajs";
  }

  return Pr;
}let eN;function Rq(){
  if (eN) {
    return pa;
  }
  eN=1;
  Object.defineProperty(pa,"__esModule",{value:true});
  pa.KafkaJsInstrumentation=void 0;
  const e=Pe();
  const t=Le;
  const n=pt();
  const r=Sq();
  const o=mq();
  const s=Aq();
  const i=gq();
  function a(d,u,_){return p=>{d.add(u,{..._,...(p ? {[n.ATTR_ERROR_TYPE]:p} : {})})};}function c(d,u,_){return p=>{d.record((Date.now()-u)/1000/* 1e3 */,{..._,...(p ? {[n.ATTR_ERROR_TYPE]:p} : {})})};}const l=[0.005/* .005 */,0.01/* .01 */,0.025/* .025 */,0.05/* .05 */,0.075/* .075 */,0.1/* .1 */,0.25/* .25 */,0.5/* .5 */,0.75/* .75 */,1,2.5,5,7.5,10];class f extends t.InstrumentationBase{constructor(u={}){super(i.PACKAGE_NAME,i.PACKAGE_VERSION,u)}_updateMetricInstruments(){
    this._clientDuration=this.meter.createHistogram(s.METRIC_MESSAGING_CLIENT_OPERATION_DURATION,{advice:{explicitBucketBoundaries:l}});
    this._sentMessages=this.meter.createCounter(s.METRIC_MESSAGING_CLIENT_SENT_MESSAGES);
    this._consumedMessages=this.meter.createCounter(s.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES);
    this._processDuration=this.meter.createHistogram(s.METRIC_MESSAGING_PROCESS_DURATION,{advice:{explicitBucketBoundaries:l}});
  }init(){const u=p=>{
  if ((0,t.isWrapped)(p?.Kafka?.prototype.producer)) {
    this._unwrap(p.Kafka.prototype,"producer");
  }

  if ((0,t.isWrapped)(p?.Kafka?.prototype.consumer)) {
    this._unwrap(p.Kafka.prototype,"consumer");
  }
};return new t.InstrumentationNodeModuleDefinition("kafkajs",[">=0.3.0 <3"],p => {
    u(p);
    this._wrap(p?.Kafka?.prototype,"producer",this._getProducerPatch());
    this._wrap(p?.Kafka?.prototype,"consumer",this._getConsumerPatch());
    return p;
  },u);}_getConsumerPatch(){const u=this;return _ => (function(...E) {
  const h=_.apply(this,E);

  if ((0,t.isWrapped)(h.run)) {
    u._unwrap(h,"run");
  }

  u._wrap(h,"run",u._getConsumerRunPatch());
  u._setKafkaEventListeners(h);
  return h;
});}_setKafkaEventListeners(u){
  if (!u[r.EVENT_LISTENERS_SET]) {
    u.events?.REQUEST&&u.on(u.events.REQUEST,this._recordClientDurationMetric.bind(this));
    u[r.EVENT_LISTENERS_SET]=true;
  }
}_recordClientDurationMetric(u){const[_,p]=u.payload.broker.split(":");this._clientDuration.record(u.payload.duration/1000/* 1e3 */,{[s.ATTR_MESSAGING_SYSTEM]:s.MESSAGING_SYSTEM_VALUE_KAFKA,[s.ATTR_MESSAGING_OPERATION_NAME]:`${u.payload.apiName}`,[n.ATTR_SERVER_ADDRESS]:_,[n.ATTR_SERVER_PORT]:Number.parseInt(p,10)})}_getProducerPatch(){const u=this;return _ => (function(...E) {
  const h=_.apply(this,E);

  if ((0,t.isWrapped)(h.sendBatch)) {
    u._unwrap(h,"sendBatch");
  }

  u._wrap(h,"sendBatch",u._getSendBatchPatch());

  if ((0,t.isWrapped)(h.send)) {
    u._unwrap(h,"send");
  }

  u._wrap(h,"send",u._getSendPatch());

  if ((0,t.isWrapped)(h.transaction)) {
    u._unwrap(h,"transaction");
  }

  u._wrap(h,"transaction",u._getProducerTransactionPatch());
  u._setKafkaEventListeners(h);
  return h;
});}_getConsumerRunPatch(){const u=this;return _ => (function(...E) {
  const h=E[0];

  if (h?.eachMessage) {
    (0,t.isWrapped)(h.eachMessage)&&u._unwrap(h,"eachMessage");
    u._wrap(h,"eachMessage",u._getConsumerEachMessagePatch());
  }

  if (h?.eachBatch) {
    (0,t.isWrapped)(h.eachBatch)&&u._unwrap(h,"eachBatch");
    u._wrap(h,"eachBatch",u._getConsumerEachBatchPatch());
  }

  return _.call(this,h);
});}_getConsumerEachMessagePatch(){const u=this;return _ => (function(...E) {
  const h=E[0];
  const T=e.propagation.extract(e.ROOT_CONTEXT,h.message.headers,o.bufferTextMapGetter);
  const m=u._startConsumerSpan({topic:h.topic,message:h.message,operationType:s.MESSAGING_OPERATION_TYPE_VALUE_PROCESS,ctx:T,attributes:{[s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]:String(h.partition)}});
  const A=[c(u._processDuration,Date.now(),{[s.ATTR_MESSAGING_SYSTEM]:s.MESSAGING_SYSTEM_VALUE_KAFKA,[s.ATTR_MESSAGING_OPERATION_NAME]:"process",[s.ATTR_MESSAGING_DESTINATION_NAME]:h.topic,[s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]:String(h.partition)}),a(u._consumedMessages,1,{[s.ATTR_MESSAGING_SYSTEM]:s.MESSAGING_SYSTEM_VALUE_KAFKA,[s.ATTR_MESSAGING_OPERATION_NAME]:"process",[s.ATTR_MESSAGING_DESTINATION_NAME]:h.topic,[s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]:String(h.partition)})];

  const g=e.context.with(e.trace.setSpan(T,m),() => _.apply(this,E));

  return u._endSpansOnPromise([m],A,g)
});}_getConsumerEachBatchPatch(){return u=>{const _=this;return function(...E){
    const h=E[0];
    const T=_._startConsumerSpan({topic:h.batch.topic,message:void 0,operationType:s.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE,ctx:e.ROOT_CONTEXT,attributes:{[s.ATTR_MESSAGING_BATCH_MESSAGE_COUNT]:h.batch.messages.length,[s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]:String(h.batch.partition)}});
    return e.context.with(e.trace.setSpan(e.context.active(),T),()=>{
      const m=Date.now();
      const A=[];
      const g=[a(_._consumedMessages,h.batch.messages.length,{[s.ATTR_MESSAGING_SYSTEM]:s.MESSAGING_SYSTEM_VALUE_KAFKA,[s.ATTR_MESSAGING_OPERATION_NAME]:"process",[s.ATTR_MESSAGING_DESTINATION_NAME]:h.batch.topic,[s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]:String(h.batch.partition)})];
      h.batch.messages.forEach(O=>{
        const I=e.propagation.extract(e.ROOT_CONTEXT,O.headers,o.bufferTextMapGetter);
        const b=e.trace.getSpan(I)?.spanContext();
        let L;

        if (b) {
          (L = {context:b});
        }

        A.push(_._startConsumerSpan({topic:h.batch.topic,message:O,operationType:s.MESSAGING_OPERATION_TYPE_VALUE_PROCESS,link:L,attributes:{[s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]:String(h.batch.partition)}}));
        g.push(c(_._processDuration,m,{[s.ATTR_MESSAGING_SYSTEM]:s.MESSAGING_SYSTEM_VALUE_KAFKA,[s.ATTR_MESSAGING_OPERATION_NAME]:"process",[s.ATTR_MESSAGING_DESTINATION_NAME]:h.batch.topic,[s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]:String(h.batch.partition)}));
      });const R=u.apply(this,E);
      A.unshift(T);
      return _._endSpansOnPromise(A,g,R);
    });
  };};}_getProducerTransactionPatch(){const u=this;return _ => (function(...E) {
  const h=u.tracer.startSpan("transaction");
  const T=_.apply(this,E);

  T.then(m=>{const A=m.send;m.send=function(...b){return e.context.with(e.trace.setSpan(e.context.active(),h),() => u._getSendPatch()(A).apply(this,b).catch(U=>{
    h.setStatus({code:e.SpanStatusCode.ERROR,message:U?.message});
    h.recordException(U);
    throw U;
  }));};const g=m.sendBatch;m.sendBatch=function(...b){return e.context.with(e.trace.setSpan(e.context.active(),h),() => u._getSendBatchPatch()(g).apply(this,b).catch(U=>{
    h.setStatus({code:e.SpanStatusCode.ERROR,message:U?.message});
    h.recordException(U);
    throw U;
  }));};const R=m.commit;m.commit=function(...b){const L=R.apply(this,b).then(()=>{h.setStatus({code:e.SpanStatusCode.OK})});return u._endSpansOnPromise([h],[],L)};const O=m.abort;m.abort=function(...b){const L=O.apply(this,b);return u._endSpansOnPromise([h],[],L)}}).catch(m=>{
    h.setStatus({code:e.SpanStatusCode.ERROR,message:m?.message});
    h.recordException(m);
    h.end();
  });

  return T;
});}_getSendBatchPatch(){const u=this;return _ => (function(...E) {
  const T=E[0].topicMessages||[];
  const m=[];
  const A=[];
  T.forEach(R=>{R.messages.forEach(O=>{
    m.push(u._startProducerSpan(R.topic,O));
    A.push(a(u._sentMessages,1,{[s.ATTR_MESSAGING_SYSTEM]:s.MESSAGING_SYSTEM_VALUE_KAFKA,[s.ATTR_MESSAGING_OPERATION_NAME]:"send",[s.ATTR_MESSAGING_DESTINATION_NAME]:R.topic,...(O.partition!==void 0 ? {[s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]:String(O.partition)} : {})}));
  })});const g=_.apply(this,E);return u._endSpansOnPromise(m,A,g)
});}_getSendPatch(){const u=this;return _ => (function(...E) {
  const h=E[0];

  const T=h.messages.map(g => u._startProducerSpan(h.topic,g));

  const m=h.messages.map(g => a(u._sentMessages,1,{[s.ATTR_MESSAGING_SYSTEM]:s.MESSAGING_SYSTEM_VALUE_KAFKA,[s.ATTR_MESSAGING_OPERATION_NAME]:"send",[s.ATTR_MESSAGING_DESTINATION_NAME]:h.topic,...(g.partition!==void 0 ? {[s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]:String(g.partition)} : {})}));

  const A=_.apply(this,E);
  return u._endSpansOnPromise(T,m,A)
});}_endSpansOnPromise(u,_,p){return Promise.resolve(p).then(E => {
    _.forEach(h => h());

    return E;
  }).catch(E=>{
  let h;
  let T=n.ERROR_TYPE_VALUE_OTHER;

  if (typeof E=="string"||E===void 0) {
    h=E;
  } else if (typeof E=="object"&&Object.prototype.hasOwnProperty.call(E,"message")) {
    h=E.message;
    T=E.constructor.name;
  }

  _.forEach(m => m(T));

  u.forEach(m=>{
    m.setAttribute(n.ATTR_ERROR_TYPE,T);
    m.setStatus({code:e.SpanStatusCode.ERROR,message:h});
  });

  throw E;
}).finally(()=>{u.forEach(E => E.end())});}_startConsumerSpan({topic,message,operationType,ctx,link,attributes}){
  const m=operationType===s.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE?"poll":operationType;
  const A=this.tracer.startSpan(`${m} ${topic}`,{kind:operationType===s.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE?e.SpanKind.CLIENT:e.SpanKind.CONSUMER,attributes:{...attributes,[s.ATTR_MESSAGING_SYSTEM]:s.MESSAGING_SYSTEM_VALUE_KAFKA,[s.ATTR_MESSAGING_DESTINATION_NAME]:topic,[s.ATTR_MESSAGING_OPERATION_TYPE]:operationType,[s.ATTR_MESSAGING_OPERATION_NAME]:m,[s.ATTR_MESSAGING_KAFKA_MESSAGE_KEY]:message?.key?String(message.key):void 0,[s.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE]:message?.key&&message.value===null?true:void 0,[s.ATTR_MESSAGING_KAFKA_OFFSET]:message?.offset},links:link?[link]:[]},ctx);
  const {consumerHook}=this.getConfig();

  if (consumerHook&&message) {
    (0,t.safeExecuteInTheMiddle)(() => consumerHook(A,{topic:topic,message:message}),R=>{
      if (R) {
        this._diag.error("consumerHook error",R);
      }
    },true);
  }

  return A;
}_startProducerSpan(u,_){
  const p=this.tracer.startSpan(`send ${u}`,{kind:e.SpanKind.PRODUCER,attributes:{[s.ATTR_MESSAGING_SYSTEM]:s.MESSAGING_SYSTEM_VALUE_KAFKA,[s.ATTR_MESSAGING_DESTINATION_NAME]:u,[s.ATTR_MESSAGING_KAFKA_MESSAGE_KEY]:_.key?String(_.key):void 0,[s.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE]:_.key&&_.value===null?true:void 0,[s.ATTR_MESSAGING_DESTINATION_PARTITION_ID]:_.partition!==void 0?String(_.partition):void 0,[s.ATTR_MESSAGING_OPERATION_NAME]:"send",[s.ATTR_MESSAGING_OPERATION_TYPE]:s.MESSAGING_OPERATION_TYPE_VALUE_SEND}});
  _.headers=_.headers??{};
  e.propagation.inject(e.trace.setSpan(e.context.active(),p),_.headers);
  const{producerHook}=this.getConfig();

  if (producerHook) {
    (0,t.safeExecuteInTheMiddle)(() => producerHook(p,{topic:u,message:_}),h=>{
      if (h) {
        this._diag.error("producerHook error",h);
      }
    },true);
  }

  return p;
}}
  pa.KafkaJsInstrumentation=f;
  return pa;
}let tN;function Nq(){
  if (!tN) {
    tN=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.KafkaJsInstrumentation=void 0;
      const t=Rq();Object.defineProperty(e,"KafkaJsInstrumentation",{enumerable:true,get() {return t.KafkaJsInstrumentation}})
    })(Fd);
  }

  return Fd;
}const yq=Nq();
const ev="Kafka";

const Oq=Ne(ev,() => new yq.KafkaJsInstrumentation({consumerHook(e){yt(e,"auto.kafkajs.otel.consumer")},producerHook(e){yt(e,"auto.kafkajs.otel.producer")}}));

const bq=(() => ({
  name:ev,
  setupOnce(){Oq()}
}));

const Cq=bq;
const Yd={};
const Ta={};
const Mr={};
let nN;
function Iq(){
  if (!nN) {
    nN=1;
    Object.defineProperty(Mr,"__esModule",{value:true});
    Mr.PACKAGE_NAME=Mr.PACKAGE_VERSION=void 0;
    Mr.PACKAGE_VERSION="0.53.0";
    Mr.PACKAGE_NAME="@opentelemetry/instrumentation-lru-memoizer";
  }

  return Mr;
}let rN;function Pq(){
  if (rN) {
    return Ta;
  }
  rN=1;
  Object.defineProperty(Ta,"__esModule",{value:true});
  Ta.LruMemoizerInstrumentation=void 0;
  const e=Pe();
  const t=Le;
  const n=Iq();
  class r extends t.InstrumentationBase{constructor(s={}){super(n.PACKAGE_NAME,n.PACKAGE_VERSION,s)}init(){return [new t.InstrumentationNodeModuleDefinition("lru-memoizer",[">=1.3 <3"],s=>{
    const i=function(...args) {const a=s.apply(this,args);return function(){
      const c=[...args];
      const l=c.pop();
      const f=typeof l=="function"?e.context.bind(e.context.active(),l):l;
      c.push(f);
      return a.apply(this,c);
    };};
    i.sync=s.sync;
    return i;
  },void 0)];}}
  Ta.LruMemoizerInstrumentation=r;
  return Ta;
}let oN;function Mq(){
  if (!oN) {
    oN=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.LruMemoizerInstrumentation=void 0;
      const t=Pq();Object.defineProperty(e,"LruMemoizerInstrumentation",{enumerable:true,get() {return t.LruMemoizerInstrumentation}})
    })(Yd);
  }

  return Yd;
}const vq=Mq();
const tv="LruMemoizer";

const Lq=Ne(tv,() => new vq.LruMemoizerInstrumentation);

const wq=(() => ({
  name:tv,
  setupOnce(){Lq()}
}));

const Dq=wq;
const jd={};
const Sa={};
const Be={};
let sN;
function Uq(){
  if (!sN) {
    sN=1;
    Object.defineProperty(Be,"__esModule",{value:true});
    Be.METRIC_DB_CLIENT_CONNECTIONS_USAGE=Be.DB_SYSTEM_VALUE_MONGODB=Be.ATTR_NET_PEER_PORT=Be.ATTR_NET_PEER_NAME=Be.ATTR_DB_SYSTEM=Be.ATTR_DB_STATEMENT=Be.ATTR_DB_OPERATION=Be.ATTR_DB_NAME=Be.ATTR_DB_MONGODB_COLLECTION=Be.ATTR_DB_CONNECTION_STRING=void 0;
    Be.ATTR_DB_CONNECTION_STRING="db.connection_string";
    Be.ATTR_DB_MONGODB_COLLECTION="db.mongodb.collection";
    Be.ATTR_DB_NAME="db.name";
    Be.ATTR_DB_OPERATION="db.operation";
    Be.ATTR_DB_STATEMENT="db.statement";
    Be.ATTR_DB_SYSTEM="db.system";
    Be.ATTR_NET_PEER_NAME="net.peer.name";
    Be.ATTR_NET_PEER_PORT="net.peer.port";
    Be.DB_SYSTEM_VALUE_MONGODB="mongodb";
    Be.METRIC_DB_CLIENT_CONNECTIONS_USAGE="db.client.connections.usage";
  }

  return Be;
}
const qd={};
let iN;
function kq(){
  if (!iN) {
    iN=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.MongodbCommandType=void 0;

      (t => {
        t.CREATE_INDEXES="createIndexes";
        t.FIND_AND_MODIFY="findAndModify";
        t.IS_MASTER="isMaster";
        t.COUNT="count";
        t.AGGREGATE="aggregate";
        t.UNKNOWN="unknown";
      })(e.MongodbCommandType||(e.MongodbCommandType={}));
    })(qd);
  }

  return qd;
}
const vr={};
let aN;
function Gq(){
  if (!aN) {
    aN=1;
    Object.defineProperty(vr,"__esModule",{value:true});
    vr.PACKAGE_NAME=vr.PACKAGE_VERSION=void 0;
    vr.PACKAGE_VERSION="0.61.0";
    vr.PACKAGE_NAME="@opentelemetry/instrumentation-mongodb";
  }

  return vr;
}let cN;function Vq(){
  if (cN) {
    return Sa;
  }
  cN=1;
  Object.defineProperty(Sa,"__esModule",{value:true});
  Sa.MongoDBInstrumentation=void 0;
  const e=Pe();
  const t=Le;
  const n=Uq();
  const r=kq();
  const o=Gq();
  const s={requireParentSpan:true};
  class i extends t.InstrumentationBase{constructor(c={}){super(o.PACKAGE_NAME,o.PACKAGE_VERSION,{...s,...c})}setConfig(c={}){super.setConfig({...s,...c})}_updateMetricInstruments(){this._connectionsUsage=this.meter.createUpDownCounter(n.METRIC_DB_CLIENT_CONNECTIONS_USAGE,{description:"The number of connections that are currently in state described by the state attribute.",unit:"{connection}"})}init(){
    const {v3PatchConnection,v3UnpatchConnection}=this._getV3ConnectionPatches();
    const {v4PatchConnect,v4UnpatchConnect}=this._getV4ConnectPatches();
    const {v4PatchConnectionCallback,v4PatchConnectionPromise,v4UnpatchConnection}=this._getV4ConnectionPatches();
    const {v4PatchConnectionPool,v4UnpatchConnectionPool}=this._getV4ConnectionPoolPatches();
    const {v4PatchSessions,v4UnpatchSessions}=this._getV4SessionsPatches();
    return [new t.InstrumentationNodeModuleDefinition("mongodb",[">=3.3.0 <4"],void 0,void 0,[new t.InstrumentationNodeModuleFile("mongodb/lib/core/wireprotocol/index.js",[">=3.3.0 <4"],v3PatchConnection,v3UnpatchConnection)]),new t.InstrumentationNodeModuleDefinition("mongodb",[">=4.0.0 <7"],void 0,void 0,[new t.InstrumentationNodeModuleFile("mongodb/lib/cmap/connection.js",[">=4.0.0 <6.4"],v4PatchConnectionCallback,v4UnpatchConnection),new t.InstrumentationNodeModuleFile("mongodb/lib/cmap/connection.js",[">=6.4.0 <7"],v4PatchConnectionPromise,v4UnpatchConnection),new t.InstrumentationNodeModuleFile("mongodb/lib/cmap/connection_pool.js",[">=4.0.0 <6.4"],v4PatchConnectionPool,v4UnpatchConnectionPool),new t.InstrumentationNodeModuleFile("mongodb/lib/cmap/connect.js",[">=4.0.0 <7"],v4PatchConnect,v4UnpatchConnect),new t.InstrumentationNodeModuleFile("mongodb/lib/sessions.js",[">=4.0.0 <7"],v4PatchSessions,v4UnpatchSessions)])];
  }_getV3ConnectionPatches(){return {v3PatchConnection:c => {
    if ((0,t.isWrapped)(c.insert)) {
      this._unwrap(c,"insert");
    }

    this._wrap(c,"insert",this._getV3PatchOperation("insert"));

    if ((0,t.isWrapped)(c.remove)) {
      this._unwrap(c,"remove");
    }

    this._wrap(c,"remove",this._getV3PatchOperation("remove"));

    if ((0,t.isWrapped)(c.update)) {
      this._unwrap(c,"update");
    }

    this._wrap(c,"update",this._getV3PatchOperation("update"));

    if ((0,t.isWrapped)(c.command)) {
      this._unwrap(c,"command");
    }

    this._wrap(c,"command",this._getV3PatchCommand());

    if ((0,t.isWrapped)(c.query)) {
      this._unwrap(c,"query");
    }

    this._wrap(c,"query",this._getV3PatchFind());

    if ((0,t.isWrapped)(c.getMore)) {
      this._unwrap(c,"getMore");
    }

    this._wrap(c,"getMore",this._getV3PatchCursor());
    return c;
  },v3UnpatchConnection:c=>{
    if (c!==void 0) {
      this._unwrap(c,"insert");
      this._unwrap(c,"remove");
      this._unwrap(c,"update");
      this._unwrap(c,"command");
      this._unwrap(c,"query");
      this._unwrap(c,"getMore");
    }
  }};}_getV4SessionsPatches(){return {v4PatchSessions:c => {
    if ((0,t.isWrapped)(c.acquire)) {
      this._unwrap(c,"acquire");
    }

    this._wrap(c.ServerSessionPool.prototype,"acquire",this._getV4AcquireCommand());

    if ((0,t.isWrapped)(c.release)) {
      this._unwrap(c,"release");
    }

    this._wrap(c.ServerSessionPool.prototype,"release",this._getV4ReleaseCommand());
    return c;
  },v4UnpatchSessions:c=>{
    if (c!==void 0) {
      (0,t.isWrapped)(c.acquire)&&this._unwrap(c,"acquire");
      (0,t.isWrapped)(c.release)&&this._unwrap(c,"release");
    }
  }};}_getV4AcquireCommand(){const c=this;return l => (function() {
    const d=this.sessions.length;
    const u=l.call(this);
    const _=this.sessions.length;

    if (d===_) {
      c._connectionsUsage.add(1,{state:"used","pool.name":c._poolName});
    } else if (d-1===_) {
      c._connectionsUsage.add(-1,{state:"idle","pool.name":c._poolName});
      c._connectionsUsage.add(1,{state:"used","pool.name":c._poolName});
    }

    return u;
  });}_getV4ReleaseCommand(){const c=this;return l => (function(d) {
    const u=l.call(this,d);
    c._connectionsUsage.add(-1,{state:"used","pool.name":c._poolName});
    c._connectionsUsage.add(1,{state:"idle","pool.name":c._poolName});
    return u;
  });}_getV4ConnectionPoolPatches(){return {v4PatchConnectionPool:c=>{
    const l=c.ConnectionPool.prototype;

    if ((0,t.isWrapped)(l.checkOut)) {
      this._unwrap(l,"checkOut");
    }

    this._wrap(l,"checkOut",this._getV4ConnectionPoolCheckOut());
    return c;
  },v4UnpatchConnectionPool:c=>{
    if (c!==void 0) {
      this._unwrap(c.ConnectionPool.prototype,"checkOut");
    }
  }};}_getV4ConnectPatches(){return {v4PatchConnect:c => {
    if ((0,t.isWrapped)(c.connect)) {
      this._unwrap(c,"connect");
    }

    this._wrap(c,"connect",this._getV4ConnectCommand());
    return c;
  },v4UnpatchConnect:c=>{
    if (c!==void 0) {
      this._unwrap(c,"connect");
    }
  }};}_getV4ConnectionPoolCheckOut(){return c => (function(f) {const d=e.context.bind(e.context.active(),f);return c.call(this,d)});}_getV4ConnectCommand(){const c=this;return l => (function(d, u) {if(l.length===1){
    const p=l.call(this,d);

    if (p&&typeof p.then=="function") {
      p.then(() => c.setPoolName(d),()=>{});
    }

    return p;
  }const _=(p, E) => {
    if(p||!E){u(p,E);return}
    c.setPoolName(d);
    u(p,E);
  };return l.call(this,d,_)});}_getV4ConnectionPatches(){return {v4PatchConnectionCallback:c => {
    if ((0,t.isWrapped)(c.Connection.prototype.command)) {
      this._unwrap(c.Connection.prototype,"command");
    }

    this._wrap(c.Connection.prototype,"command",this._getV4PatchCommandCallback());
    return c;
  },v4PatchConnectionPromise:c => {
    if ((0,t.isWrapped)(c.Connection.prototype.command)) {
      this._unwrap(c.Connection.prototype,"command");
    }

    this._wrap(c.Connection.prototype,"command",this._getV4PatchCommandPromise());
    return c;
  },v4UnpatchConnection:c=>{
    if (c!==void 0) {
      this._unwrap(c.Connection.prototype,"command");
    }
  }};}_getV3PatchOperation(c){const l=this;return f => (function(u, _, p, E, h) {
    const T=e.trace.getSpan(e.context.active());
    const m=l._checkSkipInstrumentation(T);
    const A=typeof E=="function"?E:h;
    if (m||typeof A!="function"||typeof p!="object") {
      return typeof E=="function"?f.call(this,u,_,p,E):f.call(this,u,_,p,E,h);
    }const g=l.tracer.startSpan(`mongodb.${c}`,{kind:e.SpanKind.CLIENT});l._populateV3Attributes(g,_,u,p[0],c);const R=l._patchEnd(g,A);return typeof E=="function"?f.call(this,u,_,p,R):f.call(this,u,_,p,E,R)
  });}_getV3PatchCommand(){const c=this;return l => (function(d, u, _, p, E) {
    const h=e.trace.getSpan(e.context.active());
    const T=c._checkSkipInstrumentation(h);
    const m=typeof p=="function"?p:E;
    if (T||typeof m!="function"||typeof _!="object") {
      return typeof p=="function"?l.call(this,d,u,_,p):l.call(this,d,u,_,p,E);
    }
    const A=i._getCommandType(_);
    const g=A===r.MongodbCommandType.UNKNOWN?"command":A;
    const R=c.tracer.startSpan(`mongodb.${g}`,{kind:e.SpanKind.CLIENT});
    const O=A===r.MongodbCommandType.UNKNOWN?void 0:A;
    c._populateV3Attributes(R,u,d,_,O);const I=c._patchEnd(R,m);return typeof p=="function"?l.call(this,d,u,_,I):l.call(this,d,u,_,p,I)
  });}_getV4PatchCommandCallback(){const c=this;return l => (function(d, u, _, p) {
    const E=e.trace.getSpan(e.context.active());
    const h=c._checkSkipInstrumentation(E);
    const T=p;
    const m=Object.keys(u)[0];
    if (typeof u!="object"||u.ismaster||u.hello) {
      return l.call(this,d,u,_,p);
    }let A;

    if (!h) {
      A=c.tracer.startSpan(`mongodb.${m}`,{kind:e.SpanKind.CLIENT});
      c._populateV4Attributes(A,this,d,u,m);
    }

    const g=c._patchEnd(A,T,this.id,m);return l.call(this,d,u,_,g)
  });}_getV4PatchCommandPromise(){const c=this;return l => (function(...d) {
    const [u,_]=d;
    const p=e.trace.getSpan(e.context.active());
    const E=c._checkSkipInstrumentation(p);
    const h=Object.keys(_)[0];
    const T=()=>{};
    if (typeof _!="object"||_.ismaster||_.hello) {
      return l.apply(this,d);
    }let m;

    if (!E) {
      m=c.tracer.startSpan(`mongodb.${h}`,{kind:e.SpanKind.CLIENT});
      c._populateV4Attributes(m,this,u,_,h);
    }

    const A=c._patchEnd(m,T,this.id,h);
    const g=l.apply(this,d);

    g.then(R => A(null,R),R => A(R));

    return g;
  });}_getV3PatchFind(){const c=this;return l => (function(d, u, _, p, E, h) {
    const T=e.trace.getSpan(e.context.active());
    const m=c._checkSkipInstrumentation(T);
    const A=typeof E=="function"?E:h;
    if (m||typeof A!="function"||typeof _!="object") {
      return typeof E=="function"?l.call(this,d,u,_,p,E):l.call(this,d,u,_,p,E,h);
    }const g=c.tracer.startSpan("mongodb.find",{kind:e.SpanKind.CLIENT});c._populateV3Attributes(g,u,d,_,"find");const R=c._patchEnd(g,A);return typeof E=="function"?l.call(this,d,u,_,p,R):l.call(this,d,u,_,p,E,R)
  });}_getV3PatchCursor(){const c=this;return l => (function(d, u, _, p, E, h) {
    const T=e.trace.getSpan(e.context.active());
    const m=c._checkSkipInstrumentation(T);
    const A=typeof E=="function"?E:h;
    if (m||typeof A!="function") {
      return typeof E=="function"?l.call(this,d,u,_,p,E):l.call(this,d,u,_,p,E,h);
    }const g=c.tracer.startSpan("mongodb.getMore",{kind:e.SpanKind.CLIENT});c._populateV3Attributes(g,u,d,_.cmd,"getMore");const R=c._patchEnd(g,A);return typeof E=="function"?l.call(this,d,u,_,p,R):l.call(this,d,u,_,p,E,R)
  });}static _getCommandType(c){
    if (c.createIndexes!==void 0) {
      return r.MongodbCommandType.CREATE_INDEXES;
    }

    if (c.findandmodify!==void 0) {
      return r.MongodbCommandType.FIND_AND_MODIFY;
    }

    if (c.ismaster!==void 0) {
      return r.MongodbCommandType.IS_MASTER;
    }

    if (c.count!==void 0) {
      return r.MongodbCommandType.COUNT;
    }

    if (c.aggregate!==void 0) {
      return r.MongodbCommandType.AGGREGATE;
    }

    return r.MongodbCommandType.UNKNOWN;
  }_populateV4Attributes(c,l,f,d,u){
    let _;
    let p;
    if(l){
      const h=typeof l.address=="string"?l.address.split(":"):"";

      if (h.length===2) {
        _=h[0];
        p=h[1];
      }
    }let E;

    if (d?.documents&&d.documents[0]) {
      E=d.documents[0];
    } else if (d?.cursors) {
      E=d.cursors;
    } else {
      E=d;
    }

    this._addAllSpanAttributes(c,f.db,f.collection,_,p,E,u);
  }_populateV3Attributes(c,l,f,d,u){
    let _;
    let p;
    if(f&&f.s&&(_=f.s.options?.host??f.s.host,p=(f.s.options?.port??f.s.port)?.toString(),_==null||p==null)){const m=f.description?.address;if(m){
      const A=m.split(":");
      _=A[0];
      p=A[1];
    }}
    const [E,h]=l.toString().split(".");
    const T=d?.query??d?.q??d;
    this._addAllSpanAttributes(c,E,h,_,p,T,u)
  }_addAllSpanAttributes(c,l,f,d,u,_,p){
    c.setAttributes({[n.ATTR_DB_SYSTEM]:n.DB_SYSTEM_VALUE_MONGODB,[n.ATTR_DB_NAME]:l,[n.ATTR_DB_MONGODB_COLLECTION]:f,[n.ATTR_DB_OPERATION]:p,[n.ATTR_DB_CONNECTION_STRING]:`mongodb://${d}:${u}/${l}`});

    if (d&&u)
      {
        c.setAttribute(n.ATTR_NET_PEER_NAME,d);const T=parseInt(u,10);

        if (!isNaN(T)) {
          c.setAttribute(n.ATTR_NET_PEER_PORT,T);
        }
      }

    if (!_) {
      return;
    }
    const {dbStatementSerializer}=this.getConfig();
    const h=typeof dbStatementSerializer=="function"?dbStatementSerializer:this._defaultDbStatementSerializer.bind(this);
    (0,t.safeExecuteInTheMiddle)(()=>{const T=h(_);c.setAttribute(n.ATTR_DB_STATEMENT,T)},T=>{
      if (T) {
        this._diag.error("Error running dbStatementSerializer hook",T);
      }
    },true)
  }_getDefaultDbStatementReplacer(){const c=new WeakSet;return (l, f) => typeof f!="object"||!f?"?":c.has(f)?"[Circular]":(c.add(f),f);}_defaultDbStatementSerializer(c){const{enhancedDatabaseReporting}=this.getConfig();return enhancedDatabaseReporting?JSON.stringify(c):JSON.stringify(c,this._getDefaultDbStatementReplacer());}_handleExecutionResult(c,l){
    const{responseHook}=this.getConfig();

    if (typeof responseHook=="function") {
      (0,t.safeExecuteInTheMiddle)(()=>{responseHook(c,{data:l})},d=>{
        if (d) {
          this._diag.error("Error running response hook",d);
        }
      },true);
    }
  }_patchEnd(c,l,f,d){
    const u=e.context.active();
    const _=this;
    return function(...E){const h=E[0];if(c){if (h instanceof Error) {
      c?.setStatus({code:e.SpanStatusCode.ERROR,message:h.message});
    } else
      {const T=E[1];_._handleExecutionResult(c,T)}c.end()}return e.context.with(u,() => {
      if (d==="endSessions") {
        _._connectionsUsage.add(-1,{state:"idle","pool.name":_._poolName});
      }

      return l.apply(this,E);
    });};
  }setPoolName(c){
    const l=c.hostAddress?.host;
    const f=c.hostAddress?.port;
    const d=c.dbName;
    const u=`mongodb://${l}:${f}/${d}`;
    this._poolName=u
  }_checkSkipInstrumentation(c){return this.getConfig().requireParentSpan===true&&c===void 0;}}
  Sa.MongoDBInstrumentation=i;
  return Sa;
}
const Wd={};
let uN;
function xq(){
  if (!uN) {
    uN=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.MongodbCommandType=void 0;

      (t => {
        t.CREATE_INDEXES="createIndexes";
        t.FIND_AND_MODIFY="findAndModify";
        t.IS_MASTER="isMaster";
        t.COUNT="count";
        t.UNKNOWN="unknown";
      })(e.MongodbCommandType||(e.MongodbCommandType={}));
    })(Wd);
  }

  return Wd;
}let lN;function $q(){
  if (!lN) {
    lN=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.MongodbCommandType = void 0;
      e.MongoDBInstrumentation = void 0;
      const t=Vq();Object.defineProperty(e,"MongoDBInstrumentation",{enumerable:true,get() {return t.MongoDBInstrumentation}});const n=xq();Object.defineProperty(e,"MongodbCommandType",{enumerable:true,get() {return n.MongodbCommandType}})
    })(jd);
  }

  return jd;
}const Bq=$q();
const nv="Mongo";

const Hq=Ne(nv,() => new Bq.MongoDBInstrumentation({dbStatementSerializer:Fq,responseHook(e){yt(e,"auto.db.otel.mongo")}}));

function Fq(e){const t=wp(e);return JSON.stringify(t)}function wp(e){if (Array.isArray(e)) {
  return e.map(t => wp(t));
}if(Yq(e)){const t={};return Object.entries(e).map(([n,r]) => [n,wp(r)]).reduce((n, r) => {
  if (qq(r)) {
    (n[r[0]] = r[1]);
  }

  return n;
},t);}return"?"}function Yq(e){return typeof e=="object"&&e!==null&&!jq(e)}function jq(e){
  let t=false;

  if (typeof Buffer !== "undefined") {
    (t = Buffer.isBuffer(e));
  }

  return t;
}function qq(e){return Array.isArray(e)}

const Wq=(() => ({
  name:nv,
  setupOnce(){Hq()}
}));

const Kq=Wq;
const Kd={};
const zd={};
const Pn={};
const Qe={};
let dN;
function rv(){
  if (!dN) {
    dN=1;
    Object.defineProperty(Qe,"__esModule",{value:true});
    Qe.ATTR_NET_PEER_PORT=Qe.ATTR_NET_PEER_NAME=Qe.ATTR_DB_USER=Qe.ATTR_DB_SYSTEM=Qe.ATTR_DB_STATEMENT=Qe.ATTR_DB_OPERATION=Qe.ATTR_DB_NAME=Qe.ATTR_DB_MONGODB_COLLECTION=void 0;
    Qe.ATTR_DB_MONGODB_COLLECTION="db.mongodb.collection";
    Qe.ATTR_DB_NAME="db.name";
    Qe.ATTR_DB_OPERATION="db.operation";
    Qe.ATTR_DB_STATEMENT="db.statement";
    Qe.ATTR_DB_SYSTEM="db.system";
    Qe.ATTR_DB_USER="db.user";
    Qe.ATTR_NET_PEER_NAME="net.peer.name";
    Qe.ATTR_NET_PEER_PORT="net.peer.port";
  }

  return Qe;
}let fN;function zq(){
  if (fN) {
    return Pn;
  }
  fN=1;
  Object.defineProperty(Pn,"__esModule",{value:true});
  Pn.handleCallbackResponse = void 0;
  Pn.handlePromiseResponse = void 0;
  Pn.getAttributesFromCollection = void 0;
  const e=Pe();
  const t=Le;
  const n=rv();
  function r(c){return{[n.ATTR_DB_MONGODB_COLLECTION]:c.name,[n.ATTR_DB_NAME]:c.conn.name,[n.ATTR_DB_USER]:c.conn.user,[n.ATTR_NET_PEER_NAME]:c.conn.host,[n.ATTR_NET_PEER_PORT]:c.conn.port}}Pn.getAttributesFromCollection=r;function o(c,l={}){
    c.recordException(l);

    c.setStatus({code:e.SpanStatusCode.ERROR,message:`${l.message} ${l.code?`
    Mongoose Error Code: ${l.code}`:""}`});
  }function s(c,l,f,d=void 0){
  if (f) {
    (0,t.safeExecuteInTheMiddle)(() => f(c,{moduleVersion:d,response:l}),u=>{
      if (u) {
        e.diag.error("mongoose instrumentation: responseHook error",u);
      }
    },true);
  }
}function i(c,l,f,d=void 0){return c instanceof Promise?c.then(u => {
    s(l,u,f,d);
    return u;
  }).catch(u=>{
    o(l,u);
    throw u;
  }).finally(() => l.end()):(s(l,c,f,d),l.end(),c);}Pn.handlePromiseResponse=i;function a(c,l,f,d,u,_,p=void 0){
  let E=0;

  if (u.length===2) {
    E=1;
  } else if (u.length===3) {
    (E = 2);
  }

  u[E]=(h, T) => {
    if (h) {
      o(d,h);
    } else {
      s(d,T,_,p);
    }

    d.end();
    return c(h,T);
  };

  return l.apply(f,u);
}
  Pn.handleCallbackResponse=a;
  return Pn;
}
const Lr={};
let _N;
function Zq(){
  if (!_N) {
    _N=1;
    Object.defineProperty(Lr,"__esModule",{value:true});
    Lr.PACKAGE_NAME=Lr.PACKAGE_VERSION=void 0;
    Lr.PACKAGE_VERSION="0.55.0";
    Lr.PACKAGE_NAME="@opentelemetry/instrumentation-mongoose";
  }

  return Lr;
}let pN;function Xq(...args) {
  if (!pN) {
    pN=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.MongooseInstrumentation = void 0;
      e._STORED_PARENT_SPAN = void 0;
      const t=Pe();
      const n=dn;
      const r=zq();
      const o=Le;
      const s=Zq();
      const i=rv();
      const a=["deleteOne","deleteMany","find","findOne","estimatedDocumentCount","countDocuments","distinct","where","$where","findOneAndUpdate","findOneAndDelete","findOneAndReplace"];
      const c=["remove","count","findOneAndRemove",...a];
      const l=["count","findOneAndRemove",...a];
      const f=[...a];
      function d(p){return p?p.startsWith("6.")||p.startsWith("5.")?c:p.startsWith("7.")?l:f:a}function u(p){return p&&(p.startsWith("5.")||p.startsWith("6."))||false;}e._STORED_PARENT_SPAN=Symbol("stored-parent-span");class _ extends o.InstrumentationBase{constructor(E={}){super(s.PACKAGE_NAME,s.PACKAGE_VERSION,E)}init(){return new o.InstrumentationNodeModuleDefinition("mongoose",[">=5.9.7 <9"],this.patch.bind(this),this.unpatch.bind(this))}patch(E,h){
      const T=E[Symbol.toStringTag]==="Module"?E.default:E;
      this._wrap(T.Model.prototype,"save",this.patchOnModelMethods("save",h));
      T.Model.prototype.$save=T.Model.prototype.save;

      if (u(h)) {
        this._wrap(T.Model.prototype,"remove",this.patchOnModelMethods("remove",h));
      }

      this._wrap(T.Query.prototype,"exec",this.patchQueryExec(h));
      this._wrap(T.Aggregate.prototype,"exec",this.patchAggregateExec(h));
      d(h).forEach(A=>{this._wrap(T.Query.prototype,A,this.patchAndCaptureSpanContext(A))});
      this._wrap(T.Model,"aggregate",this.patchModelAggregate());
      this._wrap(T.Model,"insertMany",this.patchModelStatic("insertMany",h));
      this._wrap(T.Model,"bulkWrite",this.patchModelStatic("bulkWrite",h));
      return T;
    }unpatch(E,h){
      const T=E[Symbol.toStringTag]==="Module"?E.default:E;
      const m=d(h);
      this._unwrap(T.Model.prototype,"save");
      T.Model.prototype.$save=T.Model.prototype.save;

      if (u(h)) {
        this._unwrap(T.Model.prototype,"remove");
      }

      this._unwrap(T.Query.prototype,"exec");
      this._unwrap(T.Aggregate.prototype,"exec");
      m.forEach(A=>{this._unwrap(T.Query.prototype,A)});
      this._unwrap(T.Model,"aggregate");
      this._unwrap(T.Model,"insertMany");
      this._unwrap(T.Model,"bulkWrite");
    }patchAggregateExec(E){const h=this;return T => (function(A) {
      if (h.getConfig().requireParentSpan&&t.trace.getSpan(t.context.active())===void 0) {
        return T.apply(this,args);
      }
      const g=this[e._STORED_PARENT_SPAN];
      const R={};
      const {dbStatementSerializer}=h.getConfig();

      if (dbStatementSerializer) {
        (R[i.ATTR_DB_STATEMENT] = dbStatementSerializer("aggregate",{options:this.options,aggregatePipeline:this._pipeline}));
      }

      const I=h._startSpan(this._model.collection,this._model?.modelName,"aggregate",R,g);return h._handleResponse(I,T,this,args,A,E);
    });}patchQueryExec(E){const h=this;return T => (function(A) {
      if (h.getConfig().requireParentSpan&&t.trace.getSpan(t.context.active())===void 0) {
        return T.apply(this,args);
      }
      const g=this[e._STORED_PARENT_SPAN];
      const R={};
      const {dbStatementSerializer}=h.getConfig();

      if (dbStatementSerializer) {
        (R[i.ATTR_DB_STATEMENT] = dbStatementSerializer(this.op,{condition:this._conditions,updates:this._update,options:this.options,fields:this._fields}));
      }

      const I=h._startSpan(this.mongooseCollection,this.model.modelName,this.op,R,g);return h._handleResponse(I,T,this,args,A,E);
    });}patchOnModelMethods(E,h){const T=this;return m => (function(g, R) {
      if (T.getConfig().requireParentSpan&&t.trace.getSpan(t.context.active())===void 0) {
        return m.apply(this,args);
      }const O={document:this};

      if (g&&!(g instanceof Function)) {
        (O.options = g);
      }

      const I={};
      const {dbStatementSerializer}=T.getConfig();

      if (dbStatementSerializer) {
        (I[i.ATTR_DB_STATEMENT] = dbStatementSerializer(E,O));
      }

      const L=T._startSpan(this.constructor.collection,this.constructor.modelName,E,I);

      if (g instanceof Function) {
        R=g;
        g=void 0;
      }

      return T._handleResponse(L,m,this,args,R,h);
    });}patchModelStatic(E,h){const T=this;return m => (function(g, R, O) {
      if (T.getConfig().requireParentSpan&&t.trace.getSpan(t.context.active())===void 0) {
        return m.apply(this,args);
      }

      if (typeof R=="function") {
        O=R;
        R=void 0;
      }

      const I={};switch(E){case "insertMany":
          {
            I.documents=g;break;
          }case "bulkWrite":
          {
            I.operations=g;break;
          }default:
          {
            I.document=g;break
          }}

      if (R!==void 0) {
        (I.options = R);
      }

      const b={};
      const {dbStatementSerializer}=T.getConfig();

      if (dbStatementSerializer) {
        (b[i.ATTR_DB_STATEMENT] = dbStatementSerializer(E,I));
      }

      const U=T._startSpan(this.collection,this.modelName,E,b);return T._handleResponse(U,m,this,args,O,h);
    });}patchModelAggregate(){const E=this;return h => (function(...args) {
      const m=t.trace.getSpan(t.context.active());

      const A=E._callOriginalFunction(() => h.apply(this,args));

      if (A) {
        (A[e._STORED_PARENT_SPAN] = m);
      }

      return A;
    });}patchAndCaptureSpanContext(E){const h=this;return T => (function(...args) {
      this[e._STORED_PARENT_SPAN]=t.trace.getSpan(t.context.active());

      return h._callOriginalFunction(() => T.apply(this,args));
    });}_startSpan(E,h,T,m,A){return this.tracer.startSpan(`mongoose.${h}.${T}`,{kind:t.SpanKind.CLIENT,attributes:{...m,...(0,r.getAttributesFromCollection)(E),[i.ATTR_DB_OPERATION]:T,[i.ATTR_DB_SYSTEM]:"mongoose"}},A?t.trace.setSpan(t.context.active(),A):void 0)}_handleResponse(E,h,T,m,A,g=void 0){const R=this;if (A instanceof Function) {
        return R._callOriginalFunction(() => (0,r.handleCallbackResponse)(A,h,T,E,m,R.getConfig().responseHook,g));
      }{const O=R._callOriginalFunction(() => h.apply(T,m));return(0,r.handlePromiseResponse)(O,E,R.getConfig().responseHook,g)}}_callOriginalFunction(E){return this.getConfig().suppressInternalInstrumentation?t.context.with((0,n.suppressTracing)(t.context.active()),E):E()}}e.MongooseInstrumentation=_
    })(zd);
  }

  return zd;
}let EN;function Qq(){
  if (!EN) {
    EN=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.MongooseInstrumentation=void 0;
      const t=Xq();Object.defineProperty(e,"MongooseInstrumentation",{enumerable:true,get() {return t.MongooseInstrumentation}})
    })(Kd);
  }

  return Kd;
}const Jq=Qq();
const ov="Mongoose";

const eW=Ne(ov,() => new Jq.MongooseInstrumentation({responseHook(e){yt(e,"auto.db.otel.mongoose")}}));

const tW=(() => ({
  name:ov,
  setupOnce(){eW()}
}));

const nW=tW;
const Zd={};
const ma={};
const We={};
let hN;
function sv(){
  if (!hN) {
    hN=1;
    Object.defineProperty(We,"__esModule",{value:true});
    We.METRIC_DB_CLIENT_CONNECTIONS_USAGE=We.DB_SYSTEM_VALUE_MYSQL=We.ATTR_NET_PEER_PORT=We.ATTR_NET_PEER_NAME=We.ATTR_DB_USER=We.ATTR_DB_SYSTEM=We.ATTR_DB_STATEMENT=We.ATTR_DB_NAME=We.ATTR_DB_CONNECTION_STRING=void 0;
    We.ATTR_DB_CONNECTION_STRING="db.connection_string";
    We.ATTR_DB_NAME="db.name";
    We.ATTR_DB_STATEMENT="db.statement";
    We.ATTR_DB_SYSTEM="db.system";
    We.ATTR_DB_USER="db.user";
    We.ATTR_NET_PEER_NAME="net.peer.name";
    We.ATTR_NET_PEER_PORT="net.peer.port";
    We.DB_SYSTEM_VALUE_MYSQL="mysql";
    We.METRIC_DB_CLIENT_CONNECTIONS_USAGE="db.client.connections.usage";
  }

  return We;
}
const Xd={};
let TN;
function rW(){
  if (!TN) {
    TN=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.AttributeNames=void 0;
      (t => {t.MYSQL_VALUES="db.mysql.values"})(e.AttributeNames||(e.AttributeNames={}));
    })(Xd);
  }

  return Xd;
}
const Tt={};
let SN;
function oW(){
  if (SN) {
    return Tt;
  }
  SN=1;
  Object.defineProperty(Tt,"__esModule",{value:true});
  Tt.getPoolName = void 0;
  Tt.arrayStringifyHelper = void 0;
  Tt.getSpanName = void 0;
  Tt.getDbValues = void 0;
  Tt.getDbStatement = void 0;
  Tt.getConnectionAttributes = void 0;
  const e=sv();function t(l){
    const {host,port,database,user}=n(l);
    const p=parseInt(port,10);
    return isNaN(p)?{[e.ATTR_NET_PEER_NAME]:host,[e.ATTR_DB_CONNECTION_STRING]:r(host,port,database),[e.ATTR_DB_NAME]:database,[e.ATTR_DB_USER]:user}:{[e.ATTR_NET_PEER_NAME]:host,[e.ATTR_NET_PEER_PORT]:p,[e.ATTR_DB_CONNECTION_STRING]:r(host,port,database),[e.ATTR_DB_NAME]:database,[e.ATTR_DB_USER]:user};
  }Tt.getConnectionAttributes=t;function n(l){const{host,port,database,user}=l&&l.connectionConfig||l||{};return {host:host,port:port,database:database,user:user};}function r(l,f,d){
  let u=`jdbc:mysql://${l||"localhost"}`;

  if (typeof f=="number") {
    (u += `:${f}`);
  }

  if (typeof d=="string") {
    (u += `/${d}`);
  }

  return u;
}function o(l){return typeof l=="string"?l:l.sql}Tt.getDbStatement=o;function s(l,f){return a(typeof l=="string"?f:f||l.values)}Tt.getDbValues=s;function i(l){
    const f=typeof l=="object"?l.sql:l;
    const d=f?.indexOf(" ");
    return typeof d=="number"&&d!==-1?f?.substring(0,d):f
  }Tt.getSpanName=i;function a(l){return l?`[${l.toString()}]`:""}Tt.arrayStringifyHelper=a;function c(l){
  const f=l.config.connectionConfig;let d="";
  d+=f.host?`host: '${f.host}', `:"";
  d+=f.port?`port: ${f.port}, `:"";
  d+=f.database?`database: '${f.database}', `:"";
  d+=f.user?`user: '${f.user}'`:"";

  if (!f.user) {
    (d = d.substring(0,d.length-2));
  }

  return d.trim();
}
  Tt.getPoolName=c;
  return Tt;
}
const wr={};
let mN;
function sW(){
  if (!mN) {
    mN=1;
    Object.defineProperty(wr,"__esModule",{value:true});
    wr.PACKAGE_NAME=wr.PACKAGE_VERSION=void 0;
    wr.PACKAGE_VERSION="0.54.0";
    wr.PACKAGE_NAME="@opentelemetry/instrumentation-mysql";
  }

  return wr;
}let AN;function iW(...args) {
  if (AN) {
    return ma;
  }
  AN=1;
  Object.defineProperty(ma,"__esModule",{value:true});
  ma.MySQLInstrumentation=void 0;
  const e=Pe();
  const t=Le;
  const n=sv();
  const r=rW();
  const o=oW();
  const s=sW();
  class i extends t.InstrumentationBase{static COMMON_ATTRIBUTES={[n.ATTR_DB_SYSTEM]:n.DB_SYSTEM_VALUE_MYSQL};constructor(c={}){super(s.PACKAGE_NAME,s.PACKAGE_VERSION,c)}_updateMetricInstruments(){this._connectionsUsage=this.meter.createUpDownCounter(n.METRIC_DB_CLIENT_CONNECTIONS_USAGE,{description:"The number of connections that are currently in state described by the state attribute.",unit:"{connection}"})}init(){return [new t.InstrumentationNodeModuleDefinition("mysql",[">=2.0.0 <3"],c => {
    if ((0,t.isWrapped)(c.createConnection)) {
      this._unwrap(c,"createConnection");
    }

    this._wrap(c,"createConnection",this._patchCreateConnection());

    if ((0,t.isWrapped)(c.createPool)) {
      this._unwrap(c,"createPool");
    }

    this._wrap(c,"createPool",this._patchCreatePool());

    if ((0,t.isWrapped)(c.createPoolCluster)) {
      this._unwrap(c,"createPoolCluster");
    }

    this._wrap(c,"createPoolCluster",this._patchCreatePoolCluster());
    return c;
  },c=>{
    if (c!==void 0) {
      this._unwrap(c,"createConnection");
      this._unwrap(c,"createPool");
      this._unwrap(c,"createPoolCluster");
    }
  })];}_patchCreateConnection(){return c=>{const l=this;return function(d){
    const u=c(...args);
    l._wrap(u,"query",l._patchQuery(u));
    return u;
  };};}_patchCreatePool(){return c=>{const l=this;return function(d){
    const u=c(...args);
    l._wrap(u,"query",l._patchQuery(u));
    l._wrap(u,"getConnection",l._patchGetConnection(u));
    l._wrap(u,"end",l._patchPoolEnd(u));
    l._setPoolcallbacks(u,l,"");
    return u;
  };};}_patchPoolEnd(c){return l=>{const f=this;return function(u){
    const _=c._allConnections.length;
    const p=c._freeConnections.length;
    const E=_-p;
    const h=(0,o.getPoolName)(c);
    f._connectionsUsage.add(-E,{state:"used",name:h});
    f._connectionsUsage.add(-p,{state:"idle",name:h});
    l.apply(c,args);
  };};}_patchCreatePoolCluster(){return c=>{const l=this;return function(d){
    const u=c(...args);
    l._wrap(u,"getConnection",l._patchGetConnection(u));
    l._wrap(u,"add",l._patchAdd(u));
    return u;
  };};}_patchAdd(c){return l=>{const f=this;return function(u,_){if (!f._enabled) {
    f._unwrap(c,"add");
    return l.apply(c,args);
  }l.apply(c,args);const p=c._nodes;if(p){
    const E=typeof u=="object"?`CLUSTER::${c._lastId}`:String(u);
    const h=p[E].pool;
    f._setPoolcallbacks(h,f,u)
  }};};}_patchGetConnection(c){return l=>{const f=this;return function(u,_,p){if (!f._enabled) {
    f._unwrap(c,"getConnection");
    return l.apply(c,args);
  }if(args.length===1&&typeof u=="function"){const E=f._getConnectionCallbackPatchFn(u);return l.call(c,E)}if(args.length===2&&typeof _=="function"){const E=f._getConnectionCallbackPatchFn(_);return l.call(c,u,E)}if(args.length===3&&typeof p=="function"){const E=f._getConnectionCallbackPatchFn(p);return l.call(c,u,_,E)}return l.apply(c,args);};};}_getConnectionCallbackPatchFn(c){
    const l=this;
    const f=e.context.active();
    return function(d,u){
      if (u) {
        if (!(0,t.isWrapped)(u.query)) {
          l._wrap(u,"query",l._patchQuery(u));
        }
      }

      if (typeof c=="function") {
        e.context.with(f,c,this,d,u);
      }
    };
  }_patchQuery(c){return l=>{const f=this;return function(d,u,_){
    if (!f._enabled) {
      f._unwrap(c,"query");
      return l.apply(c,args);
    }const p=f.tracer.startSpan((0,o.getSpanName)(d),{kind:e.SpanKind.CLIENT,attributes:{...i.COMMON_ATTRIBUTES,...(0,o.getConnectionAttributes)(c.config)}});
    p.setAttribute(n.ATTR_DB_STATEMENT,(0,o.getDbStatement)(d));

    if (f.getConfig().enhancedDatabaseReporting) {
      let T;

      if (Array.isArray(u)) {
        T=u;
      } else if (args[2]) {
        (T = [u]);
      }

      p.setAttribute(r.AttributeNames.MYSQL_VALUES,(0,o.getDbValues)(d,T));
    }

    const E=Array.from(args).findIndex(T => typeof T=="function");

    const h=e.context.active();
    if (E===-1) {
      const T=e.context.with(e.trace.setSpan(e.context.active(),p),() => l.apply(c,args));
      e.context.bind(h,T);

      return T.on("error",m => p.setStatus({code:e.SpanStatusCode.ERROR,message:m.message})).on("end",()=>{p.end()});
    } else {
      f._wrap(args,E,f._patchCallbackQuery(p,h));

      return e.context.with(e.trace.setSpan(e.context.active(),p),() => l.apply(c,args));
    }
  };};}_patchCallbackQuery(c,l){return f => (function(d, u, _) {
    if (d) {
      c.setStatus({code:e.SpanStatusCode.ERROR,message:d.message});
    }

    c.end();

    return e.context.with(l,() => f(...args));
  });}_setPoolcallbacks(c,l,f){
    const d=f||(0,o.getPoolName)(c);
    c.on("connection",u=>{l._connectionsUsage.add(1,{state:"idle",name:d})});

    c.on("acquire",u=>{
      l._connectionsUsage.add(-1,{state:"idle",name:d});
      l._connectionsUsage.add(1,{state:"used",name:d});
    });

    c.on("release",u=>{
      l._connectionsUsage.add(-1,{state:"used",name:d});
      l._connectionsUsage.add(1,{state:"idle",name:d});
    });
  }}
  ma.MySQLInstrumentation=i;
  return ma;
}let gN;function aW(){
  if (!gN) {
    gN=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.MySQLInstrumentation=void 0;
      const t=iW();Object.defineProperty(e,"MySQLInstrumentation",{enumerable:true,get() {return t.MySQLInstrumentation}})
    })(Zd);
  }

  return Zd;
}const cW=aW();
const iv="Mysql";

const uW=Ne(iv,() => new cW.MySQLInstrumentation({}));

const lW=(() => ({
  name:iv,
  setupOnce(){uW()}
}));

const dW=lW;
const Qd={};
const Aa={};
const Je={};
let RN;
function av(){
  if (!RN) {
    RN=1;
    Object.defineProperty(Je,"__esModule",{value:true});
    Je.DB_SYSTEM_VALUE_MYSQL=Je.ATTR_NET_PEER_PORT=Je.ATTR_NET_PEER_NAME=Je.ATTR_DB_USER=Je.ATTR_DB_SYSTEM=Je.ATTR_DB_STATEMENT=Je.ATTR_DB_NAME=Je.ATTR_DB_CONNECTION_STRING=void 0;
    Je.ATTR_DB_CONNECTION_STRING="db.connection_string";
    Je.ATTR_DB_NAME="db.name";
    Je.ATTR_DB_STATEMENT="db.statement";
    Je.ATTR_DB_SYSTEM="db.system";
    Je.ATTR_DB_USER="db.user";
    Je.ATTR_NET_PEER_NAME="net.peer.name";
    Je.ATTR_NET_PEER_PORT="net.peer.port";
    Je.DB_SYSTEM_VALUE_MYSQL="mysql";
  }

  return Je;
}
const ga={};
let NN;
function cv(){
  if (NN) {
    return ga;
  }
  NN=1;
  Object.defineProperty(ga,"__esModule",{value:true});
  ga.addSqlCommenterComment=void 0;
  const e=Pe();
  const t=dn;
  function n(s){const i=s.indexOf("--");if (i>=0) {
    return true;
  }if (!s.includes("/*")) {
    return false;
  }const c=s.indexOf("*/");return i<c}function r(s){return encodeURIComponent(s).replace(/[!'()*]/g,i => `%${i.charCodeAt(0).toString(16).toUpperCase()}`);}function o(s,i){
    if (typeof i!="string"||i.length===0||n(i)) {
      return i;
    }
    const a=new t.W3CTraceContextPropagator;
    const c={};
    a.inject(e.trace.setSpan(e.ROOT_CONTEXT,s),c,e.defaultTextMapSetter);const l=Object.keys(c).sort();if (l.length===0) {
      return i;
    }const f=l.map(d=>{const u=r(c[d]);return`${d}='${u}'`}).join(",");return`${i} /*${f}*/`
  }
  ga.addSqlCommenterComment=o;
  return ga;
}
const vt={};
let yN;
function fW(){
  if (yN) {
    return vt;
  }
  yN=1;
  Object.defineProperty(vt,"__esModule",{value:true});
  vt.getConnectionPrototypeToInstrument = void 0;
  vt.once = void 0;
  vt.getSpanName = void 0;
  vt.getQueryText = void 0;
  vt.getConnectionAttributes = void 0;
  const e=av();
  const t=Le;
  const n=pt();
  function r(u,_,p){
    const {host,port,database,user}=o(u);
    const A={};

    if (_&t.SemconvStability.OLD) {
      A[e.ATTR_DB_CONNECTION_STRING]=s(host,port,database);
      A[e.ATTR_DB_NAME]=database;
      A[e.ATTR_DB_USER]=user;
    }

    if (_&t.SemconvStability.STABLE) {
      (A[n.ATTR_DB_NAMESPACE] = database);
    }

    const g=parseInt(port,10);

    if (p&t.SemconvStability.OLD) {
      A[e.ATTR_NET_PEER_NAME]=host;
      isNaN(g)||(A[e.ATTR_NET_PEER_PORT]=g);
    }

    if (p&t.SemconvStability.STABLE) {
      A[n.ATTR_SERVER_ADDRESS]=host;
      isNaN(g)||(A[n.ATTR_SERVER_PORT]=g);
    }

    return A;
  }vt.getConnectionAttributes=r;function o(u){const{host,port,database,user}=u&&u.connectionConfig||u||{};return {host:host,port:port,database:database,user:user};}function s(u,_,p){
  let E=`jdbc:mysql://${u||"localhost"}`;

  if (typeof _=="number") {
    (E += `:${_}`);
  }

  if (typeof p=="string") {
    (E += `/${p}`);
  }

  return E;
}function i(u,_,p,E=false,h=a){const[T,m]=typeof u=="string"?[u,p]:[u.sql,c(u)?p||u.values:p];try{return E?h(T):_&&m?_(T,m):T}catch{return"Could not determine the query due to an error in masking or formatting"}}vt.getQueryText=i;function a(u){return u.replace(/\b\d+\b/g,"?").replace(/(["'])(?:(?=(\\?))\2.)*?\1/g,"?");}function c(u){return"values"in u}function l(u){
    const _=typeof u=="object"?u.sql:u;
    const p=_?.indexOf(" ");
    return typeof p=="number"&&p!==-1?_?.substring(0,p):_
  }vt.getSpanName=l;const f=u=>{let _=false;return (...p)=>{if (!_) {
    _=true;
    return u(...p);
  }};};vt.once=f;function d(u){
    const _=u.prototype;
    const p=Object.getPrototypeOf(_);
    return typeof p?.query=="function"&&typeof p?.execute=="function"?p:_
  }
  vt.getConnectionPrototypeToInstrument=d;
  return vt;
}
const Dr={};
let ON;
function _W(){
  if (!ON) {
    ON=1;
    Object.defineProperty(Dr,"__esModule",{value:true});
    Dr.PACKAGE_NAME=Dr.PACKAGE_VERSION=void 0;
    Dr.PACKAGE_VERSION="0.55.0";
    Dr.PACKAGE_NAME="@opentelemetry/instrumentation-mysql2";
  }

  return Dr;
}let bN;function pW(...args) {
  if (bN) {
    return Aa;
  }
  bN=1;
  Object.defineProperty(Aa,"__esModule",{value:true});
  Aa.MySQL2Instrumentation=void 0;
  const e=Pe();
  const t=Le;
  const n=av();
  const r=cv();
  const o=fW();
  const s=_W();
  const i=pt();
  const a=[">=1.4.2 <4"];
  class c extends t.InstrumentationBase{_netSemconvStability;_dbSemconvStability;constructor(f={}){
    super(s.PACKAGE_NAME,s.PACKAGE_VERSION,f);
    this._setSemconvStabilityFromEnv();
  }_setSemconvStabilityFromEnv(){
    this._netSemconvStability=(0,t.semconvStabilityFromStr)("http",process.env.OTEL_SEMCONV_STABILITY_OPT_IN);
    this._dbSemconvStability=(0,t.semconvStabilityFromStr)("database",process.env.OTEL_SEMCONV_STABILITY_OPT_IN);
  }init(){
    let f;function d(p){
    if (!f&&p.format) {
      (f = p.format);
    }
  }

    const u=p=>{
      if ((0,t.isWrapped)(p.query)) {
        this._unwrap(p,"query");
      }

      this._wrap(p,"query",this._patchQuery(f,false));

      if ((0,t.isWrapped)(p.execute)) {
        this._unwrap(p,"execute");
      }

      this._wrap(p,"execute",this._patchQuery(f,true));
    };

    const _=p=>{
      this._unwrap(p,"query");
      this._unwrap(p,"execute");
    };

    return [new t.InstrumentationNodeModuleDefinition("mysql2",a,p => {
      d(p);
      return p;
    },()=>{},[new t.InstrumentationNodeModuleFile("mysql2/promise.js",a,p => {
      d(p);
      return p;
    },()=>{}),new t.InstrumentationNodeModuleFile("mysql2/lib/connection.js",a,p=>{
      const E=(0,o.getConnectionPrototypeToInstrument)(p);
      u(E);
      return p;
    },p=>{if (p===void 0) {
      return;
    }const E=(0,o.getConnectionPrototypeToInstrument)(p);_(E)})])];
  }_patchQuery(f,d){return u=>{const _=this;return function(p,E,h){
    let T;

    if (Array.isArray(E)) {
      T=E;
    } else if (args[2]) {
      (T = [E]);
    }

    const {maskStatement,maskStatementHook,responseHook}=_.getConfig();
    const R=(0,o.getConnectionAttributes)(this.config,_._dbSemconvStability,_._netSemconvStability);
    const O=(0,o.getQueryText)(p,f,T,maskStatement,maskStatementHook);

    if (_._dbSemconvStability&t.SemconvStability.OLD) {
      R[n.ATTR_DB_SYSTEM]=n.DB_SYSTEM_VALUE_MYSQL;
      R[n.ATTR_DB_STATEMENT]=O;
    }

    if (_._dbSemconvStability&t.SemconvStability.STABLE) {
      R[i.ATTR_DB_SYSTEM_NAME]=i.DB_SYSTEM_NAME_VALUE_MYSQL;
      R[i.ATTR_DB_QUERY_TEXT]=O;
    }

    const I=_.tracer.startSpan((0,o.getSpanName)(p),{kind:e.SpanKind.CLIENT,attributes:R});

    if (!d&&_.getConfig().addSqlCommenterCommentToQueries) {
      (args[0] = p=typeof p=="string"?(0,r.addSqlCommenterComment)(I,p):Object.assign(p,{sql:(0,r.addSqlCommenterComment)(I,p.sql)}));
    }

    const b=(0,o.once)((L,U)=>{
      if (L) {
        I.setStatus({code:e.SpanStatusCode.ERROR,message:L.message});
      } else if (typeof responseHook=="function") {
        (0,t.safeExecuteInTheMiddle)(()=>{responseHook(I,{queryResults:U})},q=>{
          if (q) {
            _._diag.warn("Failed executing responseHook",q);
          }
        },true);
      }

      I.end();
    });if(args.length===1){
      if (typeof p.onResult=="function") {
        _._wrap(p,"onResult",_._patchCallbackQuery(b));
      }

      const L=u.apply(this,args);
      L.once("error",U=>{b(U)}).once("result",U=>{b(void 0,U)});
      return L;
    }

    if (typeof args[1]=="function") {
      _._wrap(args,1,_._patchCallbackQuery(b));
    } else if (typeof args[2]=="function") {
      _._wrap(args,2,_._patchCallbackQuery(b));
    }

    return u.apply(this,args);
  };};}_patchCallbackQuery(f){return d => (function(u, _, p) {
    f(u,_);
    return d(...args);
  });}}
  Aa.MySQL2Instrumentation=c;
  return Aa;
}let CN;function EW(){
  if (!CN) {
    CN=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.MySQL2Instrumentation=void 0;
      const t=pW();Object.defineProperty(e,"MySQL2Instrumentation",{enumerable:true,get() {return t.MySQL2Instrumentation}})
    })(Qd);
  }

  return Qd;
}const hW=EW();
const uv="Mysql2";

const TW=Ne(uv,() => new hW.MySQL2Instrumentation({responseHook(e){yt(e,"auto.db.otel.mysql2")}}));

const SW=(() => ({
  name:uv,
  setupOnce(){TW()}
}));

const mW=SW;
const Jd={};
const Ra={};
const St={};
let IN;
function AW(){
  if (!IN) {
    IN=1;
    Object.defineProperty(St,"__esModule",{value:true});
    St.DB_SYSTEM_VALUE_REDIS=St.ATTR_NET_PEER_PORT=St.ATTR_NET_PEER_NAME=St.ATTR_DB_SYSTEM=St.ATTR_DB_STATEMENT=St.ATTR_DB_CONNECTION_STRING=void 0;
    St.ATTR_DB_CONNECTION_STRING="db.connection_string";
    St.ATTR_DB_STATEMENT="db.statement";
    St.ATTR_DB_SYSTEM="db.system";
    St.ATTR_NET_PEER_NAME="net.peer.name";
    St.ATTR_NET_PEER_PORT="net.peer.port";
    St.DB_SYSTEM_VALUE_REDIS="redis";
  }

  return St;
}
const Na={};
let PN;
function gW(){
  if (PN) {
    return Na;
  }
  PN=1;
  Object.defineProperty(Na,"__esModule",{value:true});
  Na.endSpan=void 0;
  const e=Pe();

  const t=(n,r)=>{
    if (r) {
      n.recordException(r);
      n.setStatus({code:e.SpanStatusCode.ERROR,message:r.message});
    }

    n.end();
  };

  Na.endSpan=t;
  return Na;
}
const ya={};
let MN;
function eh(){
  if (MN) {
    return ya;
  }
  MN=1;
  Object.defineProperty(ya,"__esModule",{value:true});
  ya.defaultDbStatementSerializer=void 0;
  const e=[{regex:/^ECHO/i,args:0},{regex:/^(LPUSH|MSET|PFA|PUBLISH|RPUSH|SADD|SET|SPUBLISH|XADD|ZADD)/i,args:1},{regex:/^(HSET|HMSET|LSET|LINSERT)/i,args:2},{regex:/^(ACL|BIT|B[LRZ]|CLIENT|CLUSTER|CONFIG|COMMAND|DECR|DEL|EVAL|EX|FUNCTION|GEO|GET|HINCR|HMGET|HSCAN|INCR|L[TRLM]|MEMORY|P[EFISTU]|RPOP|S[CDIMORSU]|XACK|X[CDGILPRT]|Z[CDILMPRS])/i,args:-1}];

  const t=(n,r)=>{if(Array.isArray(r)&&r.length){
    const o=e.find(({regex}) => regex.test(n))?.args??0;

    const s=o>=0?r.slice(0,o):r;

    if (r.length>s.length) {
      s.push(`[${r.length-o} other arguments]`);
    }

    return `${n} ${s.join(" ")}`;
  }return n};

  ya.defaultDbStatementSerializer=t;
  return ya;
}
const Ur={};
let vN;
function RW(){
  if (!vN) {
    vN=1;
    Object.defineProperty(Ur,"__esModule",{value:true});
    Ur.PACKAGE_NAME=Ur.PACKAGE_VERSION=void 0;
    Ur.PACKAGE_VERSION="0.56.0";
    Ur.PACKAGE_NAME="@opentelemetry/instrumentation-ioredis";
  }

  return Ur;
}let LN;function NW(...args) {
  if (LN) {
    return Ra;
  }
  LN=1;
  Object.defineProperty(Ra,"__esModule",{value:true});
  Ra.IORedisInstrumentation=void 0;
  const e=Pe();
  const t=Le;
  const n=AW();
  const r=Le;
  const o=gW();
  const s=eh();
  const i=RW();
  const a={requireParentSpan:true};
  class c extends t.InstrumentationBase{constructor(f={}){super(i.PACKAGE_NAME,i.PACKAGE_VERSION,{...a,...f})}setConfig(f={}){super.setConfig({...a,...f})}init(){return [new t.InstrumentationNodeModuleDefinition("ioredis",[">=2.0.0 <6"],(f,d)=>{
    const u=f[Symbol.toStringTag]==="Module"?f.default:f;

    if ((0,t.isWrapped)(u.prototype.sendCommand)) {
      this._unwrap(u.prototype,"sendCommand");
    }

    this._wrap(u.prototype,"sendCommand",this._patchSendCommand(d));

    if ((0,t.isWrapped)(u.prototype.connect)) {
      this._unwrap(u.prototype,"connect");
    }

    this._wrap(u.prototype,"connect",this._patchConnection());
    return f;
  },f=>{
    if (f===void 0) {
      return;
    }const d=f[Symbol.toStringTag]==="Module"?f.default:f;
    this._unwrap(d.prototype,"sendCommand");
    this._unwrap(d.prototype,"connect");
  })];}_patchSendCommand(f){return d => this._traceSendCommand(d,f);}_patchConnection(){return f => this._traceConnection(f);}_traceSendCommand(f,d){const u=this;return function(_){
    if (args.length<1||typeof _!="object") {
      return f.apply(this,args);
    }
    const p=u.getConfig();
    const E=p.dbStatementSerializer||s.defaultDbStatementSerializer;
    const h=e.trace.getSpan(e.context.active())===void 0;
    if (p.requireParentSpan===true&&h) {
      return f.apply(this,args);
    }
    const T=u.tracer.startSpan(_.name,{kind:e.SpanKind.CLIENT,attributes:{[n.ATTR_DB_SYSTEM]:n.DB_SYSTEM_VALUE_REDIS,[n.ATTR_DB_STATEMENT]:E(_.name,_.args)}});
    const {requestHook}=p;

    if (requestHook) {
      (0,r.safeExecuteInTheMiddle)(() => requestHook(T,{moduleVersion:d,cmdName:_.name,cmdArgs:_.args}),R=>{
        if (R) {
          e.diag.error("ioredis instrumentation: request hook failed",R);
        }
      },true);
    }

    const{host,port}=this.options;T.setAttributes({[n.ATTR_NET_PEER_NAME]:host,[n.ATTR_NET_PEER_PORT]:port,[n.ATTR_DB_CONNECTION_STRING]:`redis://${host}:${port}`});try{
        const R=f.apply(this,args);
        const O=_.resolve;
        _.resolve=b => {
          (0,r.safeExecuteInTheMiddle)(() => p.responseHook?.(T,_.name,_.args,b),L=>{
            if (L) {
              e.diag.error("ioredis instrumentation: response hook failed",L);
            }
          },true);

          (0,o.endSpan)(T,null);
          O(b);
        };const I=_.reject;

        _.reject=b => {
          (0,o.endSpan)(T,b);
          I(b);
        };

        return R;
      }catch(R){
        (0,o.endSpan)(T,R);
        throw R;
      }
  };}_traceConnection(f){const d=this;return function(...args) {
    const u=e.trace.getSpan(e.context.active())===void 0;if (d.getConfig().requireParentSpan===true&&u) {
      return f.apply(this,args);
    }
    const _=d.tracer.startSpan("connect",{kind:e.SpanKind.CLIENT,attributes:{[n.ATTR_DB_SYSTEM]:n.DB_SYSTEM_VALUE_REDIS,[n.ATTR_DB_STATEMENT]:"connect"}});
    const {host,port}=this.options;
    _.setAttributes({[n.ATTR_NET_PEER_NAME]:host,[n.ATTR_NET_PEER_PORT]:port,[n.ATTR_DB_CONNECTION_STRING]:`redis://${host}:${port}`});try{
      const h=f.apply(this,args);
      (0,o.endSpan)(_,null);
      return h;
    }catch(h){
      (0,o.endSpan)(_,h);
      throw h;
    }
  };}}
  Ra.IORedisInstrumentation=c;
  return Ra;
}let wN;function yW(){
  if (!wN) {
    wN=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.IORedisInstrumentation=void 0;
      const t=NW();Object.defineProperty(e,"IORedisInstrumentation",{enumerable:true,get() {return t.IORedisInstrumentation}})
    })(Jd);
  }

  return Jd;
}
const OW=yW();
const ef={};
const Oa={};
const kr={};
let DN;
function th(){
  if (!DN) {
    DN=1;
    Object.defineProperty(kr,"__esModule",{value:true});
    kr.PACKAGE_NAME=kr.PACKAGE_VERSION=void 0;
    kr.PACKAGE_VERSION="0.57.0";
    kr.PACKAGE_NAME="@opentelemetry/instrumentation-redis";
  }

  return kr;
}
const ba={};
const Mn={};
let UN;
function bW(){
  if (UN) {
    return Mn;
  }
  UN=1;
  Object.defineProperty(Mn,"__esModule",{value:true});
  Mn.getTracedCreateStreamTrace = void 0;
  Mn.getTracedCreateClient = void 0;
  Mn.endSpan = void 0;
  const e=Pe();

  const t=(o,s)=>{
    if (s) {
      o.setStatus({code:e.SpanStatusCode.ERROR,message:s.message});
    }

    o.end();
  };

  Mn.endSpan=t;const n=o => (function(...args) {const i=o.apply(this,args);return e.context.bind(e.context.active(),i)});Mn.getTracedCreateClient=n;const r=o => (function(...args) {
  if (!Object.prototype.hasOwnProperty.call(this,"stream")) {
    Object.defineProperty(this,"stream",{get(){return this._patched_redis_stream},set(i){
      e.context.bind(e.context.active(),i);
      this._patched_redis_stream=i;
    }});
  }

  return o.apply(this,args);
});
  Mn.getTracedCreateStreamTrace=r;
  return Mn;
}
const ot={};
let kN;
function nh(){
  if (!kN) {
    kN=1;
    Object.defineProperty(ot,"__esModule",{value:true});
    ot.DB_SYSTEM_VALUE_REDIS=ot.DB_SYSTEM_NAME_VALUE_REDIS=ot.ATTR_NET_PEER_PORT=ot.ATTR_NET_PEER_NAME=ot.ATTR_DB_SYSTEM=ot.ATTR_DB_STATEMENT=ot.ATTR_DB_CONNECTION_STRING=void 0;
    ot.ATTR_DB_CONNECTION_STRING="db.connection_string";
    ot.ATTR_DB_STATEMENT="db.statement";
    ot.ATTR_DB_SYSTEM="db.system";
    ot.ATTR_NET_PEER_NAME="net.peer.name";
    ot.ATTR_NET_PEER_PORT="net.peer.port";
    ot.DB_SYSTEM_NAME_VALUE_REDIS="redis";
    ot.DB_SYSTEM_VALUE_REDIS="redis";
  }

  return ot;
}let GN;function CW(...args) {
  if (GN) {
    return ba;
  }
  GN=1;
  Object.defineProperty(ba,"__esModule",{value:true});
  ba.RedisInstrumentationV2_V3=void 0;
  const e=Le;
  const t=bW();
  const n=th();
  const r=Pe();
  const o=pt();
  const s=nh();
  const i=eh();
  class a extends e.InstrumentationBase{static COMPONENT="redis";_semconvStability;constructor(l={}){
    super(n.PACKAGE_NAME,n.PACKAGE_VERSION,l);
    this._semconvStability=l.semconvStability?l.semconvStability:(0,e.semconvStabilityFromStr)("database",process.env.OTEL_SEMCONV_STABILITY_OPT_IN);
  }setConfig(l={}){
    super.setConfig(l);
    this._semconvStability=l.semconvStability?l.semconvStability:(0,e.semconvStabilityFromStr)("database",process.env.OTEL_SEMCONV_STABILITY_OPT_IN);
  }init(){return [new e.InstrumentationNodeModuleDefinition("redis",[">=2.6.0 <4"],l => {
    if ((0,e.isWrapped)(l.RedisClient.prototype.internal_send_command)) {
      this._unwrap(l.RedisClient.prototype,"internal_send_command");
    }

    this._wrap(l.RedisClient.prototype,"internal_send_command",this._getPatchInternalSendCommand());

    if ((0,e.isWrapped)(l.RedisClient.prototype.create_stream)) {
      this._unwrap(l.RedisClient.prototype,"create_stream");
    }

    this._wrap(l.RedisClient.prototype,"create_stream",this._getPatchCreateStream());

    if ((0,e.isWrapped)(l.createClient)) {
      this._unwrap(l,"createClient");
    }

    this._wrap(l,"createClient",this._getPatchCreateClient());
    return l;
  },l=>{
    if (l!==void 0) {
      this._unwrap(l.RedisClient.prototype,"internal_send_command");
      this._unwrap(l.RedisClient.prototype,"create_stream");
      this._unwrap(l,"createClient");
    }
  })];}_getPatchInternalSendCommand(){const l=this;return d => (function(_) {
    if (args.length!==1||typeof _!="object") {
      return d.apply(this,args);
    }
    const p=l.getConfig();
    const E=r.trace.getSpan(r.context.active())===void 0;
    if (p.requireParentSpan===true&&E) {
      return d.apply(this,args);
    }
    const h=p?.dbStatementSerializer||i.defaultDbStatementSerializer;
    const T={};

    if (l._semconvStability&e.SemconvStability.OLD) {
      Object.assign(T,{[s.ATTR_DB_SYSTEM]:s.DB_SYSTEM_VALUE_REDIS,[s.ATTR_DB_STATEMENT]:h(_.command,_.args)});
    }

    if (l._semconvStability&e.SemconvStability.STABLE) {
      Object.assign(T,{[o.ATTR_DB_SYSTEM_NAME]:s.DB_SYSTEM_NAME_VALUE_REDIS,[o.ATTR_DB_OPERATION_NAME]:_.command,[o.ATTR_DB_QUERY_TEXT]:h(_.command,_.args)});
    }

    const m=l.tracer.startSpan(`${a.COMPONENT}-${_.command}`,{kind:r.SpanKind.CLIENT,attributes:T});if(this.connection_options){
      const g={};

      if (l._semconvStability&e.SemconvStability.OLD) {
        Object.assign(g,{[s.ATTR_NET_PEER_NAME]:this.connection_options.host,[s.ATTR_NET_PEER_PORT]:this.connection_options.port});
      }

      if (l._semconvStability&e.SemconvStability.STABLE) {
        Object.assign(g,{[o.ATTR_SERVER_ADDRESS]:this.connection_options.host,[o.ATTR_SERVER_PORT]:this.connection_options.port});
      }

      m.setAttributes(g);
    }

    if (this.address&&l._semconvStability&e.SemconvStability.OLD) {
      m.setAttribute(s.ATTR_DB_CONNECTION_STRING,`redis://${this.address}`);
    }

    const A=args[0].callback;if(A){const g=r.context.active();args[0].callback=function(O,I){
        if(p?.responseHook){const b=p.responseHook;(0,e.safeExecuteInTheMiddle)(()=>{b(m,_.command,_.args,I)},L=>{
          if (L) {
            l._diag.error("Error executing responseHook",L);
          }
        },true)}
        (0,t.endSpan)(m,O);
        return r.context.with(g,A,this,...args);
      }}try{return d.apply(this,args);}catch(g){
        (0,t.endSpan)(m,g);
        throw g;
      }
  });}_getPatchCreateClient(){return f => (0,t.getTracedCreateClient)(f);}_getPatchCreateStream(){return f => (0,t.getTracedCreateStreamTrace)(f);}}
  ba.RedisInstrumentationV2_V3=a;
  return ba;
}
const Ca={};
const Ia={};
let VN;
function IW(){
  if (VN) {
    return Ia;
  }
  VN=1;
  Object.defineProperty(Ia,"__esModule",{value:true});
  Ia.getClientAttributes=void 0;
  const e=pt();
  const t=nh();
  const n=Le;
  function r(s,i,a){
    const c={};

    if (a&n.SemconvStability.OLD) {
      Object.assign(c,{[t.ATTR_DB_SYSTEM]:t.DB_SYSTEM_VALUE_REDIS,[t.ATTR_NET_PEER_NAME]:i?.socket?.host,[t.ATTR_NET_PEER_PORT]:i?.socket?.port,[t.ATTR_DB_CONNECTION_STRING]:o(s,i?.url)});
    }

    if (a&n.SemconvStability.STABLE) {
      Object.assign(c,{[e.ATTR_DB_SYSTEM_NAME]:t.DB_SYSTEM_NAME_VALUE_REDIS,[e.ATTR_SERVER_ADDRESS]:i?.socket?.host,[e.ATTR_SERVER_PORT]:i?.socket?.port});
    }

    return c;
  }Ia.getClientAttributes=r;function o(s,i){if (!(typeof i!="string"||!i)) {
    try{
      const a=new URL(i);
      a.searchParams.delete("user_pwd");
      a.username="";
      a.password="";
      return a.href;
    }catch(a){s.error("failed to sanitize redis connection url",a)}
  }}return Ia
}let xN;function PW(...args) {
  if (xN) {
    return Ca;
  }
  xN=1;
  Object.defineProperty(Ca,"__esModule",{value:true});
  Ca.RedisInstrumentationV4_V5=void 0;
  const e=Pe();
  const t=Le;
  const n=IW();
  const r=eh();
  const o=th();
  const s=pt();
  const i=nh();
  const a=Symbol("opentelemetry.instrumentation.redis.open_spans");
  const c=Symbol("opentelemetry.instrumentation.redis.multi_command_options");
  class l extends t.InstrumentationBase{static COMPONENT="redis";_semconvStability;constructor(d={}){
    super(o.PACKAGE_NAME,o.PACKAGE_VERSION,d);
    this._semconvStability=d.semconvStability?d.semconvStability:(0,t.semconvStabilityFromStr)("database",process.env.OTEL_SEMCONV_STABILITY_OPT_IN);
  }setConfig(d={}){
    super.setConfig(d);
    this._semconvStability=d.semconvStability?d.semconvStability:(0,t.semconvStabilityFromStr)("database",process.env.OTEL_SEMCONV_STABILITY_OPT_IN);
  }init(){return[this._getInstrumentationNodeModuleDefinition("@redis/client"),this._getInstrumentationNodeModuleDefinition("@node-redis/client")]}_getInstrumentationNodeModuleDefinition(d){
    const u=new t.InstrumentationNodeModuleFile(`${d}/dist/lib/commander.js`,["^1.0.0"],(E,h)=>{
      const T=E.transformCommandArguments;if (!T) {
          this._diag.error("internal instrumentation error, missing transformCommandArguments function");
          return E;
        }const m=h?.startsWith("1.0.")?"extendWithCommands":"attachCommands";

      if ((0,t.isWrapped)(E?.[m])) {
        this._unwrap(E,m);
      }

      this._wrap(E,m,this._getPatchExtendWithCommands(T));
      return E;
    },E=>{
      if ((0,t.isWrapped)(E?.extendWithCommands)) {
        this._unwrap(E,"extendWithCommands");
      }

      if ((0,t.isWrapped)(E?.attachCommands)) {
        this._unwrap(E,"attachCommands");
      }
    });

    const _=new t.InstrumentationNodeModuleFile(`${d}/dist/lib/client/multi-command.js`,["^1.0.0","^5.0.0"],E=>{
      const h=E?.default?.prototype;

      if ((0,t.isWrapped)(h?.exec)) {
        this._unwrap(h,"exec");
      }

      this._wrap(h,"exec",this._getPatchMultiCommandsExec());

      if ((0,t.isWrapped)(h?.addCommand)) {
        this._unwrap(h,"addCommand");
      }

      this._wrap(h,"addCommand",this._getPatchMultiCommandsAddCommand());
      return E;
    },E=>{
      const h=E?.default?.prototype;

      if ((0,t.isWrapped)(h?.exec)) {
        this._unwrap(h,"exec");
      }

      if ((0,t.isWrapped)(h?.addCommand)) {
        this._unwrap(h,"addCommand");
      }
    });

    const p=new t.InstrumentationNodeModuleFile(`${d}/dist/lib/client/index.js`,["^1.0.0","^5.0.0"],E=>{
      const h=E?.default?.prototype;

      if (h?.multi) {
        (0,t.isWrapped)(h?.multi)&&this._unwrap(h,"multi");
        this._wrap(h,"multi",this._getPatchRedisClientMulti());
      }

      if (h?.MULTI) {
        (0,t.isWrapped)(h?.MULTI)&&this._unwrap(h,"MULTI");
        this._wrap(h,"MULTI",this._getPatchRedisClientMulti());
      }

      if ((0,t.isWrapped)(h?.sendCommand)) {
        this._unwrap(h,"sendCommand");
      }

      this._wrap(h,"sendCommand",this._getPatchRedisClientSendCommand());
      this._wrap(h,"connect",this._getPatchedClientConnect());
      return E;
    },E=>{
      const h=E?.default?.prototype;

      if ((0,t.isWrapped)(h?.multi)) {
        this._unwrap(h,"multi");
      }

      if ((0,t.isWrapped)(h?.MULTI)) {
        this._unwrap(h,"MULTI");
      }

      if ((0,t.isWrapped)(h?.sendCommand)) {
        this._unwrap(h,"sendCommand");
      }
    });

    return new t.InstrumentationNodeModuleDefinition(d,["^1.0.0","^5.0.0"],E => E,()=>{},[u,_,p]);
  }_getPatchExtendWithCommands(d){const u=this;return p => (function(h) {
    if (h?.BaseClass?.name!=="RedisClient") {
      return p.apply(this,args);
    }const T=h.executor;
    h.executor=function(m,A){const g=d(m,A).args;return u._traceClientCommand(T,this,args,g);};
    return p.apply(this,args);
  });}_getPatchMultiCommandsExec(){const d=this;return _ => (function(...args) {const E=_.apply(this,args);return typeof E?.then!="function"?(d._diag.error("got non promise result when patching RedisClientMultiCommand.exec"),E):E.then(h=>{
    const T=this[a];
    d._endSpansWithRedisReplies(T,h);
    return h;
  }).catch(h=>{const T=this[a];if (!T) {
    d._diag.error("cannot find open spans to end for redis multi command");
  } else
    {const m=h.constructor.name==="MultiErrorReply"?h.replies:new Array(T.length).fill(h);d._endSpansWithRedisReplies(T,m)}return Promise.reject(h)});});}_getPatchMultiCommandsAddCommand(){const d=this;return _ => (function(E) {return d._traceClientCommand(_,this,args,E);});}_getPatchRedisClientMulti(){return u => (function(...args) {
    const p=u.apply(this,args);
    p[c]=this.options;
    return p;
  });}_getPatchRedisClientSendCommand(){const d=this;return _ => (function(E) {return d._traceClientCommand(_,this,args,E);});}_getPatchedClientConnect(){const d=this;return _ => (function() {
    const E=this.options;
    const h=(0,n.getClientAttributes)(d._diag,E,d._semconvStability);
    const T=d.tracer.startSpan(`${l.COMPONENT}-connect`,{kind:e.SpanKind.CLIENT,attributes:h});
    return e.context.with(e.trace.setSpan(e.context.active(),T),() => _.apply(this)).then(A => {
      T.end();
      return A;
    }).catch(A => {
      T.recordException(A);
      T.setStatus({code:e.SpanStatusCode.ERROR,message:A.message});
      T.end();
      return Promise.reject(A);
    });
  });}_traceClientCommand(d,u,_,p){
    if (e.trace.getSpan(e.context.active())===void 0&&this.getConfig().requireParentSpan) {
      return d.apply(u,_);
    }
    const h=u.options||u[c];
    const T=p[0];
    const m=p.slice(1);
    const A=this.getConfig().dbStatementSerializer||r.defaultDbStatementSerializer;
    const g=(0,n.getClientAttributes)(this._diag,h,this._semconvStability);

    if (this._semconvStability&t.SemconvStability.STABLE) {
      (g[s.ATTR_DB_OPERATION_NAME] = T);
    }

    try{
      const I=A(T,m);

      if (I!=null) {
        this._semconvStability&t.SemconvStability.OLD&&(g[i.ATTR_DB_STATEMENT]=I);
        this._semconvStability&t.SemconvStability.STABLE&&(g[s.ATTR_DB_QUERY_TEXT]=I);
      }
    }catch(I){this._diag.error("dbStatementSerializer throw an exception",I,{commandName:T})}
    const R=this.tracer.startSpan(`${l.COMPONENT}-${T}`,{kind:e.SpanKind.CLIENT,attributes:g});

    const O=e.context.with(e.trace.setSpan(e.context.active(),R),() => d.apply(u,_));

    if (typeof O?.then=="function") {
      O.then(I=>{this._endSpanWithResponse(R,T,m,I,void 0)},I=>{this._endSpanWithResponse(R,T,m,null,I)});
    } else {
      const I=O;
      I[a]=I[a]||[];
      I[a].push({span:R,commandName:T,commandArgs:m});
    }return O
  }_endSpansWithRedisReplies(d,u){if (!d) {
    return this._diag.error("cannot find open spans to end for redis multi command");
  }if (u.length!==d.length) {
    return this._diag.error("number of multi command spans does not match response from redis");
  }for(let _=0;_<d.length;_++){
    const {span,commandName,commandArgs}=d[_];
    const T=u[_];
    const [m,A]=T instanceof Error?[null,T]:[T,void 0];
    this._endSpanWithResponse(span,commandName,commandArgs,m,A)
  }}_endSpanWithResponse(d,u,_,p,E){
    const{responseHook}=this.getConfig();if (!E&&responseHook) {
        try{responseHook(d,u,_,p)}catch(T){this._diag.error("responseHook throw an exception",T)}
      }

    if (E) {
      d.recordException(E);
      d.setStatus({code:e.SpanStatusCode.ERROR,message:E?.message});
    }

    d.end();
  }}
  Ca.RedisInstrumentationV4_V5=l;
  return Ca;
}let $N;function MW(){
  if ($N) {
    return Oa;
  }
  $N=1;
  Object.defineProperty(Oa,"__esModule",{value:true});
  Oa.RedisInstrumentation=void 0;
  const e=Le;
  const t=th();
  const n=CW();
  const r=PW();
  const o={requireParentSpan:false};
  class s extends e.InstrumentationBase{instrumentationV2_V3;instrumentationV4_V5;initialized=false;constructor(a={}){
    const c={...o,...a};
    super(t.PACKAGE_NAME,t.PACKAGE_VERSION,c);
    this.instrumentationV2_V3=new n.RedisInstrumentationV2_V3(this.getConfig());
    this.instrumentationV4_V5=new r.RedisInstrumentationV4_V5(this.getConfig());
    this.initialized=true;
  }setConfig(a={}){
    const c={...o,...a};
    super.setConfig(c);

    if (this.initialized) {
      this.instrumentationV2_V3.setConfig(c);
      this.instrumentationV4_V5.setConfig(c);
    }
  }init(){}getModuleDefinitions(){return[...this.instrumentationV2_V3.getModuleDefinitions(),...this.instrumentationV4_V5.getModuleDefinitions()]}setTracerProvider(a){
    super.setTracerProvider(a);

    if (this.initialized) {
      this.instrumentationV2_V3.setTracerProvider(a);
      this.instrumentationV4_V5.setTracerProvider(a);
    }
  }enable(){
    super.enable();

    if (this.initialized) {
      this.instrumentationV2_V3.enable();
      this.instrumentationV4_V5.enable();
    }
  }disable(){
    super.disable();

    if (this.initialized) {
      this.instrumentationV2_V3.disable();
      this.instrumentationV4_V5.disable();
    }
  }}
  Oa.RedisInstrumentation=s;
  return Oa;
}let BN;function vW(){
  if (!BN) {
    BN=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.RedisInstrumentation=void 0;
      const t=MW();Object.defineProperty(e,"RedisInstrumentation",{enumerable:true,get() {return t.RedisInstrumentation}})
    })(ef);
  }

  return ef;
}const LW=vW();
const wW=["get","set","setex"];
const lv=["get","mget"];
const DW=["set","setex"];
function wu(e,t){return e.includes(t.toLowerCase())}function dv(e){return wu(lv,e)?"cache.get":wu(DW,e)?"cache.put":void 0}function UW(e,t){return t.some(n => e.startsWith(n));}function kW(e,t){try{
  if (t.length===0) {
    return;
  }

  const n=o => typeof o=="string"||typeof o=="number"||Buffer.isBuffer(o)?[o.toString()]:Array.isArray(o)?HN(o.map(s => n(s))):["<unknown>"];

  const r=t[0];
  return wu(wW,e)&&r!=null?n(r):HN(t.map(o => n(o)));
}catch{return}}function GW(e,t,n){if (!dv(e)) {
  return false;
}for (const r of t) {
  if (UW(r,n)) {
    return true;
  }
}return false;}function VW(e){const t=n=>{try{return Buffer.isBuffer(n)?n.byteLength:typeof n=="string"?n.length:typeof n=="number"?n.toString().length:n==null?0:JSON.stringify(n).length}catch{return}};return Array.isArray(e)?e.reduce((n,r)=>{const o=t(r);return typeof o=="number"?n!==void 0?n+o:o:n},0):t(e)}function HN(e){
  const t=[];
  const n=r=>{r.forEach(o=>{
    if (Array.isArray(o)) {
      n(o);
    } else {
      t.push(o);
    }
  })};
  n(e);
  return t;
}const Pl="Redis";let ja={};

const fv=(e,t,n,r)=>{
  e.setAttribute(Ge,"auto.db.otel.redis");
  const o=kW(t,n);
  const s=dv(t);
  if (!o||!s||!ja.cachePrefixes||!GW(t,o,ja.cachePrefixes)) {
    return;
  }
  const i=Re(e).data["net.peer.name"];
  const a=Re(e).data["net.peer.port"];

  if (a&&i) {
    e.setAttributes({"network.peer.address":i,"network.peer.port":a});
  }

  const c=VW(r);

  if (c) {
    e.setAttribute(xk,c);
  }

  if (wu(lv,t)&&c!==void 0) {
    e.setAttribute(Gk,c>0);
  }

  e.setAttributes({[Ee]:s,[Vk]:o});
  const l=o.join(", ");e.updateName(ja.maxCacheKeyLength?Eu(l,ja.maxCacheKeyLength):l)
};

const xW=Ne(`${Pl}.IORedis`,() => new OW.IORedisInstrumentation({responseHook:fv}));

const $W=Ne(`${Pl}.Redis`,() => new LW.RedisInstrumentation({responseHook:fv}));

const BW=Object.assign(()=>{
  xW();
  $W();
},{id:Pl});

const HW=((e={}) => ({
  name:Pl,

  setupOnce(){
    ja=e;
    BW();
  }
}));

const FW=HW;
const tf={};
const Pa={};
const Ma={};
let FN;
function YW(){
  if (!FN) {
    FN=1;
    Object.defineProperty(Ma,"__esModule",{value:true});
    Ma.EVENT_LISTENERS_SET=void 0;
    Ma.EVENT_LISTENERS_SET=Symbol("opentelemetry.instrumentation.pg.eventListenersSet");
  }

  return Ma;
}
const me={};
const nf={};
let YN;
function _v(){
  if (!YN) {
    YN=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.AttributeNames=void 0;

      (t => {
        t.PG_VALUES="db.postgresql.values";
        t.PG_PLAN="db.postgresql.plan";
        t.IDLE_TIMEOUT_MILLIS="db.postgresql.idle.timeout.millis";
        t.MAX_CLIENT="db.postgresql.max.client";
      })(e.AttributeNames||(e.AttributeNames={}));
    })(nf);
  }

  return nf;
}
const Me={};
let jN;
function pv(){
  if (!jN) {
    jN=1;
    Object.defineProperty(Me,"__esModule",{value:true});
    Me.METRIC_DB_CLIENT_CONNECTION_PENDING_REQUESTS=Me.METRIC_DB_CLIENT_CONNECTION_COUNT=Me.DB_SYSTEM_VALUE_POSTGRESQL=Me.DB_CLIENT_CONNECTION_STATE_VALUE_USED=Me.DB_CLIENT_CONNECTION_STATE_VALUE_IDLE=Me.ATTR_NET_PEER_PORT=Me.ATTR_NET_PEER_NAME=Me.ATTR_DB_USER=Me.ATTR_DB_SYSTEM=Me.ATTR_DB_STATEMENT=Me.ATTR_DB_NAME=Me.ATTR_DB_CONNECTION_STRING=Me.ATTR_DB_CLIENT_CONNECTION_STATE=Me.ATTR_DB_CLIENT_CONNECTION_POOL_NAME=void 0;
    Me.ATTR_DB_CLIENT_CONNECTION_POOL_NAME="db.client.connection.pool.name";
    Me.ATTR_DB_CLIENT_CONNECTION_STATE="db.client.connection.state";
    Me.ATTR_DB_CONNECTION_STRING="db.connection_string";
    Me.ATTR_DB_NAME="db.name";
    Me.ATTR_DB_STATEMENT="db.statement";
    Me.ATTR_DB_SYSTEM="db.system";
    Me.ATTR_DB_USER="db.user";
    Me.ATTR_NET_PEER_NAME="net.peer.name";
    Me.ATTR_NET_PEER_PORT="net.peer.port";
    Me.DB_CLIENT_CONNECTION_STATE_VALUE_IDLE="idle";
    Me.DB_CLIENT_CONNECTION_STATE_VALUE_USED="used";
    Me.DB_SYSTEM_VALUE_POSTGRESQL="postgresql";
    Me.METRIC_DB_CLIENT_CONNECTION_COUNT="db.client.connection.count";
    Me.METRIC_DB_CLIENT_CONNECTION_PENDING_REQUESTS="db.client.connection.pending_requests";
  }

  return Me;
}
const rf={};
let qN;
function Ev(){
  if (!qN) {
    qN=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.SpanNames=void 0;

      (t => {
        t.QUERY_PREFIX="pg.query";
        t.CONNECT="pg.connect";
        t.POOL_CONNECT="pg-pool.connect";
      })(e.SpanNames||(e.SpanNames={}));
    })(rf);
  }

  return rf;
}let WN;function jW(...args) {
  if (WN) {
    return me;
  }
  WN=1;
  Object.defineProperty(me,"__esModule",{value:true});
  me.sanitizedErrorMessage = void 0;
  me.isObjectWithTextString = void 0;
  me.getErrorMessage = void 0;
  me.patchClientConnectCallback = void 0;
  me.patchCallbackPGPool = void 0;
  me.updateCounter = void 0;
  me.getPoolName = void 0;
  me.patchCallback = void 0;
  me.handleExecutionResult = void 0;
  me.handleConfigQuery = void 0;
  me.shouldSkipInstrumentation = void 0;
  me.getSemanticAttributesFromPoolConnection = void 0;
  me.getSemanticAttributesFromConnection = void 0;
  me.getConnectionString = void 0;
  me.parseAndMaskConnectionString = void 0;
  me.parseNormalizedOperationName = void 0;
  me.getQuerySpanName = void 0;
  const e=Pe();
  const t=_v();
  const n=pt();
  const r=pv();
  const o=Le;
  const s=Ev();
  function i(b,L){if (!L) {
    return s.SpanNames.QUERY_PREFIX;
  }const U=typeof L.name=="string"&&L.name?L.name:a(L.text);return`${s.SpanNames.QUERY_PREFIX}:${U}${b?` ${b}`:""}`}me.getQuerySpanName=i;function a(b){
    const L=b.indexOf(" ");let U=L===-1?b:b.slice(0,L);
    U=U.toUpperCase();
    return U.endsWith(";")?U.slice(0,-1):U;
  }me.parseNormalizedOperationName=a;function c(b){try{
    const L=new URL(b);
    L.username="";
    L.password="";
    return L.toString();
  }catch{return"postgresql://localhost:5432/"}}me.parseAndMaskConnectionString=c;function l(b){
    if ("connectionString"in b&&b.connectionString) {
      return c(b.connectionString);
    }
    const L=b.host||"localhost";
    const U=b.port||5432;
    const q=b.database||"";
    return`postgresql://${L}:${U}/${q}`
  }me.getConnectionString=l;function f(b){if (Number.isInteger(b)) {
    return b
  }}function d(b,L){
  let U={};

  if (L&o.SemconvStability.OLD) {
    (U = {...U,[r.ATTR_DB_SYSTEM]:r.DB_SYSTEM_VALUE_POSTGRESQL,[r.ATTR_DB_NAME]:b.database,[r.ATTR_DB_CONNECTION_STRING]:l(b),[r.ATTR_DB_USER]:b.user,[r.ATTR_NET_PEER_NAME]:b.host,[r.ATTR_NET_PEER_PORT]:f(b.port)});
  }

  if (L&o.SemconvStability.STABLE) {
    (U = {...U,[n.ATTR_DB_SYSTEM_NAME]:n.DB_SYSTEM_NAME_VALUE_POSTGRESQL,[n.ATTR_DB_NAMESPACE]:b.namespace,[n.ATTR_SERVER_ADDRESS]:b.host,[n.ATTR_SERVER_PORT]:f(b.port)});
  }

  return U;
}me.getSemanticAttributesFromConnection=d;function u(b,L){
  let U;try{U=b.connectionString?new URL(b.connectionString):void 0}catch{U=void 0}let q={[t.AttributeNames.IDLE_TIMEOUT_MILLIS]:b.idleTimeoutMillis,[t.AttributeNames.MAX_CLIENT]:b.maxClient};

  if (L&o.SemconvStability.OLD) {
    (q = {...q,[r.ATTR_DB_SYSTEM]:r.DB_SYSTEM_VALUE_POSTGRESQL,[r.ATTR_DB_NAME]:U?.pathname.slice(1)??b.database,[r.ATTR_DB_CONNECTION_STRING]:l(b),[r.ATTR_NET_PEER_NAME]:U?.hostname??b.host,[r.ATTR_NET_PEER_PORT]:Number(U?.port)||f(b.port),[r.ATTR_DB_USER]:U?.username??b.user});
  }

  if (L&o.SemconvStability.STABLE) {
    (q = {...q,[n.ATTR_DB_SYSTEM_NAME]:n.DB_SYSTEM_NAME_VALUE_POSTGRESQL,[n.ATTR_DB_NAMESPACE]:b.namespace,[n.ATTR_SERVER_ADDRESS]:U?.hostname??b.host,[n.ATTR_SERVER_PORT]:Number(U?.port)||f(b.port)});
  }

  return q;
}me.getSemanticAttributesFromPoolConnection=u;function _(b){return b.requireParentSpan===true&&e.trace.getSpan(e.context.active())===void 0;}me.shouldSkipInstrumentation=_;function p(b,L,U,q){
  const {connectionParameters}=this;
  const $=connectionParameters.database;
  const B=i($,q);
  const F=b.startSpan(B,{kind:e.SpanKind.CLIENT,attributes:d(connectionParameters,U)});
  if (!q) {
    return F;
  }

  if (q.text) {
    U&o.SemconvStability.OLD&&F.setAttribute(r.ATTR_DB_STATEMENT,q.text);
    U&o.SemconvStability.STABLE&&F.setAttribute(n.ATTR_DB_QUERY_TEXT,q.text);
  }

  if (L.enhancedDatabaseReporting&&Array.isArray(q.values)) {
    try{const D=q.values.map(k => k==null?"null":k instanceof Buffer?k.toString():typeof k=="object"?typeof k.toPostgres=="function"?k.toPostgres():JSON.stringify(k):k.toString());F.setAttribute(t.AttributeNames.PG_VALUES,D)}catch(D){e.diag.error("failed to stringify ",q.values,D)}
  }

  if (typeof q.name=="string") {
    F.setAttribute(t.AttributeNames.PG_PLAN,q.name);
  }

  return F;
}me.handleConfigQuery=p;function E(b,L,U){
  if (typeof b.responseHook=="function") {
    (0,o.safeExecuteInTheMiddle)(()=>{b.responseHook(L,{data:U})},q=>{
      if (q) {
        e.diag.error("Error running response hook",q);
      }
    },true);
  }
}me.handleExecutionResult=E;function h(b,L,U,q,H){return function(B,F){
  if (B) {
    Object.prototype.hasOwnProperty.call(B,"code")&&(q[n.ATTR_ERROR_TYPE]=B.code);
    B instanceof Error&&L.recordException(I(B));
    L.setStatus({code:e.SpanStatusCode.ERROR,message:B.message});
  } else {
    E(b,L,F);
  }

  H();
  L.end();
  U.call(this,B,F);
};}me.patchCallback=h;function T(b){
    let L="";
    L+=`${b?.host?`${b.host}`:"unknown_host"}:`;
    L+=`${b?.port?`${b.port}`:"unknown_port"}/`;
    L+=b?.database?`${b.database}`:"unknown_database";
    return L.trim();
  }me.getPoolName=T;function m(b,L,U,q,H){
    const $=L.totalCount;
    const B=L.waitingCount;
    const F=L.idleCount;
    const D=$-F;
    U.add(D-H.used,{[r.ATTR_DB_CLIENT_CONNECTION_STATE]:r.DB_CLIENT_CONNECTION_STATE_VALUE_USED,[r.ATTR_DB_CLIENT_CONNECTION_POOL_NAME]:b});
    U.add(F-H.idle,{[r.ATTR_DB_CLIENT_CONNECTION_STATE]:r.DB_CLIENT_CONNECTION_STATE_VALUE_IDLE,[r.ATTR_DB_CLIENT_CONNECTION_POOL_NAME]:b});
    q.add(B-H.pending,{[r.ATTR_DB_CLIENT_CONNECTION_POOL_NAME]:b});
    return {used:D,idle:F,pending:B};
  }me.updateCounter=m;function A(b,L){return function(q,H,$){
  if (q) {
    q instanceof Error&&b.recordException(I(q));
    b.setStatus({code:e.SpanStatusCode.ERROR,message:q.message});
  }

  b.end();
  L.call(this,q,H,$);
};}me.patchCallbackPGPool=A;function g(b,L){return function(q){
  if (q) {
    q instanceof Error&&b.recordException(I(q));
    b.setStatus({code:e.SpanStatusCode.ERROR,message:q.message});
  }

  b.end();
  L.apply(this,args);
};}me.patchClientConnectCallback=g;function R(b){return typeof b=="object"&&b!==null&&"message"in b?String(b.message):void 0}me.getErrorMessage=R;function O(b){return typeof b=="object"&&typeof b?.text=="string"}me.isObjectWithTextString=O;function I(b){
    const L=b?.name??"PostgreSQLError";
    const U=b?.code??"UNKNOWN";
    return`PostgreSQL error of type '${L}' occurred (code: ${U})`
  }
  me.sanitizedErrorMessage=I;
  return me;
}
const Gr={};
let KN;
function qW(){
  if (!KN) {
    KN=1;
    Object.defineProperty(Gr,"__esModule",{value:true});
    Gr.PACKAGE_NAME=Gr.PACKAGE_VERSION=void 0;
    Gr.PACKAGE_VERSION="0.61.0";
    Gr.PACKAGE_NAME="@opentelemetry/instrumentation-pg";
  }

  return Gr;
}let zN;function WW(){
  if (zN) {
    return Pa;
  }
  zN=1;
  Object.defineProperty(Pa,"__esModule",{value:true});
  Pa.PgInstrumentation=void 0;
  const e=Le;
  const t=Pe();
  const n=YW();
  const r=jW();
  const o=cv();
  const s=qW();
  const i=Ev();
  const a=dn;
  const c=pt();
  const l=pv();
  function f(_){return _[Symbol.toStringTag]==="Module"?_.default:_}class d extends e.InstrumentationBase{_connectionsCounter={used:0,idle:0,pending:0};_semconvStability;constructor(p={}){
    super(s.PACKAGE_NAME,s.PACKAGE_VERSION,p);
    this._semconvStability=(0,e.semconvStabilityFromStr)("database",process.env.OTEL_SEMCONV_STABILITY_OPT_IN);
  }_updateMetricInstruments(){
    this._operationDuration=this.meter.createHistogram(c.METRIC_DB_CLIENT_OPERATION_DURATION,{description:"Duration of database client operations.",unit:"s",valueType:t.ValueType.DOUBLE,advice:{explicitBucketBoundaries:[0.001/* .001 */,0.005/* .005 */,0.01/* .01 */,0.05/* .05 */,0.1/* .1 */,0.5/* .5 */,1,5,10]}});
    this._connectionsCounter={idle:0,pending:0,used:0};
    this._connectionsCount=this.meter.createUpDownCounter(l.METRIC_DB_CLIENT_CONNECTION_COUNT,{description:"The number of connections that are currently in state described by the state attribute.",unit:"{connection}"});
    this._connectionPendingRequests=this.meter.createUpDownCounter(l.METRIC_DB_CLIENT_CONNECTION_PENDING_REQUESTS,{description:"The number of current pending requests for an open connection.",unit:"{connection}"});
  }init(){
    const p=[">=8.0.3 <9"];
    const E=[">=2.0.0 <4"];
    const h=new e.InstrumentationNodeModuleFile("pg/lib/native/client.js",p,this._patchPgClient.bind(this),this._unpatchPgClient.bind(this));
    const T=new e.InstrumentationNodeModuleFile("pg/lib/client.js",p,this._patchPgClient.bind(this),this._unpatchPgClient.bind(this));

    const m=new e.InstrumentationNodeModuleDefinition("pg",p,g=>{
      const R=f(g);
      this._patchPgClient(R.Client);
      return g;
    },g=>{
      const R=f(g);
      this._unpatchPgClient(R.Client);
      return g;
    },[T,h]);

    const A=new e.InstrumentationNodeModuleDefinition("pg-pool",E,g=>{
      const R=f(g);

      if ((0,e.isWrapped)(R.prototype.connect)) {
        this._unwrap(R.prototype,"connect");
      }

      this._wrap(R.prototype,"connect",this._getPoolConnectPatch());
      return R;
    },g=>{
      const R=f(g);

      if ((0,e.isWrapped)(R.prototype.connect)) {
        this._unwrap(R.prototype,"connect");
      }
    });

    return[m,A]
  }_patchPgClient(p){
  if (!p) {
    return;
  }const E=f(p);

  if ((0,e.isWrapped)(E.prototype.query)) {
    this._unwrap(E.prototype,"query");
  }

  if ((0,e.isWrapped)(E.prototype.connect)) {
    this._unwrap(E.prototype,"connect");
  }

  this._wrap(E.prototype,"query",this._getClientQueryPatch());
  this._wrap(E.prototype,"connect",this._getClientConnectPatch());
  return p;
}_unpatchPgClient(p){
  const E=f(p);

  if ((0,e.isWrapped)(E.prototype.query)) {
    this._unwrap(E.prototype,"query");
  }

  if ((0,e.isWrapped)(E.prototype.connect)) {
    this._unwrap(E.prototype,"connect");
  }

  return p;
}_getClientConnectPatch(){const p=this;return E => (function(T) {if (r.shouldSkipInstrumentation(p.getConfig())) {
  return E.call(this,T);
}const m=p.tracer.startSpan(i.SpanNames.CONNECT,{kind:t.SpanKind.CLIENT,attributes:r.getSemanticAttributesFromConnection(this,p._semconvStability)});if(T){
  const g=t.trace.getSpan(t.context.active());
  T=r.patchClientConnectCallback(m,T);

  if (g) {
    (T = t.context.bind(t.context.active(),T));
  }
}const A=t.context.with(t.trace.setSpan(t.context.active(),m),() => E.call(this,T));return u(m,A)});}recordOperationDuration(p,E){
  const h={};
  const T=[c.ATTR_DB_NAMESPACE,c.ATTR_ERROR_TYPE,c.ATTR_SERVER_PORT,c.ATTR_SERVER_ADDRESS,c.ATTR_DB_OPERATION_NAME];

  if (this._semconvStability&e.SemconvStability.OLD) {
    T.push(l.ATTR_DB_SYSTEM);
  }

  if (this._semconvStability&e.SemconvStability.STABLE) {
    T.push(c.ATTR_DB_SYSTEM_NAME);
  }

  T.forEach(A=>{
    if (A in p) {
      (h[A] = p[A]);
    }
  });
  const m=(0,a.hrTimeToMilliseconds)((0,a.hrTimeDuration)(E,(0,a.hrTime)()))/1000/* 1e3 */;this._operationDuration.record(m,h)
}_getClientQueryPatch(){const p=this;return E => {
    this._diag.debug("Patching pg.Client.prototype.query");

    return function(...T){
      if (r.shouldSkipInstrumentation(p.getConfig())) {
        return E.apply(this,T);
      }
      const m=(0,a.hrTime)();
      const A=T[0];
      const g=typeof A=="string";
      const R=r.isObjectWithTextString(A);
      const O=g?{text:A,values:Array.isArray(T[1])?T[1]:void 0}:R?A:void 0;
      const I={[l.ATTR_DB_SYSTEM]:l.DB_SYSTEM_VALUE_POSTGRESQL,[c.ATTR_DB_NAMESPACE]:this.database,[c.ATTR_SERVER_PORT]:this.connectionParameters.port,[c.ATTR_SERVER_ADDRESS]:this.connectionParameters.host};

      if (O?.text) {
        (I[c.ATTR_DB_OPERATION_NAME] = r.parseNormalizedOperationName(O?.text));
      }

      const b=()=>{p.recordOperationDuration(I,m)};
      const L=p.getConfig();
      const U=r.handleConfigQuery.call(this,p.tracer,L,p._semconvStability,O);

      if (L.addSqlCommenterCommentToQueries) {
        if (g) {
          T[0]=(0,o.addSqlCommenterComment)(U,A);
        } else if (R&&!("name"in A)) {
          (T[0] = {...A,text:(0,o.addSqlCommenterComment)(U,A.text)});
        }
      }

      if (T.length>0) {const $=t.trace.getSpan(t.context.active());if (typeof T[T.length-1]=="function") {
        T[T.length-1]=r.patchCallback(L,U,T[T.length-1],I,b);

        if ($) {
          (T[T.length-1] = t.context.bind(t.context.active(),T[T.length-1]));
        }
      } else if(typeof O?.callback=="function"){
        let B=r.patchCallback(p.getConfig(),U,O.callback,I,b);

        if ($) {
          (B = t.context.bind(t.context.active(),B));
        }

        T[0].callback=B;
      }}

      const{requestHook}=L;

      if (typeof requestHook=="function"&&O) {
        (0,e.safeExecuteInTheMiddle)(()=>{const{database,host,port,user}=this.connectionParameters;requestHook(U,{connection:{database:database,host:host,port:port,user:user},query:{text:O.text,values:O.values,name:O.name}})},$=>{
          if ($) {
            p._diag.error("Error running query hook",$);
          }
        },true);
      }

      let H;try{H=E.apply(this,T)}catch($){
        if ($ instanceof Error) {
          U.recordException(r.sanitizedErrorMessage($));
        }

        U.setStatus({code:t.SpanStatusCode.ERROR,message:r.getErrorMessage($)});
        U.end();
        throw $;
      }return H instanceof Promise?H.then($ => new Promise(B=>{
        r.handleExecutionResult(p.getConfig(),U,$);
        b();
        U.end();
        B($);
      })).catch($ => new Promise((B,F)=>{
        if ($ instanceof Error) {
          U.recordException(r.sanitizedErrorMessage($));
        }

        U.setStatus({code:t.SpanStatusCode.ERROR,message:$.message});
        b();
        U.end();
        F($);
      })):H;
    };
  };}_setPoolConnectEventListeners(p){
    if (p[n.EVENT_LISTENERS_SET]) {
      return;
    }const E=r.getPoolName(p.options);
    p.on("connect",()=>{this._connectionsCounter=r.updateCounter(E,p,this._connectionsCount,this._connectionPendingRequests,this._connectionsCounter)});
    p.on("acquire",()=>{this._connectionsCounter=r.updateCounter(E,p,this._connectionsCount,this._connectionPendingRequests,this._connectionsCounter)});
    p.on("remove",()=>{this._connectionsCounter=r.updateCounter(E,p,this._connectionsCount,this._connectionPendingRequests,this._connectionsCounter)});
    p.on("release",()=>{this._connectionsCounter=r.updateCounter(E,p,this._connectionsCount,this._connectionPendingRequests,this._connectionsCounter)});
    p[n.EVENT_LISTENERS_SET]=true;
  }_getPoolConnectPatch(){const p=this;return E => (function(T) {
  if (r.shouldSkipInstrumentation(p.getConfig())) {
    return E.call(this,T);
  }const m=p.tracer.startSpan(i.SpanNames.POOL_CONNECT,{kind:t.SpanKind.CLIENT,attributes:r.getSemanticAttributesFromPoolConnection(this.options,p._semconvStability)});
  p._setPoolConnectEventListeners(this);

  if (T) {
    const g=t.trace.getSpan(t.context.active());
    T=r.patchCallbackPGPool(m,T);

    if (g) {
      (T = t.context.bind(t.context.active(),T));
    }
  }

  const A=t.context.with(t.trace.setSpan(t.context.active(),m),() => E.call(this,T));return u(m,A)
});}}Pa.PgInstrumentation=d;function u(_,p){if (!(p instanceof Promise)) {
    return p;
  }const E=p;return t.context.bind(t.context.active(),E.then(h => {
    _.end();
    return h;
  }).catch(h => {
  if (h instanceof Error) {
    _.recordException(r.sanitizedErrorMessage(h));
  }

  _.setStatus({code:t.SpanStatusCode.ERROR,message:r.getErrorMessage(h)});
  _.end();
  return Promise.reject(h);
}));}return Pa
}let ZN;function KW(){
  if (!ZN) {
    ZN=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.AttributeNames = void 0;
      e.PgInstrumentation = void 0;
      const t=WW();Object.defineProperty(e,"PgInstrumentation",{enumerable:true,get() {return t.PgInstrumentation}});const n=_v();Object.defineProperty(e,"AttributeNames",{enumerable:true,get() {return n.AttributeNames}})
    })(tf);
  }

  return tf;
}const zW=KW();
const hv="Postgres";

const ZW=Ne(hv,() => new zW.PgInstrumentation({requireParentSpan:true,requestHook(e){yt(e,"auto.db.otel.postgres")}}));

const XW=(() => ({
  name:hv,
  setupOnce(){ZW()}
}));

const QW=XW;
const rh="PostgresJs";
const XN=[">=3.0.0 <4"];

const JW=Ne(rh,e => new eK({requireParentSpan:e?.requireParentSpan??true,requestHook:e?.requestHook}));

class eK extends Ot{constructor(t){super("sentry-postgres-js",Ze,t)}init(){
  const t=new ft("postgres",XN);

  ["src","cf/src","cjs/src"].forEach(n=>{
    t.files.push(new Hn(`postgres/${n}/connection.js`,["*"],this._patchConnection.bind(this),this._unwrap.bind(this)));
    t.files.push(new Hn(`postgres/${n}/query.js`,XN,this._patchQuery.bind(this),this._unwrap.bind(this)));
  });

  return [t];
}_shouldCreateSpans(){const t=this.getConfig();return C.trace.getSpan(C.context.active())!==void 0||!t.requireParentSpan}_patchReject(t,n){return new Proxy(t,{apply:(r,o,s)=>{
  n.setStatus({code:Ae,message:s?.[0]?.message||"internal_error"});const i=Reflect.apply(r,o,s);
  n.setAttribute(Q.ATTR_DB_RESPONSE_STATUS_CODE,s?.[0]?.code||"Unknown error");
  n.setAttribute(Q.ATTR_ERROR_TYPE,s?.[0]?.name||"Unknown error");
  n.end();
  return i;
}});}_patchResolve(t,n){return new Proxy(t,{apply:(r,o,s)=>{
  const i=Reflect.apply(r,o,s);
  const a=s?.[0]?.command;

  if (a) {
    n.setAttribute(Q.ATTR_DB_OPERATION_NAME,a);
  }

  n.end();
  return i;
}});}_patchQuery(t){
  t.Query.prototype.handle=new Proxy(t.Query.prototype.handle,{apply:async(n,r,o)=>{if (!this._shouldCreateSpans()) {
    return Reflect.apply(n,r,o);
  }const s=this._sanitizeSqlQuery(r.strings?.[0]);return xn({name:s||"postgresjs.query",op:"db"},i=>{
    const c=Ke().getScopeData().contexts.postgresjsConnection;yt(i,"auto.db.otel.postgres");const{requestHook}=this.getConfig();

    if (requestHook) {
      tr(() => requestHook(i,s,c),_=>{
        if (_) {
          x.error(`Error in requestHook for ${rh} integration:`,_);
        }
      });
    }

    const f=c?.ATTR_DB_NAMESPACE||"<unknown database>";
    const d=c?.ATTR_SERVER_ADDRESS||"<unknown host>";
    const u=c?.ATTR_SERVER_PORT||"<unknown port>";
    i.setAttribute(Q.ATTR_DB_SYSTEM_NAME,"postgres");
    i.setAttribute(Q.ATTR_DB_NAMESPACE,f);
    i.setAttribute(Q.ATTR_SERVER_ADDRESS,d);
    i.setAttribute(Q.ATTR_SERVER_PORT,u);
    i.setAttribute(Q.ATTR_DB_QUERY_TEXT,s);
    r.resolve=this._patchResolve(r.resolve,i);
    r.reject=this._patchReject(r.reject,i);
    try{return Reflect.apply(n,r,o)}catch(_){
      i.setStatus({code:Ae});
      i.end();
      throw _;
    }
  });}});

  return t;
}_patchConnection(t){return new Proxy(t,{apply:(n,r,o)=>{
  const s=o[0]?.database||"<unknown database>";
  const i=o[0]?.host?.[0]||"<unknown host>";
  const a=o[0]?.port?.[0]||"<unknown port>";
  Ke().setContext("postgresjsConnection",{ATTR_DB_NAMESPACE:s,ATTR_SERVER_ADDRESS:i,ATTR_SERVER_PORT:a});
  return Reflect.apply(n,r,o);
}});}_sanitizeSqlQuery(t){return t?t.replace(/\s+/g," ").trim().substring(0,1024).replace(/--.*?(\r?\n|$)/g,"").replace(/\/\*[\s\S]*?\*\//g,"").replace(/;\s*$/,"").replace(/\b\d+\b/g,"?").replace(/\s+/g," ").replace(/\bIN\b\s*\(\s*\?(?:\s*,\s*\?)*\s*\)/g,"IN (?)"):"Unknown SQL Query";}}

const tK=(() => ({
  name:rh,
  setupOnce(){JW()}
}));

const nK=tK;
const rK=process.env.PRISMA_SHOW_ALL_TRACES==="true";
const oK="00-10-10-00";
function sK(e){switch(e){case "client":
  {
    return C.SpanKind.CLIENT;
  }case"internal":default:
  {
    return C.SpanKind.INTERNAL
  }}}const iK=class{tracerProvider;ignoreSpanTypes;constructor({tracerProvider,ignoreSpanTypes}){
  this.tracerProvider=tracerProvider;
  this.ignoreSpanTypes=ignoreSpanTypes;
}isEnabled(){return true;}getTraceParent(e){const t=C.trace.getSpanContext(e??C.context.active());return t?`00-${t.traceId}-${t.spanId}-0${t.traceFlags}`:oK}dispatchEngineSpans(e){
  const t=this.tracerProvider.getTracer("prisma");
  const n=new Map;

  const r=e.filter(o => o.parentId===null);

  for (const o of r) {
    Tv(t,o,e,n,this.ignoreSpanTypes)
  }
}getActiveContext(){return C.context.active()}runInChildSpan(e,t){
  if (typeof e=="string") {
    (e = {name:e});
  }

  if (e.internal&&!rK) {
    return t();
  }

  const n=this.tracerProvider.getTracer("prisma");
  const r=e.context??this.getActiveContext();
  const o=`prisma:client:${e.name}`;
  if (Sv(o,this.ignoreSpanTypes)) {
    return t();
  }if(e.active===false){const s=n.startSpan(o,e,r);return QN(s,t(s,r))}return n.startActiveSpan(o,e,s => QN(s,t(s,r)));
}};function Tv(e,t,n,r,o){if (Sv(t.name,o)) {
  return;
}const s={attributes:t.attributes,kind:sK(t.kind),startTime:t.startTime};e.startActiveSpan(t.name,s,i=>{
  r.set(t.id,i.spanContext().spanId);

  if (t.links) {
    i.addLinks(t.links.flatMap(c=>{const l=r.get(c);return l?{context:{spanId:l,traceId:i.spanContext().traceId,traceFlags:i.spanContext().traceFlags}}:[]}));
  }

  const a=n.filter(c => c.parentId===t.id);for (const c of a) {
      Tv(e,c,n,r,o);
    }i.end(t.endTime)
})}function QN(e,t){return aK(t)?t.then(n => {
  e.end();
  return n;
},n=>{
  e.end();
  throw n;
}):(e.end(),t);}function aK(e){return e!=null&&typeof e.then=="function"}function Sv(e,t){return t.some(n => typeof n=="string"?n===e:n.test(e));}
const mv={name:"@prisma/instrumentation",version:"6.19.0"};
const Dp=mv.version;
const cK=Dp.split(".")[0];
const JN="PRISMA_INSTRUMENTATION";
const of=`V${cK}_PRISMA_INSTRUMENTATION`;
const uK=mv.name;
const lK="@prisma/client";

const dK=class extends Ot{tracerProvider;constructor(e={}){super(uK,Dp,e)}setTracerProvider(e){this.tracerProvider=e}init(){return[new ft(lK,[Dp])]}enable(){
  const e=this._config;
  const t={helper:new iK({tracerProvider:this.tracerProvider??C.trace.getTracerProvider(),ignoreSpanTypes:e.ignoreSpanTypes??[]})};
  global[JN]=t;
  global[of]=t;
}disable(){
  delete global[JN];
  delete global[of];
}isEnabled(){return!!global[of]}};

const Av="Prisma";function fK(e){return!!e&&typeof e=="object"&&"dispatchEngineSpans"in e}function gv(){const e=globalThis.PRISMA_INSTRUMENTATION;return e&&typeof e=="object"&&"helper"in e?e.helper:void 0}class _K extends dK{constructor(){super()}enable(){
  super.enable();const t=gv();

  if (fK(t)) {
    (t.createEngineSpan = n=>{
      const r=C.trace.getTracer("prismaV5Compatibility");
      const o=r._idGenerator;
      if(!o){an(()=>{console.warn("[Sentry] Could not find _idGenerator on tracer, skipping Prisma v5 compatibility - some Prisma spans may be missing!")});return}try{n.spans.forEach(s=>{
        const i=pK(s.kind);
        const a=s.parent_span_id;
        const c=s.span_id;
        const l=s.trace_id;

        const f=s.links?.map(u => ({
          context:{traceId:u.trace_id,spanId:u.span_id,traceFlags:C.TraceFlags.SAMPLED}
        }));

        const d=C.trace.setSpanContext(C.context.active(),{traceId:l,spanId:a,traceFlags:C.TraceFlags.SAMPLED});
        C.context.with(d,()=>{
          const u={generateTraceId:() => l,generateSpanId:() => c};
          r._idGenerator=u;
          r.startSpan(s.name,{kind:i,links:f,startTime:s.start_time,attributes:s.attributes}).end(s.end_time);
          r._idGenerator=o;
        })
      })}finally{r._idGenerator=o}
    });
  }
}}function pK(e){switch(e){case "client":
  {
    return C.SpanKind.CLIENT;
  }case"internal":default:
  {
    return C.SpanKind.INTERNAL
  }}}

const EK=Ne(Av,e => new _K);

const hK=e => ({
  name:Av,
  setupOnce(){EK()},

  setup(t){
    if (gv()) {
      t.on("spanStart",n=>{
        const r=Re(n);

        if (r.description?.startsWith("prisma:")) {
          n.setAttribute(Ge,"auto.db.otel.prisma");
        }

        if (r.description==="prisma:engine:db_query"&&r.data["db.query.text"]) {
          n.updateName(r.data["db.query.text"]);
        }

        if (r.description==="prisma:engine:db_query"&&!r.data["db.system"]) {
          n.setAttribute("db.system","prisma");
        }
      });
    }
  }
});

const sf={};
const va={};
const Vr={};
let ey;
function TK(){
  if (!ey) {
    ey=1;
    Object.defineProperty(Vr,"__esModule",{value:true});
    Vr.PACKAGE_NAME=Vr.PACKAGE_VERSION=void 0;
    Vr.PACKAGE_VERSION="0.55.0";
    Vr.PACKAGE_NAME="@opentelemetry/instrumentation-hapi";
  }

  return Vr;
}
const tn={};
let ty;
function Rv(){
  if (!ty) {
    ty=1;
    Object.defineProperty(tn,"__esModule",{value:true});
    tn.HapiLifecycleMethodNames=tn.HapiLayerType=tn.handlerPatched=tn.HapiComponentName=void 0;
    tn.HapiComponentName="@hapi/hapi";
    tn.handlerPatched=Symbol("hapi-handler-patched");
    tn.HapiLayerType={ROUTER:"router",PLUGIN:"plugin",EXT:"server.ext"};
    tn.HapiLifecycleMethodNames=new Set(["onPreAuth","onCredentials","onPostAuth","onPreHandler","onPostHandler","onPreResponse","onRequest"]);
  }

  return tn;
}
const af={};
const La={};
let ny;
function SK(){
  if (!ny) {
    ny=1;
    Object.defineProperty(La,"__esModule",{value:true});
    La.ATTR_HTTP_METHOD=void 0;
    La.ATTR_HTTP_METHOD="http.method";
  }

  return La;
}
const cf={};
let ry;
function Nv(){
  if (!ry) {
    ry=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.AttributeNames=void 0;

      (t => {
        t.HAPI_TYPE="hapi.type";
        t.PLUGIN_NAME="hapi.plugin.name";
        t.EXT_TYPE="server.ext.type";
      })(e.AttributeNames||(e.AttributeNames={}));
    })(cf);
  }

  return cf;
}let oy;function mK(){
  if (!oy) {
    oy=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.getPluginFromInput = void 0;
      e.getExtMetadata = void 0;
      e.getRouteMetadata = void 0;
      e.isPatchableExtMethod = void 0;
      e.isDirectExtInput = void 0;
      e.isLifecycleExtEventObj = void 0;
      e.isLifecycleExtType = void 0;
      e.getPluginName = void 0;
      const t=pt();
      const n=SK();
      const r=Rv();
      const o=Nv();
      const s=Le;
      function i(p){return p.name?p.name:p.pkg.name}e.getPluginName=i;const a=p => typeof p=="string"&&r.HapiLifecycleMethodNames.has(p);e.isLifecycleExtType=a;const c=p=>{const E=p?.type;return E!==void 0&&(0,e.isLifecycleExtType)(E)};e.isLifecycleExtEventObj=c;const l=p => Array.isArray(p)&&p.length<=3&&(0,e.isLifecycleExtType)(p[0])&&typeof p[1]=="function";e.isDirectExtInput=l;const f=p => !Array.isArray(p);e.isPatchableExtMethod=f;const d=(p,E,h)=>{
      const T={[t.ATTR_HTTP_ROUTE]:p.path};

      if (E&s.SemconvStability.OLD) {
        (T[n.ATTR_HTTP_METHOD] = p.method);
      }

      if (E&s.SemconvStability.STABLE) {
        (T[t.ATTR_HTTP_REQUEST_METHOD] = p.method);
      }

      let m;

      if (h) {
        T[o.AttributeNames.HAPI_TYPE]=r.HapiLayerType.PLUGIN;
        T[o.AttributeNames.PLUGIN_NAME]=h;
        m=`${h}: route - ${p.path}`;
      } else {
        T[o.AttributeNames.HAPI_TYPE]=r.HapiLayerType.ROUTER;
        m=`route - ${p.path}`;
      }

      return {attributes:T,name:m};
    };e.getRouteMetadata=d;const u=(p, E) => E?{attributes:{[o.AttributeNames.EXT_TYPE]:p,[o.AttributeNames.HAPI_TYPE]:r.HapiLayerType.EXT,[o.AttributeNames.PLUGIN_NAME]:E},name:`${E}: ext - ${p}`}:{attributes:{[o.AttributeNames.EXT_TYPE]:p,[o.AttributeNames.HAPI_TYPE]:r.HapiLayerType.EXT},name:`ext - ${p}`};e.getExtMetadata=u;const _=p => "plugin"in p?"plugin"in p.plugin?p.plugin.plugin:p.plugin:p;e.getPluginFromInput=_
    })(af);
  }

  return af;
}let sy;function AK(){
  if (sy) {
    return va;
  }
  sy=1;
  Object.defineProperty(va,"__esModule",{value:true});
  va.HapiInstrumentation=void 0;
  const e=Pe();
  const t=dn;
  const n=Le;
  const r=TK();
  const o=Rv();
  const s=mK();
  class i extends n.InstrumentationBase{_semconvStability;constructor(c={}){
    super(r.PACKAGE_NAME,r.PACKAGE_VERSION,c);
    this._semconvStability=(0,n.semconvStabilityFromStr)("http",process.env.OTEL_SEMCONV_STABILITY_OPT_IN);
  }init(){return new n.InstrumentationNodeModuleDefinition(o.HapiComponentName,[">=17.0.0 <22"],c=>{
    const l=c[Symbol.toStringTag]==="Module"?c.default:c;

    if (!(0,n.isWrapped)(l.server)) {
      this._wrap(l,"server",this._getServerPatch.bind(this));
    }

    if (!(0,n.isWrapped)(l.Server)) {
      this._wrap(l,"Server",this._getServerPatch.bind(this));
    }

    return l;
  },c=>{const l=c[Symbol.toStringTag]==="Module"?c.default:c;this._massUnwrap([l],["server","Server"])});}_getServerPatch(c){
    const l=this;
    const f=this;
    return function(u){
      const _=c.apply(this,[u]);

      f._wrap(_,"route",p => l._getServerRoutePatch.bind(l)(p));

      f._wrap(_,"ext",p => l._getServerExtPatch.bind(l)(p));

      f._wrap(_,"register",l._getServerRegisterPatch.bind(l));
      return _;
    };
  }_getServerRegisterPatch(c){const l=this;return function(d,u){if (Array.isArray(d)) {
    for(const _ of d){const p=(0,s.getPluginFromInput)(_);l._wrapRegisterHandler(p)}
  } else
    {const _=(0,s.getPluginFromInput)(d);l._wrapRegisterHandler(_)}return c.apply(this,[d,u])};}_getServerExtPatch(c,l){const f=this;return function(...u){if(Array.isArray(u[0])){
    const _=u[0];

    _.forEach((E, p) => {
      if((0,s.isLifecycleExtType)(E.type)){
        const h=E;
        const T=f._wrapExtMethods(h.method,E.type,l);
        h.method=T;
        _[p]=h;
      }
    });

    return c.apply(this,u)
  }else if((0,s.isDirectExtInput)(u)){
    const _=u;
    const p=_[1];
    const E=f._wrapExtMethods(p,_[0],l);
    return c.apply(this,[_[0],E,_[2]])
  }else if((0,s.isLifecycleExtEventObj)(u[0])){
    const _=u[0];
    const p=f._wrapExtMethods(_.method,_.type,l);
    _.method=p;
    return c.call(this,_);
  }return c.apply(this,u)};}_getServerRoutePatch(c,l){const f=this;return function(d){if (Array.isArray(d)) {
    for(let u=0;u<d.length;u++){const _=f._wrapRouteHandler.call(f,d[u],l);d[u]=_}
  } else {
    d=f._wrapRouteHandler.call(f,d,l);
  }return c.apply(this,[d])};}_wrapRegisterHandler(c){
    const l=this;
    const f=(0,s.getPluginName)(c);
    const d=c.register;
    const u=this;

    const _=function(p,E){
      u._wrap(p,"route",h => l._getServerRoutePatch.bind(l)(h,f));

      u._wrap(p,"ext",h => l._getServerExtPatch.bind(l)(h,f));

      return d.call(this,p,E);
    };

    c.register=_
  }_wrapExtMethods(c,l,f){const d=this;if(c instanceof Array){for (let u=0; u<c.length; u++) {
    c[u]=d._wrapExtMethods(c[u],l);
  }return c}else if ((0,s.isPatchableExtMethod)(c)) {
    return c[o.handlerPatched]===true?c:(c[o.handlerPatched]=true,async function(..._){
      if (e.trace.getSpan(e.context.active())===void 0) {
        return await c.apply(this,_);
      }
      const p=(0,s.getExtMetadata)(l,f);
      const E=d.tracer.startSpan(p.name,{attributes:p.attributes});
      try{return await e.context.with(e.trace.setSpan(e.context.active(),E),c,void 0,..._)}catch(h){
        E.recordException(h);
        E.setStatus({code:e.SpanStatusCode.ERROR,message:h.message});
        throw h;
      }finally{E.end()}
    });
  }return c}_wrapRouteHandler(c,l){const f=this;if (c[o.handlerPatched]===true) {
    return c;
  }c[o.handlerPatched]=true;const d=u => (async function(..._) {
    if (e.trace.getSpan(e.context.active())===void 0) {
      return await u.call(this,..._);
    }const p=(0,t.getRPCMetadata)(e.context.active());

    if (p?.type===t.RPCType.HTTP) {
      (p.route = c.path);
    }

    const E=(0,s.getRouteMetadata)(c,f._semconvStability,l);
    const h=f.tracer.startSpan(E.name,{attributes:E.attributes});
    try{return await e.context.with(e.trace.setSpan(e.context.active(),h),() => u.call(this,..._));}catch(T){
      h.recordException(T);
      h.setStatus({code:e.SpanStatusCode.ERROR,message:T.message});
      throw T;
    }finally{h.end()}
  });if (typeof c.handler=="function") {
    c.handler=d(c.handler);
  } else if (typeof c.options=="function") {const u=c.options;c.options=_ => {
    const p=u(_);

    if (typeof p.handler=="function") {
      (p.handler = d(p.handler));
    }

    return p;
  }} else {
    if (typeof c.options?.handler=="function") {
      (c.options.handler = d(c.options.handler));
    }
  }return c}}
  va.HapiInstrumentation=i;
  return va;
}let iy;function gK(){
  if (!iy) {
    iy=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.AttributeNames = void 0;
      e.HapiInstrumentation = void 0;
      const t=AK();Object.defineProperty(e,"HapiInstrumentation",{enumerable:true,get() {return t.HapiInstrumentation}});const n=Nv();Object.defineProperty(e,"AttributeNames",{enumerable:true,get() {return n.AttributeNames}})
    })(sf);
  }

  return sf;
}const RK=gK();
const yv="Hapi";

const NK=Ne(yv,() => new RK.HapiInstrumentation);

const yK=(() => ({
  name:yv,
  setupOnce(){NK()}
}));

const OK=yK;
const bo={HONO_TYPE:"hono.type",HONO_NAME:"hono.name"};
const Hc={MIDDLEWARE:"middleware",REQUEST_HANDLER:"request_handler"};
const bK="@sentry/instrumentation-hono";
const CK="0.0.1";
class IK extends Ot{constructor(t={}){super(bK,CK,t)}init(){return [new ft("hono",[">=4.0.0 <5"],t => this._patch(t))];}_patch(t){const n=this;class r extends t.Hono{constructor(...s){
  super(...s);
  n._wrap(this,"get",n._patchHandler());
  n._wrap(this,"post",n._patchHandler());
  n._wrap(this,"put",n._patchHandler());
  n._wrap(this,"delete",n._patchHandler());
  n._wrap(this,"options",n._patchHandler());
  n._wrap(this,"patch",n._patchHandler());
  n._wrap(this,"all",n._patchHandler());
  n._wrap(this,"on",n._patchOnHandler());
  n._wrap(this,"use",n._patchMiddlewareHandler());
}}try{t.Hono=r}catch{return{...t,Hono:r}}return t}_patchHandler(){const t=this;return n => (function(...o) {if(typeof o[0]=="string"){const s=o[0];if (o.length===1) {
  return n.apply(this,[s]);
}const i=o.slice(1);return n.apply(this,[s,...i.map(a => t._wrapHandler(a))]);}return n.apply(this,o.map(s => t._wrapHandler(s)));});}_patchOnHandler(){const t=this;return n => (function(...o) {const s=o.slice(2);return n.apply(this,[...o.slice(0,2),...s.map(i => t._wrapHandler(i))]);});}_patchMiddlewareHandler(){const t=this;return n => (function(...o) {if(typeof o[0]=="string"){const s=o[0];if (o.length===1) {
  return n.apply(this,[s]);
}const i=o.slice(1);return n.apply(this,[s,...i.map(a => t._wrapHandler(a))]);}return n.apply(this,o.map(s => t._wrapHandler(s)));});}_wrapHandler(t){const n=this;return function(r,o){
  if (!n.isEnabled()) {
    return t.apply(this,[r,o]);
  }
  const s=r.req.path;
  const i=n.tracer.startSpan(s);
  return C.context.with(C.trace.setSpan(C.context.active(),i),() => n._safeExecute(()=>{const a=t.apply(this,[r,o]);if (nr(a)) {
    return a.then(c=>{
      const l=n._determineHandlerType(c);
      i.setAttributes({[bo.HONO_TYPE]:l,[bo.HONO_NAME]:l===Hc.REQUEST_HANDLER?s:t.name||"anonymous"});
      n.getConfig().responseHook?.(i);
      return c;
    });
  }{
    const c=n._determineHandlerType(a);
    i.setAttributes({[bo.HONO_TYPE]:c,[bo.HONO_NAME]:c===Hc.REQUEST_HANDLER?s:t.name||"anonymous"});
    n.getConfig().responseHook?.(i);
    return a;
  }},() => i.end(),a=>{
    n._handleError(i,a);
    i.end();
  }));
};}_safeExecute(t,n,r){try{
  const o=t();

  if (nr(o)) {
    o.then(() => n(),s => r(s));
  } else {
    n();
  }

  return o;
}catch(o){
  r(o);
  throw o;
}}_determineHandlerType(t){return t===void 0?Hc.MIDDLEWARE:Hc.REQUEST_HANDLER}_handleError(t,n){
  if (n instanceof Error) {
    t.setStatus({code:C.SpanStatusCode.ERROR,message:n.message});
    t.recordException(n);
  }
}}const Ov="Hono";function PK(e){
  const t=Re(e).data;
  const n=t[bo.HONO_TYPE];
  if (t[Ee]||!n) {
    return;
  }e.setAttributes({[Ge]:"auto.http.otel.hono",[Ee]:`${n}.hono`});const r=t[bo.HONO_NAME];

  if (typeof r=="string") {
    e.updateName(r);
  }

  if (je()===Xo())
    {
      if (io) {
        x.warn("Isolation scope is default isolation scope - skipping setting transactionName");
      }

      return
    }

  const o=t[Q.ATTR_HTTP_ROUTE];
  const s=t[Q.ATTR_HTTP_REQUEST_METHOD];

  if (typeof o=="string"&&typeof s=="string") {
    je().setTransactionName(`${s} ${o}`);
  }
}

const MK=Ne(Ov,() => new IK({responseHook:e=>{PK(e)}}));

const vK=(() => ({
  name:Ov,
  setupOnce(){MK()}
}));

const LK=vK;
const uf={};
const wa={};
const lf={};
let ay;
function oh(){
  if (!ay) {
    ay=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.KoaLayerType=void 0;

      (t => {
        t.ROUTER="router";
        t.MIDDLEWARE="middleware";
      })(e.KoaLayerType||(e.KoaLayerType={}));
    })(lf);
  }

  return lf;
}
const xr={};
let cy;
function wK(){
  if (!cy) {
    cy=1;
    Object.defineProperty(xr,"__esModule",{value:true});
    xr.PACKAGE_NAME=xr.PACKAGE_VERSION=void 0;
    xr.PACKAGE_VERSION="0.57.0";
    xr.PACKAGE_NAME="@opentelemetry/instrumentation-koa";
  }

  return xr;
}
const $r={};
const df={};
let uy;
function bv(){
  if (!uy) {
    uy=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.AttributeNames=void 0;

      (t => {
        t.KOA_TYPE="koa.type";
        t.KOA_NAME="koa.name";
      })(e.AttributeNames||(e.AttributeNames={}));
    })(df);
  }

  return df;
}let ly;function DK(){
  if (ly) {
    return $r;
  }
  ly=1;
  Object.defineProperty($r,"__esModule",{value:true});
  $r.isLayerIgnored = void 0;
  $r.getMiddlewareMetadata = void 0;
  const e=oh();
  const t=bv();
  const n=pt();

  const r=(s, i, a, c) => a?{attributes:{[t.AttributeNames.KOA_NAME]:c?.toString(),[t.AttributeNames.KOA_TYPE]:e.KoaLayerType.ROUTER,[n.ATTR_HTTP_ROUTE]:c?.toString()},name:s._matchedRouteName||`router - ${c}`}:{attributes:{[t.AttributeNames.KOA_NAME]:i.name??"middleware",[t.AttributeNames.KOA_TYPE]:e.KoaLayerType.MIDDLEWARE},name:`middleware - ${i.name}`};

  $r.getMiddlewareMetadata=r;const o=(s, i) => !!(Array.isArray(i?.ignoreLayersType)&&i?.ignoreLayersType?.includes(s));
  $r.isLayerIgnored=o;
  return $r;
}
const Da={};
let dy;
function UK(){
  if (!dy) {
    dy=1;
    Object.defineProperty(Da,"__esModule",{value:true});
    Da.kLayerPatched=void 0;
    Da.kLayerPatched=Symbol("koa-layer-patched");
  }

  return Da;
}let fy;function kK(){
  if (fy) {
    return wa;
  }
  fy=1;
  Object.defineProperty(wa,"__esModule",{value:true});
  wa.KoaInstrumentation=void 0;
  const e=Pe();
  const t=Le;
  const n=oh();
  const r=wK();
  const o=DK();
  const s=dn;
  const i=UK();
  class a extends t.InstrumentationBase{constructor(l={}){super(r.PACKAGE_NAME,r.PACKAGE_VERSION,l)}init(){return new t.InstrumentationNodeModuleDefinition("koa",[">=2.0.0 <4"],l=>{const f=l[Symbol.toStringTag]==="Module"?l.default:l;return f==null?f:((0,t.isWrapped)(f.prototype.use)&&this._unwrap(f.prototype,"use"),this._wrap(f.prototype,"use",this._getKoaUsePatch.bind(this)),l)},l=>{
    const f=l[Symbol.toStringTag]==="Module"?l.default:l;

    if ((0,t.isWrapped)(f.prototype.use)) {
      this._unwrap(f.prototype,"use");
    }
  });}_getKoaUsePatch(l){const f=this;return function(u){
    let _;

    if (u.router) {
      _=f._patchRouterDispatch(u);
    } else {
      _=f._patchLayer(u,false);
    }

    return l.apply(this,[_]);
  };}_patchRouterDispatch(l){e.diag.debug("Patching @koa/router dispatch");const d=l.router?.stack??[];for(const u of d){
    const _=u.path;
    const p=u.stack;

    p.forEach((h, E) => {
      p[E]=this._patchLayer(h,true,_)
    });
  }return l}_patchLayer(l,f,d){const u=f?n.KoaLayerType.ROUTER:n.KoaLayerType.MIDDLEWARE;return l[i.kLayerPatched]===true||(0,o.isLayerIgnored)(u,this.getConfig())?l:l.constructor.name==="GeneratorFunction"||l.constructor.name==="AsyncGeneratorFunction"?(e.diag.debug("ignoring generator-based Koa middleware layer"),l):(l[i.kLayerPatched]=true,e.diag.debug("patching Koa middleware layer"),async(_,p)=>{
    if (e.trace.getSpan(e.context.active())===void 0) {
      return l(_,p);
    }
    const h=(0,o.getMiddlewareMetadata)(_,l,f,d);
    const T=this.tracer.startSpan(h.name,{attributes:h.attributes});
    const m=(0,s.getRPCMetadata)(e.context.active());

    if (m?.type===s.RPCType.HTTP&&_._matchedRoute) {
      (m.route = _._matchedRoute.toString());
    }

    const{requestHook}=this.getConfig();

    if (requestHook) {
      (0,t.safeExecuteInTheMiddle)(() => requestHook(T,{context:_,middlewareLayer:l,layerType:u}),R=>{
        if (R) {
          e.diag.error("koa instrumentation: request hook failed",R);
        }
      },true);
    }

    const g=e.trace.setSpan(e.context.active(),T);return e.context.with(g,async()=>{try{return await l(_,p)}catch(R){
        T.recordException(R);
        throw R;
      }finally{T.end()}});
  });}}
  wa.KoaInstrumentation=a;
  return wa;
}let _y;function GK(){
  if (!_y) {
    _y=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.KoaLayerType = void 0;
      e.AttributeNames = void 0;
      e.KoaInstrumentation = void 0;
      const t=kK();Object.defineProperty(e,"KoaInstrumentation",{enumerable:true,get() {return t.KoaInstrumentation}});const n=bv();Object.defineProperty(e,"AttributeNames",{enumerable:true,get() {return n.AttributeNames}});const r=oh();Object.defineProperty(e,"KoaLayerType",{enumerable:true,get() {return r.KoaLayerType}})
    })(uf);
  }

  return uf;
}const VK=GK();
const Cv="Koa";

const xK=Ne(Cv,VK.KoaInstrumentation,(e={}) => ({
  ignoreLayersType:e.ignoreLayersType,

  requestHook(t,n){
    yt(t,"auto.http.otel.koa");
    const r=Re(t).data;
    const o=r["koa.type"];

    if (o) {
      t.setAttribute(Ee,`${o}.koa`);
    }

    const s=r["koa.name"];

    if (typeof s=="string") {
      t.updateName(s||"< unknown >");
    }

    if (je()===Xo())
      {
        if (io) {
          x.warn("Isolation scope is default isolation scope - skipping setting transactionName");
        }

        return
      }

    const i=r[Q.ATTR_HTTP_ROUTE];
    const a=n.context?.request?.method?.toUpperCase()||"GET";

    if (i) {
      je().setTransactionName(`${a} ${i}`);
    }
  }
}));

const $K=((e={}) => ({
  name:Cv,
  setupOnce(){xK(e)}
}));

const BK=$K;
const ff={};
const _f={};
const pf={};
let py;
function Iv(){
  if (!py) {
    py=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.ConnectNames = void 0;
      e.ConnectTypes = void 0;
      e.AttributeNames = void 0;

      (t => {
        t.CONNECT_TYPE="connect.type";
        t.CONNECT_NAME="connect.name";
      })(e.AttributeNames||(e.AttributeNames={}));

      (t => {
        t.MIDDLEWARE="middleware";
        t.REQUEST_HANDLER="request_handler";
      })(e.ConnectTypes||(e.ConnectTypes={}));

      (t => {
        t.MIDDLEWARE="middleware";
        t.REQUEST_HANDLER="request handler";
      })(e.ConnectNames||(e.ConnectNames={}));
    })(pf);
  }

  return pf;
}
const Br={};
let Ey;
function HK(){
  if (!Ey) {
    Ey=1;
    Object.defineProperty(Br,"__esModule",{value:true});
    Br.PACKAGE_NAME=Br.PACKAGE_VERSION=void 0;
    Br.PACKAGE_VERSION="0.52.0";
    Br.PACKAGE_NAME="@opentelemetry/instrumentation-connect";
  }

  return Br;
}
const vn={};
const Ua={};
let hy;
function FK(){
  if (!hy) {
    hy=1;
    Object.defineProperty(Ua,"__esModule",{value:true});
    Ua._LAYERS_STORE_PROPERTY=void 0;
    Ua._LAYERS_STORE_PROPERTY=Symbol("opentelemetry.instrumentation-connect.request-route-stack");
  }

  return Ua;
}let Ty;function YK(){
  if (Ty) {
    return vn;
  }
  Ty=1;
  Object.defineProperty(vn,"__esModule",{value:true});
  vn.generateRoute = void 0;
  vn.replaceCurrentStackRoute = void 0;
  vn.addNewStackLayer = void 0;
  const e=Pe();
  const t=FK();

  const n=s=>{
    if (Array.isArray(s[t._LAYERS_STORE_PROPERTY])===false) {
      Object.defineProperty(s,t._LAYERS_STORE_PROPERTY,{enumerable:false,value:[]});
    }

    s[t._LAYERS_STORE_PROPERTY].push("/");
    const i=s[t._LAYERS_STORE_PROPERTY].length;return ()=>{
      if (i===s[t._LAYERS_STORE_PROPERTY].length) {
        s[t._LAYERS_STORE_PROPERTY].pop();
      } else {
        e.diag.warn("Connect: Trying to pop the stack multiple time");
      }
    };
  };

  vn.addNewStackLayer=n;const r=(s,i)=>{
  if (i) {
    s[t._LAYERS_STORE_PROPERTY].splice(-1,1,i);
  }
};vn.replaceCurrentStackRoute=r;const o=s => s[t._LAYERS_STORE_PROPERTY].reduce((i, a) => i.replace(/\/+$/,"")+a);
  vn.generateRoute=o;
  return vn;
}let Sy;function jK(...args) {
  if (!Sy) {
    Sy=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.ConnectInstrumentation = void 0;
      e.ANONYMOUS_NAME = void 0;
      const t=Pe();
      const n=dn;
      const r=Iv();
      const o=HK();
      const s=Le;
      const i=pt();
      const a=YK();
      e.ANONYMOUS_NAME="anonymous";class c extends s.InstrumentationBase{constructor(f={}){super(o.PACKAGE_NAME,o.PACKAGE_VERSION,f)}init(){return [new s.InstrumentationNodeModuleDefinition("connect",[">=3.0.0 <4"],f => this._patchConstructor(f))];}_patchApp(f){
      if (!(0,s.isWrapped)(f.use)) {
        this._wrap(f,"use",this._patchUse.bind(this));
      }

      if (!(0,s.isWrapped)(f.handle)) {
        this._wrap(f,"handle",this._patchHandle.bind(this));
      }
    }_patchConstructor(f){const d=this;return function(...u){
        const _=f.apply(this,u);
        d._patchApp(_);
        return _;
      };}_patchNext(f,d){return function(_){
        const p=f.apply(this,[_]);
        d();
        return p;
      };}_startSpan(f,d){
      let u;
      let _;
      let p;

      if (f) {
        u=r.ConnectTypes.REQUEST_HANDLER;
        p=r.ConnectNames.REQUEST_HANDLER;
        _=f;
      } else {
        u=r.ConnectTypes.MIDDLEWARE;
        p=r.ConnectNames.MIDDLEWARE;
        _=d.name||e.ANONYMOUS_NAME;
      }

      const E=`${p} - ${_}`;
      const h={attributes:{[i.ATTR_HTTP_ROUTE]:f.length>0?f:"/",[r.AttributeNames.CONNECT_TYPE]:u,[r.AttributeNames.CONNECT_NAME]:_}};
      return this.tracer.startSpan(E,h)
    }_patchMiddleware(f,d){
        const u=this;
        const _=d.length===4;
        function p(){
          if (!u.isEnabled()) {
            return d.apply(this,args);
          }
          const [E,h,T]=_?[1,2,3]:[0,1,2];
          const m=args[E];
          const A=args[h];
          const g=args[T];
          (0,a.replaceCurrentStackRoute)(m,f);const R=(0,n.getRPCMetadata)(t.context.active());

          if (f&&R?.type===n.RPCType.HTTP) {
            (R.route = (0,a.generateRoute)(m));
          }

          let O="";

          if (f) {
            O=`request handler - ${f}`;
          } else {
            O=`middleware - ${d.name||e.ANONYMOUS_NAME}`;
          }

          const I=u._startSpan(f,d);u._diag.debug("start span",O);let b=false;function L(){
            if (b) {
              u._diag.debug(`span ${I.name} - already finished`);
            } else {
              b=true;
              u._diag.debug(`finishing span ${I.name}`);
              I.end();
            }

            A.removeListener("close",L);
          }
          A.addListener("close",L);
          args[T]=u._patchNext(g,L);
          return d.apply(this,args);
        }
        Object.defineProperty(p,"length",{value:d.length,writable:false,configurable:true});
        return p;
      }_patchUse(f){const d=this;return function(...u){
        const _=u[u.length-1];
        const p=u[u.length-2]||"";
        u[u.length-1]=d._patchMiddleware(p,_);
        return f.apply(this,u);
      };}_patchHandle(f){const d=this;return function(...args) {
      const [u,_]=[0,2];
      const p=args[u];
      const E=args[_];
      const h=(0,a.addNewStackLayer)(p);

      if (typeof E=="function") {
        (args[_] = d._patchOut(E,h));
      }

      return f.apply(this,args);
    };}_patchOut(f,d){return function(..._){
        d();
        return Reflect.apply(f,this,_);
      };}}e.ConnectInstrumentation=c
    })(_f);
  }

  return _f;
}let my;function qK(){
  if (!my) {
    my=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.ConnectTypes = void 0;
      e.ConnectNames = void 0;
      e.AttributeNames = void 0;
      e.ANONYMOUS_NAME = void 0;
      e.ConnectInstrumentation = void 0;
      const t=jK();
      Object.defineProperty(e,"ConnectInstrumentation",{enumerable:true,get() {return t.ConnectInstrumentation}});
      Object.defineProperty(e,"ANONYMOUS_NAME",{enumerable:true,get() {return t.ANONYMOUS_NAME}});
      const n=Iv();
      Object.defineProperty(e,"AttributeNames",{enumerable:true,get() {return n.AttributeNames}});
      Object.defineProperty(e,"ConnectNames",{enumerable:true,get() {return n.ConnectNames}});
      Object.defineProperty(e,"ConnectTypes",{enumerable:true,get() {return n.ConnectTypes}});
    })(ff);
  }

  return ff;
}const WK=qK();
const Pv="Connect";

const KK=Ne(Pv,() => new WK.ConnectInstrumentation);

const zK=(() => ({
  name:Pv,
  setupOnce(){KK()}
}));

const ZK=zK;
const Ef={};
const hf={};
const et={};
let Ay;
function XK(){
  if (!Ay) {
    Ay=1;
    Object.defineProperty(et,"__esModule",{value:true});
    et.DB_SYSTEM_VALUE_MSSQL=et.ATTR_NET_PEER_PORT=et.ATTR_NET_PEER_NAME=et.ATTR_DB_USER=et.ATTR_DB_SYSTEM=et.ATTR_DB_STATEMENT=et.ATTR_DB_SQL_TABLE=et.ATTR_DB_NAME=void 0;
    et.ATTR_DB_NAME="db.name";
    et.ATTR_DB_SQL_TABLE="db.sql.table";
    et.ATTR_DB_STATEMENT="db.statement";
    et.ATTR_DB_SYSTEM="db.system";
    et.ATTR_DB_USER="db.user";
    et.ATTR_NET_PEER_NAME="net.peer.name";
    et.ATTR_NET_PEER_PORT="net.peer.port";
    et.DB_SYSTEM_VALUE_MSSQL="mssql";
  }

  return et;
}
const Hr={};
let gy;
function QK(){
  if (gy) {
    return Hr;
  }
  gy=1;
  Object.defineProperty(Hr,"__esModule",{value:true});
  Hr.once = void 0;
  Hr.getSpanName = void 0;
  function e(n,r,o,s){return n==="execBulkLoad"&&s&&r?`${n} ${s} ${r}`:n==="callProcedure"?r?`${n} ${o} ${r}`:`${n} ${o}`:r?`${n} ${r}`:`${n}`}Hr.getSpanName=e;const t=n=>{let r=false;return (...o)=>{if (!r) {
    r=true;
    return n(...o);
  }};};
  Hr.once=t;
  return Hr;
}
const Fr={};
let Ry;
function JK(){
  if (!Ry) {
    Ry=1;
    Object.defineProperty(Fr,"__esModule",{value:true});
    Fr.PACKAGE_NAME=Fr.PACKAGE_VERSION=void 0;
    Fr.PACKAGE_VERSION="0.27.0";
    Fr.PACKAGE_NAME="@opentelemetry/instrumentation-tedious";
  }

  return Fr;
}let Ny;function e2(...args) {
  if (!Ny) {
    Ny=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.TediousInstrumentation = void 0;
      e.INJECTED_CTX = void 0;
      const t=Pe();
      const n=zu;
      const r=Le;
      const o=XK();
      const s=QK();
      const i=JK();
      const a=Symbol("opentelemetry.instrumentation-tedious.current-database");
      e.INJECTED_CTX=Symbol("opentelemetry.instrumentation-tedious.context-info-injected");const c=["callProcedure","execSql","execSqlBatch","execBulkLoad","prepare","execute"];function l(d){Object.defineProperty(this,a,{value:d,writable:true})}class f extends r.InstrumentationBase{static COMPONENT="tedious";constructor(u={}){super(i.PACKAGE_NAME,i.PACKAGE_VERSION,u)}init(){return [new r.InstrumentationNodeModuleDefinition(f.COMPONENT,[">=1.11.0 <20"],u=>{
      const _=u.Connection.prototype;for (const p of c) {
        if ((0,r.isWrapped)(_[p])) {
          this._unwrap(_,p);
        }

        this._wrap(_,p,this._patchQuery(p,u));
      }

      if ((0,r.isWrapped)(_.connect)) {
        this._unwrap(_,"connect");
      }

      this._wrap(_,"connect",this._patchConnect);
      return u;
    },u=>{if (u===void 0) {
        return;
      }const _=u.Connection.prototype;for (const p of c) {
        this._unwrap(_,p);
      }this._unwrap(_,"connect")})];}_patchConnect(u){return function(...args) {
        l.call(this,this.config?.options?.database);
        this.removeListener("databaseChange",l);
        this.on("databaseChange",l);
        this.once("end",()=>{this.removeListener("databaseChange",l)});
        return u.apply(this,args);
      };}_buildTraceparent(u){const _=u.spanContext();return`00-${_.traceId}-${_.spanId}-0${Number(_.traceFlags||t.TraceFlags.NONE).toString(16)}`}_injectContextInfo(u,_,p){return new Promise(E=>{try{
        const h="set context_info @opentelemetry_traceparent";
        const T=new _.Request(h,A=>{E()});
        Object.defineProperty(T,e.INJECTED_CTX,{value:true});const m=Buffer.from(p,"utf8");
        T.addParameter("opentelemetry_traceparent",_.TYPES.VarBinary,m,{length:m.length});
        u.execSql(T);
      }catch{E()}});}_shouldInjectFor(u){return u==="execSql"||u==="execSqlBatch"||u==="callProcedure"||u==="execute"}_patchQuery(u,_){return p=>{
        const E=this;function h(T){
      if (T?.[e.INJECTED_CTX]) {
        return p.apply(this,args);
      }if (!(T instanceof n.EventEmitter)) {
              E._diag.warn(`Unexpected invocation of patched ${u} method. Span not recorded`);
              return p.apply(this,args);
            }
      let m=0;
      let A=0;

      const g=() => A++;

      const R=() => m++;

      const O=this[a];

      const I=(B => B.sqlTextOrProcedure==="sp_prepare"&&B.parametersByName?.stmt?.value?B.parametersByName.stmt.value:B.sqlTextOrProcedure)(T);

      const b=E.tracer.startSpan((0,s.getSpanName)(u,O,I,T.table),{kind:t.SpanKind.CLIENT,attributes:{[o.ATTR_DB_SYSTEM]:o.DB_SYSTEM_VALUE_MSSQL,[o.ATTR_DB_NAME]:O,[o.ATTR_NET_PEER_PORT]:this.config?.options?.port,[o.ATTR_NET_PEER_NAME]:this.config?.server,[o.ATTR_DB_USER]:this.config?.userName??this.config?.authentication?.options?.userName,[o.ATTR_DB_STATEMENT]:I,[o.ATTR_DB_SQL_TABLE]:T.table}});

      const L=(0,s.once)(B=>{
        T.removeListener("done",g);
        T.removeListener("doneInProc",g);
        T.removeListener("doneProc",R);
        T.removeListener("error",L);
        this.removeListener("end",L);
        b.setAttribute("tedious.procedure_count",m);
        b.setAttribute("tedious.statement_count",A);

        if (B) {
          b.setStatus({code:t.SpanStatusCode.ERROR,message:B.message});
        }

        b.end();
      });

      T.on("done",g);
      T.on("doneInProc",g);
      T.on("doneProc",R);
      T.once("error",L);
      this.on("end",L);

      if (typeof T.callback=="function") {
        E._wrap(T,"callback",E._patchCallbackQuery(L));
      } else {
        E._diag.error("Expected request.callback to be a function");
      }

      const U=() => t.context.with(t.trace.setSpan(t.context.active(),b),p,this,...args);if (!(E.getConfig().enableTraceContextPropagation&&E._shouldInjectFor(u))) {
              return U();
            }const $=E._buildTraceparent(b);E._injectContextInfo(this,_,$).finally(U)
    }
        Object.defineProperty(h,"length",{value:p.length,writable:false});
        return h;
      };}_patchCallbackQuery(u){return _ => (function(p, E, h) {
      u(p);
      return _.apply(this,args);
    });}}e.TediousInstrumentation=f
    })(hf);
  }

  return hf;
}let yy;function t2(){
  if (!yy) {
    yy=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.TediousInstrumentation=void 0;
      const t=e2();Object.defineProperty(e,"TediousInstrumentation",{enumerable:true,get() {return t.TediousInstrumentation}})
    })(Ef);
  }

  return Ef;
}const n2=t2();
const r2=new Set(["callProcedure","execSql","execSqlBatch","execBulkLoad","prepare","execute"]);
const Mv="Tedious";

const o2=Ne(Mv,() => new n2.TediousInstrumentation({}));

const s2=(()=>{let e;return {name:Mv,setupOnce(){const t=o2();e=WP(t)},setup(t){e?.(() => t.on("spanStart",n=>{
  const{description,data}=Re(n);if (!description||data["db.system"]!=="mssql") {
    return;
  }const s=description.split(" ")[0]||"";

  if (r2.has(s)) {
    n.setAttribute(Ge,"auto.db.otel.tedious");
  }
}))}};});

const i2=s2;
const Tf={};
const ka={};
const Yr={};
let Oy;
function a2(){
  if (!Oy) {
    Oy=1;
    Object.defineProperty(Yr,"__esModule",{value:true});
    Yr.PACKAGE_NAME=Yr.PACKAGE_VERSION=void 0;
    Yr.PACKAGE_VERSION="0.52.0";
    Yr.PACKAGE_NAME="@opentelemetry/instrumentation-generic-pool";
  }

  return Yr;
}let by;function c2(){
  if (by) {
    return ka;
  }
  by=1;
  Object.defineProperty(ka,"__esModule",{value:true});
  ka.GenericPoolInstrumentation=void 0;
  const e=Pe();
  const t=Le;
  const n=a2();
  const r="generic-pool";
  class o extends t.InstrumentationBase{_isDisabled=false;constructor(i={}){super(n.PACKAGE_NAME,n.PACKAGE_VERSION,i)}init(){return [new t.InstrumentationNodeModuleDefinition(r,[">=3.0.0 <4"],i=>{
    const a=i.Pool;

    if ((0,t.isWrapped)(a.prototype.acquire)) {
      this._unwrap(a.prototype,"acquire");
    }

    this._wrap(a.prototype,"acquire",this._acquirePatcher.bind(this));
    return i;
  },i=>{
    const a=i.Pool;
    this._unwrap(a.prototype,"acquire");
    return i;
  }),new t.InstrumentationNodeModuleDefinition(r,[">=2.4.0 <3"],i=>{
    const a=i.Pool;

    if ((0,t.isWrapped)(a.prototype.acquire)) {
      this._unwrap(a.prototype,"acquire");
    }

    this._wrap(a.prototype,"acquire",this._acquireWithCallbacksPatcher.bind(this));
    return i;
  },i=>{
    const a=i.Pool;
    this._unwrap(a.prototype,"acquire");
    return i;
  }),new t.InstrumentationNodeModuleDefinition(r,[">=2.0.0 <2.4"],i => {
    this._isDisabled=false;

    if ((0,t.isWrapped)(i.Pool)) {
      this._unwrap(i,"Pool");
    }

    this._wrap(i,"Pool",this._poolWrapper.bind(this));
    return i;
  },i => {
    this._isDisabled=true;
    return i;
  })];}_acquirePatcher(i){const a=this;return function(...l){
    const f=e.context.active();
    const d=a.tracer.startSpan("generic-pool.acquire",{},f);
    return e.context.with(e.trace.setSpan(f,d),() => i.call(this,...l).then(u => {
      d.end();
      return u;
    },u=>{
      d.recordException(u);
      d.end();
      throw u;
    }));
  };}_poolWrapper(i){const a=this;return function(...args) {
    const l=i.apply(this,args);
    a._wrap(l,"acquire",a._acquireWithCallbacksPatcher.bind(a));
    return l;
  };}_acquireWithCallbacksPatcher(i){const a=this;return function(l,f){
    if (a._isDisabled) {
      return i.call(this,l,f);
    }
    const d=e.context.active();
    const u=a.tracer.startSpan("generic-pool.acquire",{},d);
    return e.context.with(e.trace.setSpan(d,u),()=>{i.call(this,(_,p)=>{
      u.end();

      if (l) {
        return l(_,p)
      }
    },f)});
  };}}
  ka.GenericPoolInstrumentation=o;
  return ka;
}let Cy;function u2(){
  if (!Cy) {
    Cy=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.GenericPoolInstrumentation=void 0;
      const t=c2();Object.defineProperty(e,"GenericPoolInstrumentation",{enumerable:true,get() {return t.GenericPoolInstrumentation}})
    })(Tf);
  }

  return Tf;
}const l2=u2();
const vv="GenericPool";

const d2=Ne(vv,() => new l2.GenericPoolInstrumentation({}));

const f2=(()=>{let e;return {name:vv,setupOnce(){const t=d2();e=WP(t)},setup(t){e?.(() => t.on("spanStart",n=>{
  const o=Re(n).description;

  if ((o==="generic-pool.aquire" || o==="generic-pool.acquire")) {
    n.setAttribute(Ge,"auto.db.otel.generic_pool");
  }
}))}};});

const _2=f2;
const Sf={};
const Ga={};
const nn={};
let Iy;
function Lv(){
  if (!Iy) {
    Iy=1;
    Object.defineProperty(nn,"__esModule",{value:true});
    nn.ATTR_NET_PEER_PORT=nn.ATTR_NET_PEER_NAME=nn.ATTR_MESSAGING_SYSTEM=nn.ATTR_MESSAGING_OPERATION=void 0;
    nn.ATTR_MESSAGING_OPERATION="messaging.operation";
    nn.ATTR_MESSAGING_SYSTEM="messaging.system";
    nn.ATTR_NET_PEER_NAME="net.peer.name";
    nn.ATTR_NET_PEER_PORT="net.peer.port";
  }

  return nn;
}
const He={};
let Py;
function wv(){
  if (!Py) {
    Py=1;
    Object.defineProperty(He,"__esModule",{value:true});
    He.ATTR_MESSAGING_CONVERSATION_ID=He.OLD_ATTR_MESSAGING_MESSAGE_ID=He.MESSAGING_DESTINATION_KIND_VALUE_TOPIC=He.ATTR_MESSAGING_URL=He.ATTR_MESSAGING_PROTOCOL_VERSION=He.ATTR_MESSAGING_PROTOCOL=He.MESSAGING_OPERATION_VALUE_PROCESS=He.ATTR_MESSAGING_RABBITMQ_ROUTING_KEY=He.ATTR_MESSAGING_DESTINATION_KIND=He.ATTR_MESSAGING_DESTINATION=void 0;
    He.ATTR_MESSAGING_DESTINATION="messaging.destination";
    He.ATTR_MESSAGING_DESTINATION_KIND="messaging.destination_kind";
    He.ATTR_MESSAGING_RABBITMQ_ROUTING_KEY="messaging.rabbitmq.routing_key";
    He.MESSAGING_OPERATION_VALUE_PROCESS="process";
    He.ATTR_MESSAGING_PROTOCOL="messaging.protocol";
    He.ATTR_MESSAGING_PROTOCOL_VERSION="messaging.protocol_version";
    He.ATTR_MESSAGING_URL="messaging.url";
    He.MESSAGING_DESTINATION_KIND_VALUE_TOPIC="topic";
    He.OLD_ATTR_MESSAGING_MESSAGE_ID="messaging.message_id";
    He.ATTR_MESSAGING_CONVERSATION_ID="messaging.conversation_id";
  }

  return He;
}
const mf={};
let My;
function Dv(){
  if (!My) {
    My=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.DEFAULT_CONFIG = void 0;
      e.EndOperation = void 0;

      (t => {
        t.AutoAck="auto ack";
        t.Ack="ack";
        t.AckAll="ackAll";
        t.Reject="reject";
        t.Nack="nack";
        t.NackAll="nackAll";
        t.ChannelClosed="channel closed";
        t.ChannelError="channel error";
        t.InstrumentationTimeout="instrumentation timeout";
      })(e.EndOperation||(e.EndOperation={}));

      e.DEFAULT_CONFIG={consumeTimeoutMs:1000/* 1e3 */*60,useLinksForConsume:false};
    })(mf);
  }

  return mf;
}
const Fe={};
let vy;
function p2(){
  if (vy) {
    return Fe;
  }
  vy=1;
  Object.defineProperty(Fe,"__esModule",{value:true});
  Fe.isConfirmChannelTracing = void 0;
  Fe.unmarkConfirmChannelTracing = void 0;
  Fe.markConfirmChannelTracing = void 0;
  Fe.getConnectionAttributesFromUrl = void 0;
  Fe.getConnectionAttributesFromServer = void 0;
  Fe.normalizeExchange = void 0;
  Fe.CONNECTION_ATTRIBUTES = void 0;
  Fe.CHANNEL_CONSUME_TIMEOUT_TIMER = void 0;
  Fe.CHANNEL_SPANS_NOT_ENDED = void 0;
  Fe.MESSAGE_STORED_SPAN = void 0;
  const e=Pe();
  const t=Lv();
  const n=wv();
  Fe.MESSAGE_STORED_SPAN=Symbol("opentelemetry.amqplib.message.stored-span");
  Fe.CHANNEL_SPANS_NOT_ENDED=Symbol("opentelemetry.amqplib.channel.spans-not-ended");
  Fe.CHANNEL_CONSUME_TIMEOUT_TIMER=Symbol("opentelemetry.amqplib.channel.consumer-timeout-timer");
  Fe.CONNECTION_ATTRIBUTES=Symbol("opentelemetry.amqplib.connection.attributes");
  const r=(0,e.createContextKey)("opentelemetry.amqplib.channel.is-confirm-channel");

  const o=E => E!==""?E:"<default>";

  Fe.normalizeExchange=o;

  const s=E => E.replace(/:[^:@/]*@/,":***@");

  const i=(E, h) => E||(h==="AMQP"?5672:5671);

  const a=E=>{const h=E||"amqp";return(h.endsWith(":")?h.substring(0,h.length-1):h).toUpperCase()};

  const c=E => E||"localhost";

  const l=(E, h, T, m) => T?{[h]:T}:(e.diag.error(`amqplib instrumentation: could not extract connection attribute ${m} from user supplied url`,{url:E}),{});

  const f=E=>{const h=E.serverProperties.product?.toLowerCase?.();return h?{[t.ATTR_MESSAGING_SYSTEM]:h}:{}};
  Fe.getConnectionAttributesFromServer=f;const d=E=>{
    const h={[n.ATTR_MESSAGING_PROTOCOL_VERSION]:"0.9.1"};
    E=E||"amqp://localhost";

    if (typeof E=="object") {
      const T=E;
      const m=a(T?.protocol);
      Object.assign(h,{...l(E,n.ATTR_MESSAGING_PROTOCOL,m,"protocol")});const A=c(T?.hostname);Object.assign(h,{...l(E,t.ATTR_NET_PEER_NAME,A,"hostname")});const g=i(T.port,m);Object.assign(h,{...l(E,t.ATTR_NET_PEER_PORT,g,"port")})
    } else {const T=s(E);h[n.ATTR_MESSAGING_URL]=T;try{
      const m=new URL(T);
      const A=a(m.protocol);
      Object.assign(h,{...l(T,n.ATTR_MESSAGING_PROTOCOL,A,"protocol")});const g=c(m.hostname);Object.assign(h,{...l(T,t.ATTR_NET_PEER_NAME,g,"hostname")});const R=i(m.port?parseInt(m.port):void 0,A);Object.assign(h,{...l(T,t.ATTR_NET_PEER_PORT,R,"port")})
    }catch(m){e.diag.error("amqplib instrumentation: error while extracting connection details from connection url",{censoredUrl:T,err:m})}}

    return h
  };Fe.getConnectionAttributesFromUrl=d;const u=E => E.setValue(r,true);Fe.markConfirmChannelTracing=u;const _=E => E.deleteValue(r);Fe.unmarkConfirmChannelTracing=_;const p=E => E.getValue(r)===true;
  Fe.isConfirmChannelTracing=p;
  return Fe;
}
const jr={};
let Ly;
function E2(){
  if (!Ly) {
    Ly=1;
    Object.defineProperty(jr,"__esModule",{value:true});
    jr.PACKAGE_NAME=jr.PACKAGE_VERSION=void 0;
    jr.PACKAGE_VERSION="0.55.0";
    jr.PACKAGE_NAME="@opentelemetry/instrumentation-amqplib";
  }

  return jr;
}let wy;function h2(...args) {
  if (wy) {
    return Ga;
  }
  wy=1;
  Object.defineProperty(Ga,"__esModule",{value:true});
  Ga.AmqplibInstrumentation=void 0;
  const e=Pe();
  const t=dn;
  const n=Le;
  const r=Lv();
  const o=wv();
  const s=Dv();
  const i=p2();
  const a=E2();
  const c=[">=0.5.5 <1"];
  class l extends n.InstrumentationBase{constructor(d={}){super(a.PACKAGE_NAME,a.PACKAGE_VERSION,{...s.DEFAULT_CONFIG,...d})}setConfig(d={}){super.setConfig({...s.DEFAULT_CONFIG,...d})}init(){
    const d=new n.InstrumentationNodeModuleFile("amqplib/lib/channel_model.js",c,this.patchChannelModel.bind(this),this.unpatchChannelModel.bind(this));
    const u=new n.InstrumentationNodeModuleFile("amqplib/lib/callback_model.js",c,this.patchChannelModel.bind(this),this.unpatchChannelModel.bind(this));
    const _=new n.InstrumentationNodeModuleFile("amqplib/lib/connect.js",c,this.patchConnect.bind(this),this.unpatchConnect.bind(this));
    return new n.InstrumentationNodeModuleDefinition("amqplib",c,void 0,void 0,[d,_,u])
  }patchConnect(d){
    d=this.unpatchConnect(d);

    if (!(0,n.isWrapped)(d.connect)) {
      this._wrap(d,"connect",this.getConnectPatch.bind(this));
    }

    return d;
  }unpatchConnect(d){
    if ((0,n.isWrapped)(d.connect)) {
      this._unwrap(d,"connect");
    }

    return d;
  }patchChannelModel(d,u){
    if (!(0,n.isWrapped)(d.Channel.prototype.publish)) {
      this._wrap(d.Channel.prototype,"publish",this.getPublishPatch.bind(this,u));
    }

    if (!(0,n.isWrapped)(d.Channel.prototype.consume)) {
      this._wrap(d.Channel.prototype,"consume",this.getConsumePatch.bind(this,u));
    }

    if (!(0,n.isWrapped)(d.Channel.prototype.ack)) {
      this._wrap(d.Channel.prototype,"ack",this.getAckPatch.bind(this,false,s.EndOperation.Ack));
    }

    if (!(0,n.isWrapped)(d.Channel.prototype.nack)) {
      this._wrap(d.Channel.prototype,"nack",this.getAckPatch.bind(this,true,s.EndOperation.Nack));
    }

    if (!(0,n.isWrapped)(d.Channel.prototype.reject)) {
      this._wrap(d.Channel.prototype,"reject",this.getAckPatch.bind(this,true,s.EndOperation.Reject));
    }

    if (!(0,n.isWrapped)(d.Channel.prototype.ackAll)) {
      this._wrap(d.Channel.prototype,"ackAll",this.getAckAllPatch.bind(this,false,s.EndOperation.AckAll));
    }

    if (!(0,n.isWrapped)(d.Channel.prototype.nackAll)) {
      this._wrap(d.Channel.prototype,"nackAll",this.getAckAllPatch.bind(this,true,s.EndOperation.NackAll));
    }

    if (!(0,n.isWrapped)(d.Channel.prototype.emit)) {
      this._wrap(d.Channel.prototype,"emit",this.getChannelEmitPatch.bind(this));
    }

    if (!(0,n.isWrapped)(d.ConfirmChannel.prototype.publish)) {
      this._wrap(d.ConfirmChannel.prototype,"publish",this.getConfirmedPublishPatch.bind(this,u));
    }

    return d;
  }unpatchChannelModel(d){
    if ((0,n.isWrapped)(d.Channel.prototype.publish)) {
      this._unwrap(d.Channel.prototype,"publish");
    }

    if ((0,n.isWrapped)(d.Channel.prototype.consume)) {
      this._unwrap(d.Channel.prototype,"consume");
    }

    if ((0,n.isWrapped)(d.Channel.prototype.ack)) {
      this._unwrap(d.Channel.prototype,"ack");
    }

    if ((0,n.isWrapped)(d.Channel.prototype.nack)) {
      this._unwrap(d.Channel.prototype,"nack");
    }

    if ((0,n.isWrapped)(d.Channel.prototype.reject)) {
      this._unwrap(d.Channel.prototype,"reject");
    }

    if ((0,n.isWrapped)(d.Channel.prototype.ackAll)) {
      this._unwrap(d.Channel.prototype,"ackAll");
    }

    if ((0,n.isWrapped)(d.Channel.prototype.nackAll)) {
      this._unwrap(d.Channel.prototype,"nackAll");
    }

    if ((0,n.isWrapped)(d.Channel.prototype.emit)) {
      this._unwrap(d.Channel.prototype,"emit");
    }

    if ((0,n.isWrapped)(d.ConfirmChannel.prototype.publish)) {
      this._unwrap(d.ConfirmChannel.prototype,"publish");
    }

    return d;
  }getConnectPatch(d){return function(_,p,E){return d.call(this,_,p,function(h,T){if(h==null){
    const m=(0,i.getConnectionAttributesFromUrl)(_);
    const A=(0,i.getConnectionAttributesFromServer)(T);
    T[i.CONNECTION_ATTRIBUTES]={...m,...A}
  }E.apply(this,args)});};}getChannelEmitPatch(d){const u=this;return function(p){if (p==="close") {
    u.endAllSpansOnChannel(this,true,s.EndOperation.ChannelClosed,void 0);const E=this[i.CHANNEL_CONSUME_TIMEOUT_TIMER];

    if (E) {
      clearInterval(E);
    }

    this[i.CHANNEL_CONSUME_TIMEOUT_TIMER]=void 0;
  } else {
    if (p==="error") {
      u.endAllSpansOnChannel(this,true,s.EndOperation.ChannelError,void 0);
    }
  }return d.apply(this,args);};}getAckAllPatch(d,u,_){const p=this;return function(h){
    p.endAllSpansOnChannel(this,d,u,h);
    return _.apply(this,args);
  };}getAckPatch(d,u,_){const p=this;return function(h,T,m){
    const A=this;
    const g=u===s.EndOperation.Reject?T:m;
    const R=A[i.CHANNEL_SPANS_NOT_ENDED]??[];

    const O=R.findIndex(I => I.msg===h);

    if (O<0) {
      p.endConsumerSpan(h,d,u,g);
    } else if (u!==s.EndOperation.Reject&&T) {for (let I=0; I<=O; I++) {
      p.endConsumerSpan(R[I].msg,d,u,g);
    }R.splice(0,O+1)} else {
      p.endConsumerSpan(h,d,u,g);
      R.splice(O,1);
    }return _.apply(this,args);
  };}getConsumePatch(d,u){const _=this;return function(E,h,T){
    const m=this;if(!Object.prototype.hasOwnProperty.call(m,i.CHANNEL_SPANS_NOT_ENDED)){const{consumeTimeoutMs}=_.getConfig();if(consumeTimeoutMs){
      const R=setInterval(()=>{_.checkConsumeTimeoutOnChannel(m)},consumeTimeoutMs);
      R.unref();
      m[i.CHANNEL_CONSUME_TIMEOUT_TIMER]=R;
    }m[i.CHANNEL_SPANS_NOT_ENDED]=[]}const A=function(g){
    if (!g) {
      return h.call(this,g);
    }const R=g.properties.headers??{};let O=e.propagation.extract(e.ROOT_CONTEXT,R);const I=g.fields?.exchange;let b;if(_._config.useLinksForConsume){
      const H=O?e.trace.getSpan(O)?.spanContext():void 0;
      O=void 0;

      if (H) {
        (b = [{context:H}]);
      }
    }
    const L=_.tracer.startSpan(`${E} process`,{kind:e.SpanKind.CONSUMER,attributes:{...m?.connection?.[i.CONNECTION_ATTRIBUTES],[o.ATTR_MESSAGING_DESTINATION]:I,[o.ATTR_MESSAGING_DESTINATION_KIND]:o.MESSAGING_DESTINATION_KIND_VALUE_TOPIC,[o.ATTR_MESSAGING_RABBITMQ_ROUTING_KEY]:g.fields?.routingKey,[r.ATTR_MESSAGING_OPERATION]:o.MESSAGING_OPERATION_VALUE_PROCESS,[o.OLD_ATTR_MESSAGING_MESSAGE_ID]:g?.properties.messageId,[o.ATTR_MESSAGING_CONVERSATION_ID]:g?.properties.correlationId},links:b},O);
    const {consumeHook}=_.getConfig();

    if (consumeHook) {
      (0,n.safeExecuteInTheMiddle)(() => consumeHook(L,{moduleVersion:d,msg:g}),H=>{
        if (H) {
          e.diag.error("amqplib instrumentation: consumerHook error",H);
        }
      },true);
    }

    if (!T?.noAck) {
      m[i.CHANNEL_SPANS_NOT_ENDED].push({msg:g,timeOfConsume:(0,t.hrTime)()});
      g[i.MESSAGE_STORED_SPAN]=L;
    }

    const q=O||e.ROOT_CONTEXT;
    e.context.with(e.trace.setSpan(q,L),()=>{h.call(this,g)});

    if (T?.noAck) {
      _.callConsumeEndHook(L,g,false,s.EndOperation.AutoAck);
      L.end();
    }
  };
    args[1]=A;
    return u.apply(this,args);
  };}getConfirmedPublishPatch(d,u){const _=this;return function(E,h,T,m,A){
    const g=this;
    const {span,modifiedOptions}=_.createPublishSpan(_,E,h,g,m);
    const {publishHook}=_.getConfig();

    if (publishHook) {
      (0,n.safeExecuteInTheMiddle)(() => publishHook(span,{moduleVersion:d,exchange:E,routingKey:h,content:T,options:modifiedOptions,isConfirmChannel:true}),q=>{
        if (q) {
          e.diag.error("amqplib instrumentation: publishHook error",q);
        }
      },true);
    }

    const b=function(q,H){try{A?.call(this,q,H)}finally{
      const{publishConfirmHook}=_.getConfig();

      if (publishConfirmHook) {
        (0,n.safeExecuteInTheMiddle)(() => publishConfirmHook(span,{moduleVersion:d,exchange:E,routingKey:h,content:T,options:m,isConfirmChannel:true,confirmError:q}),B=>{
          if (B) {
            e.diag.error("amqplib instrumentation: publishConfirmHook error",B);
          }
        },true);
      }

      if (q) {
        span.setStatus({code:e.SpanStatusCode.ERROR,message:"message confirmation has been nack'ed"});
      }

      span.end();
    }};

    const L=(0,i.markConfirmChannelTracing)(e.context.active());
    const U=[...args];
    U[3]=modifiedOptions;
    U[4]=e.context.bind((0,i.unmarkConfirmChannelTracing)(e.trace.setSpan(L,span)),b);
    return e.context.with(L,u.bind(this,...U));
  };}getPublishPatch(d,u){const _=this;return function(E,h,T,m){if ((0,i.isConfirmChannelTracing)(e.context.active())) {
    return u.apply(this,args);
  }{
    const A=this;
    const {span,modifiedOptions}=_.createPublishSpan(_,E,h,A,m);
    const {publishHook}=_.getConfig();

    if (publishHook) {
      (0,n.safeExecuteInTheMiddle)(() => publishHook(span,{moduleVersion:d,exchange:E,routingKey:h,content:T,options:modifiedOptions,isConfirmChannel:false}),L=>{
        if (L) {
          e.diag.error("amqplib instrumentation: publishHook error",L);
        }
      },true);
    }

    const I=[...args];I[3]=modifiedOptions;const b=u.apply(this,I);
    span.end();
    return b;
  }};}createPublishSpan(d,u,_,p,E){
    const h=(0,i.normalizeExchange)(u);
    const T=d.tracer.startSpan(`publish ${h}`,{kind:e.SpanKind.PRODUCER,attributes:{...p.connection[i.CONNECTION_ATTRIBUTES],[o.ATTR_MESSAGING_DESTINATION]:u,[o.ATTR_MESSAGING_DESTINATION_KIND]:o.MESSAGING_DESTINATION_KIND_VALUE_TOPIC,[o.ATTR_MESSAGING_RABBITMQ_ROUTING_KEY]:_,[o.OLD_ATTR_MESSAGING_MESSAGE_ID]:E?.messageId,[o.ATTR_MESSAGING_CONVERSATION_ID]:E?.correlationId}});
    const m=E??{};
    m.headers=m.headers??{};
    e.propagation.inject(e.trace.setSpan(e.context.active(),T),m.headers);
    return {span:T,modifiedOptions:m};
  }endConsumerSpan(d,u,_,p){
    const E=d[i.MESSAGE_STORED_SPAN];

    if (E) {
      u!==false&&E.setStatus({code:e.SpanStatusCode.ERROR,message:_!==s.EndOperation.ChannelClosed&&_!==s.EndOperation.ChannelError?`${_} called on message${p===true?" with requeue":p===false?" without requeue":""}`:_});
      this.callConsumeEndHook(E,d,u,_);
      E.end();
      d[i.MESSAGE_STORED_SPAN]=void 0;
    }
  }endAllSpansOnChannel(d,u,_,p){
    (d[i.CHANNEL_SPANS_NOT_ENDED]??[]).forEach(h=>{this.endConsumerSpan(h.msg,u,_,p)});
    d[i.CHANNEL_SPANS_NOT_ENDED]=[];
  }callConsumeEndHook(d,u,_,p){
    const{consumeEndHook}=this.getConfig();

    if (consumeEndHook) {
      (0,n.safeExecuteInTheMiddle)(() => consumeEndHook(d,{msg:u,rejected:_,endOperation:p}),h=>{
        if (h) {
          e.diag.error("amqplib instrumentation: consumerEndHook error",h);
        }
      },true);
    }
  }checkConsumeTimeoutOnChannel(d){
    const u=(0,t.hrTime)();
    const _=d[i.CHANNEL_SPANS_NOT_ENDED]??[];
    let p;const{consumeTimeoutMs}=this.getConfig();for(p=0;p<_.length;p++){
      const h=_[p];
      const T=(0,t.hrTimeDuration)(h.timeOfConsume,u);
      if ((0,t.hrTimeToMilliseconds)(T)<consumeTimeoutMs) {
        break;
      }this.endConsumerSpan(h.msg,null,s.EndOperation.InstrumentationTimeout,true)
    }_.splice(0,p)
  }}
  Ga.AmqplibInstrumentation=l;
  return Ga;
}let Dy;function T2(){
  if (!Dy) {
    Dy=1;

    (e => {
      Object.defineProperty(e,"__esModule",{value:true});
      e.EndOperation = void 0;
      e.DEFAULT_CONFIG = void 0;
      e.AmqplibInstrumentation = void 0;
      const t=h2();Object.defineProperty(e,"AmqplibInstrumentation",{enumerable:true,get() {return t.AmqplibInstrumentation}});const n=Dv();
      Object.defineProperty(e,"DEFAULT_CONFIG",{enumerable:true,get() {return n.DEFAULT_CONFIG}});
      Object.defineProperty(e,"EndOperation",{enumerable:true,get() {return n.EndOperation}});
    })(Sf);
  }

  return Sf;
}const S2=T2();
const Uv="Amqplib";
const m2={consumeEndHook:e=>{yt(e,"auto.amqplib.otel.consumer")},publishHook:e=>{yt(e,"auto.amqplib.otel.publisher")}};

const A2=Ne(Uv,() => new S2.AmqplibInstrumentation(m2));

const g2=(() => ({
  name:Uv,
  setupOnce(){A2()}
}));

const R2=g2;
const sh="VercelAI";
const Uy=["generateText","streamText","generateObject","streamObject","embed","embedMany"];
function N2(e){if (typeof e!="object"||e===null) {
  return false;
}const t=e;return"type"in t&&"error"in t&&"toolName"in t&&"toolCallId"in t&&t.type==="tool-error"&&t.error instanceof Error}function y2(e){if (typeof e!="object"||e===null||!("content"in e)) {
  return;
}const t=e;if(Array.isArray(t.content)){for (const n of t.content) {
  if(N2(n)){const r=yx(n.toolCallId);if (r) {
    const o=r.spanContext();

    no(s=>{
      s.setContext("trace",{trace_id:o.traceId,span_id:o.spanId});
      s.setTag("vercel.ai.tool.name",n.toolName);
      s.setTag("vercel.ai.tool.callId",n.toolCallId);
      s.setLevel("error");
      xe(n.error,{mechanism:{type:"auto.vercelai.otel",handled:false}});
    });

    Ox(n.toolCallId);
  } else {
    no(o=>{
      o.setTag("vercel.ai.tool.name",n.toolName);
      o.setTag("vercel.ai.tool.callId",n.toolCallId);
      o.setLevel("error");
      xe(n.error,{mechanism:{type:"auto.vercelai.otel",handled:false}});
    })
  }}
}}}function O2(e,t,n,r){
  const o=e?.recordInputs!==void 0?e.recordInputs:t.recordInputs!==void 0?t.recordInputs:n===true?true:r;
  const s=e?.recordOutputs!==void 0?e.recordOutputs:t.recordOutputs!==void 0?t.recordOutputs:n===true?true:r;
  return{recordInputs:o,recordOutputs:s}
}class Du extends Ot{__init(){this._isPatched=false}__init2(){this._callbacks=[]}constructor(t={}){
  super("@sentry/instrumentation-vercel-ai",Ze,t);
  Du.prototype.__init.call(this);
  Du.prototype.__init2.call(this);
}init(){return new ft("ai",[">=3.0.0 <6"],this._patch.bind(this))}callWhenPatched(t){
  if (this._isPatched) {
    t();
  } else {
    this._callbacks.push(t);
  }
}_patch(t){
  this._isPatched=true;

  this._callbacks.forEach(r => r());

  this._callbacks=[];
  const n=r => new Proxy(r,{apply:(o,s,i)=>{
    const a=i[0].experimental_telemetry||{};
    const c=a.isEnabled;
    const l=he();
    const f=l?.getIntegrationByName(sh);
    const d=f?.options;
    const u=f?!!l?.getOptions().sendDefaultPii:false;
    const {recordInputs,recordOutputs}=O2(d,a,c,u);
    i[0].experimental_telemetry={...a,isEnabled:c!==void 0?c:true,recordInputs:recordInputs,recordOutputs:recordOutputs};

    return oo(() => Reflect.apply(o,s,i),E=>{
      if (E&&typeof E=="object") {
        cn(E,"_sentry_active_span",ll());
      }
    },()=>{},E=>{y2(E)});
  }});if(Object.prototype.toString.call(t)==="[object Module]"){for (const r of Uy) {
    t[r]=n(t[r]);
  }return t}else{const r=Uy.reduce((o, s) => {
    o[s]=n(t[s]);
    return o;
  },{});return{...t,...r}}
}}const b2=Ne(sh,() => new Du({}));function C2(e){return!!e.getIntegrationByName("Modules")?.getModules?.()?.ai}

const I2=((e={})=>{let t;return {name:sh,options:e,setupOnce(){t=b2()},afterAllSetup(n){
  if (e.force??C2(n)) {
    wg(n);
  } else {
    t?.callWhenPatched(() => wg(n));
  }
}};});

const P2=I2;
const M2=[">=4.0.0 <7"];
class v2 extends Ot{constructor(t={}){super("@sentry/instrumentation-openai",Ze,t)}init(){return new ft("openai",M2,this._patch.bind(this))}_patch(t){
  let n=t;
  n=this._patchClient(n,"OpenAI");
  n=this._patchClient(n,"AzureOpenAI");
  return n;
}_patchClient(t,n){
  const r=t[n];if (!r) {
    return t;
  }
  const o=this.getConfig();

  const s=(...i) => {
    if (PE(gl)) {
      return Reflect.construct(r,i);
    }
    const a=Reflect.construct(r,i);
    const l=!!he()?.getOptions().sendDefaultPii;
    const f=o.recordInputs??l;
    const d=o.recordOutputs??l;
    return t$(a,{recordInputs:f,recordOutputs:d})
  };

  Object.setPrototypeOf(s,r);
  Object.setPrototypeOf(s.prototype,r.prototype);
  for (const i of Object.getOwnPropertyNames(r)) {
    if(!["length","name","prototype"].includes(i)){
      const a=Object.getOwnPropertyDescriptor(r,i);

      if (a) {
        Object.defineProperty(s,i,a);
      }
    }
  }try{t[n]=s}catch{Object.defineProperty(t,n,{value:s,writable:true,configurable:true,enumerable:true})}if (t.default===r) {
    try{t.default=s}catch{Object.defineProperty(t,"default",{value:s,writable:true,configurable:true,enumerable:true})}
  }return t
}}

const L2=Ne(gl,e => new v2(e));

const w2=((e={}) => ({
  name:gl,
  setupOnce(){L2(e)}
}));

const D2=w2;
const U2=[">=0.19.2 <1.0.0"];
class k2 extends Ot{constructor(t={}){super("@sentry/instrumentation-anthropic-ai",Ze,t)}init(){return new ft("@anthropic-ai/sdk",U2,this._patch.bind(this))}_patch(t){
  const n=t.Anthropic;
  const r=this.getConfig();

  const o=(...s) => {
    if (PE(Nl)) {
      return Reflect.construct(n,s);
    }
    const i=Reflect.construct(n,s);
    const c=!!he()?.getOptions().sendDefaultPii;
    const l=r.recordInputs??c;
    const f=r.recordOutputs??c;
    return A$(i,{recordInputs:l,recordOutputs:f})
  };

  Object.setPrototypeOf(o,n);
  Object.setPrototypeOf(o.prototype,n.prototype);
  for (const s of Object.getOwnPropertyNames(n)) {
    if(!["length","name","prototype"].includes(s)){
      const i=Object.getOwnPropertyDescriptor(n,s);

      if (i) {
        Object.defineProperty(o,s,i);
      }
    }
  }try{t.Anthropic=o}catch{Object.defineProperty(t,"Anthropic",{value:o,writable:true,configurable:true,enumerable:true})}if (t.default===n) {
    try{t.default=o}catch{Object.defineProperty(t,"default",{value:o,writable:true,configurable:true,enumerable:true})}
  }return t
}}

const G2=Ne(Nl,e => new k2(e));

const V2=((e={}) => ({
  name:Nl,
  options:e,
  setupOnce(){G2(e)}
}));

const x2=V2;
const ky=[">=0.10.0 <2"];
class $2 extends Ot{constructor(t={}){super("@sentry/instrumentation-google-genai",Ze,t)}init(){return new ft("@google/genai",ky,n => this._patch(n),n => n,[new Hn("@google/genai/dist/node/index.cjs",ky,n => this._patch(n),n => n)]);}_patch(t){
  const n=t.GoogleGenAI;
  const r=this.getConfig();
  if (typeof n!="function") {
    return t;
  }const o=(...s) => {
    if (PE(yl)) {
      return Reflect.construct(n,s);
    }
    const i=Reflect.construct(n,s);
    const c=!!he()?.getOptions().sendDefaultPii;
    const l=r;
    const f=l?.recordInputs??c;
    const d=l?.recordOutputs??c;
    return w$(i,{recordInputs:f,recordOutputs:d})
  };
  Object.setPrototypeOf(o,n);
  Object.setPrototypeOf(o.prototype,n.prototype);
  for (const s of Object.getOwnPropertyNames(n)) {
    if(!["length","name","prototype"].includes(s)){
      const i=Object.getOwnPropertyDescriptor(n,s);

      if (i) {
        Object.defineProperty(o,s,i);
      }
    }
  }
  z$(t,"GoogleGenAI",o);
  return t;
}}

const B2=Ne(yl,e => new $2(e));

const H2=((e={}) => ({
  name:yl,
  setupOnce(){B2(e)}
}));

const F2=H2;
const Fc=[">=0.1.0 <2.0.0"];
function Y2(e,t){return e?Array.isArray(e)?e.includes(t)?e:[...e,t]:typeof e=="object"?[e,t]:e:[t]}function j2(e,t,n){return new Proxy(e,{apply(r,o,s){
  let a=s[1];

  if ((!a||typeof a!="object" || Array.isArray(a))) {
    a={};
    s[1]=a;
  }

  const c=a.callbacks;
  const l=Y2(c,t);
  a.callbacks=l;
  return Reflect.apply(r,o,s);
}});}class q2 extends Ot{constructor(t={}){super("@sentry/instrumentation-langchain",Ze,t)}init(){
  const t=[];
  const n=["@langchain/anthropic","@langchain/openai","@langchain/google-genai","@langchain/mistralai","@langchain/google-vertexai","@langchain/groq"];
  for (const r of n) {
    t.push(new ft(r,Fc,this._patch.bind(this),o => o,[new Hn(`${r}/dist/index.cjs`,Fc,this._patch.bind(this),o => o)]));
  }

  t.push(new ft("langchain",Fc,this._patch.bind(this),r => r,[new Hn("langchain/dist/chat_models/universal.cjs",Fc,this._patch.bind(this),r => r)]));

  return t;
}_patch(t){
  $G([gl,Nl,yl]);
  const r=!!he()?.getOptions().sendDefaultPii;
  const o=this.getConfig();
  const s=o?.recordInputs??r;
  const i=o?.recordOutputs??r;
  const a=B$({recordInputs:s,recordOutputs:i});
  this._patchRunnableMethods(t,a);
  return t;
}_patchRunnableMethods(t,n){
  const r=["ChatAnthropic","ChatOpenAI","ChatGoogleGenerativeAI","ChatMistralAI","ChatVertexAI","ChatGroq","ConfigurableModel"];
  const o=t.universal_exports??t;

  const s=Object.values(o).find(c => typeof c=="function"&&r.includes(c.name));

  if (!s) {
    return;
  }
  const i=s.prototype;
  const a=["invoke","stream","batch"];
  for(const c of a){
    const l=i[c];

    if (typeof l=="function") {
      (i[c] = j2(l,n));
    }
  }
}}

const W2=Ne(HP,e => new q2(e));

const K2=((e={}) => ({
  name:HP,
  setupOnce(){W2(e)}
}));

const z2=K2;
const Gy=[">=0.0.0 <2.0.0"];
class Z2 extends Ot{constructor(t={}){super("@sentry/instrumentation-langgraph",Ze,t)}init(){return new ft("@langchain/langgraph",Gy,this._patch.bind(this),n => n,[new Hn("@langchain/langgraph/dist/index.cjs",Gy,this._patch.bind(this),n => n)]);}_patch(t){
  const r=!!he()?.getOptions().sendDefaultPii;
  const o=this.getConfig();
  const s=o.recordInputs??r;
  const i=o.recordOutputs??r;
  const a={recordInputs:s,recordOutputs:i};
  if(t.StateGraph&&typeof t.StateGraph=="function"){const c=t.StateGraph;c.prototype.compile=W$(c.prototype.compile,a)}return t
}}

const X2=Ne(YP,e => new Z2(e));

const Q2=((e={}) => ({
  name:YP,
  setupOnce(){X2(e)}
}));

const J2=Q2;
function ez(e,t,n,r,o){
  let i=()=>{};const a=o.firestoreSpanCreationHook;

  if (typeof a=="function") {
    (i = f=>{tr(() => a(f),d=>{
      if (d) {
        C.diag.error(d?.message);
      }
    },true)});
  }

  const c=new ft("@firebase/firestore",t,f => Vy(f,n,r,e,i));

  const l=["@firebase/firestore/dist/lite/index.node.cjs.js","@firebase/firestore/dist/lite/index.node.mjs.js","@firebase/firestore/dist/lite/index.rn.esm2017.js","@firebase/firestore/dist/lite/index.cjs.js"];
  for (const f of l) {
    c.files.push(new Hn(f,t,d => Vy(d,n,r,e,i),d => kv(d,r)));
  }return c
}function Vy(e,t,n,r,o){
  kv(e,n);
  t(e,"addDoc",tz(r,o));
  t(e,"getDocs",rz(r,o));
  t(e,"setDoc",oz(r,o));
  t(e,"deleteDoc",nz(r,o));
  return e;
}function kv(e,t){for (const n of ["addDoc","getDocs","setDoc","deleteDoc"]) {
  if (ol(e[n])) {
    t(e,n);
  }
}return e}function tz(e,t){return r => (o, s) => {
  const i=vl(e,"addDoc",o);
  t(i);

  return Ml(i,() => r(o,s));
};}function nz(e,t){return r => o => {
  const s=vl(e,"deleteDoc",o.parent||o);
  t(s);

  return Ml(s,() => r(o));
};}function rz(e,t){return r => o => {
  const s=vl(e,"getDocs",o);
  t(s);

  return Ml(s,() => r(o));
};}function oz(e,t){return r => (o, s, i) => {
  const a=vl(e,"setDoc",o.parent||o);
  t(a);

  return Ml(a,() => typeof i !== "undefined"?r(o,s,i):r(o,s));
};}function Ml(e,t){return C.context.with(C.trace.setSpan(C.context.active(),e),() => tr(() => t(),n=>{
  if (n) {
    e.recordException(n);
  }

  e.end();
},true));}function vl(e,t,n){
  const r=e.startSpan(`${t} ${n.path}`,{kind:C.SpanKind.CLIENT});
  iz(r,n);
  r.setAttribute(Q.ATTR_DB_OPERATION_NAME,t);
  return r;
}function sz(e){
  let t;
  let n;
  if (typeof e.host=="string") {
    if(e.host.startsWith("[")){if (e.host.endsWith("]")) {
      t=e.host.replace(/^\[|\]$/g,"");
    } else
      if(e.host.includes("]:")){
        const r=e.host.lastIndexOf(":");

        if (r!==-1) {
          t=e.host.slice(1,r).replace(/^\[|\]$/g,"");
          n=e.host.slice(r+1);
        }
      }}else if (No.isIPv6(e.host)) {
      t=e.host;
    } else
      {
        const r=e.host.lastIndexOf(":");

        if (r!==-1) {
          t=e.host.slice(0,r);
          n=e.host.slice(r+1);
        } else {
          t=e.host;
        }
      }
  }return{address:t,port:n?parseInt(n,10):void 0}
}function iz(e,t){
  const n=t.firestore.app;
  const r=n.options;
  const s=(t.firestore.toJSON()||{}).settings||{};
  const i={[Q.ATTR_DB_COLLECTION_NAME]:t.path,[Q.ATTR_DB_NAMESPACE]:n.name,[Q.ATTR_DB_SYSTEM_NAME]:"firebase.firestore","firebase.firestore.type":t.type,"firebase.firestore.options.projectId":r.projectId,"firebase.firestore.options.appId":r.appId,"firebase.firestore.options.messagingSenderId":r.messagingSenderId,"firebase.firestore.options.storageBucket":r.storageBucket};
  const {address,port}=sz(s);

  if (address) {
    (i[Q.ATTR_SERVER_ADDRESS] = address);
  }

  if (port) {
    (i[Q.ATTR_SERVER_PORT] = port);
  }

  e.setAttributes(i);
}function az(e,t,n,r,o){
  let s=()=>{};
  let i=()=>{};
  const a=o.functions?.errorHook;
  const c=o.functions?.requestHook;
  const l=o.functions?.responseHook;

  if (typeof l=="function") {
    (i = (u,_)=>{tr(() => l(u,_),p=>{
      if (p) {
        C.diag.error(p?.message);
      }
    },true)});
  }

  if (typeof c=="function") {
    (s = u=>{tr(() => c(u),_=>{
      if (_) {
        C.diag.error(_?.message);
      }
    },true)});
  }

  const f=new ft("firebase-functions",t);

  [{name:"firebase-functions/lib/v2/providers/https.js",triggerType:"function"},{name:"firebase-functions/lib/v2/providers/firestore.js",triggerType:"firestore"},{name:"firebase-functions/lib/v2/providers/scheduler.js",triggerType:"scheduler"},{name:"firebase-functions/lib/v2/storage.js",triggerType:"storage"}].forEach(({name,triggerType})=>{f.files.push(new Hn(name,t,p => cz(p,n,r,e,{requestHook:s,responseHook:i,errorHook:a},triggerType),p => Gv(p,r)))});

  return f;
}function mt(e,t,n){return o => (function(...s) {
  const i=typeof s[0]=="function"?s[0]:s[1];
  const a=typeof s[0]=="function"?void 0:s[0];
  if (!i) {
    return o.call(this,...s);
  }const c=async function(...l){
  const f=process.env.FUNCTION_TARGET||process.env.K_SERVICE||"unknown";
  const d=e.startSpan(`firebase.function.${n}`,{kind:C.SpanKind.SERVER});
  const u={"faas.name":f,"faas.trigger":n,"faas.provider":"firebase"};

  if (process.env.GCLOUD_PROJECT) {
    (u["cloud.project_id"] = process.env.GCLOUD_PROJECT);
  }

  if (process.env.EVENTARC_CLOUD_EVENT_SOURCE) {
    (u["cloud.event_source"] = process.env.EVENTARC_CLOUD_EVENT_SOURCE);
  }

  d.setAttributes(u);
  t?.requestHook?.(d);

  return C.context.with(C.trace.setSpan(C.context.active(),d),async()=>{
    let _;
    let p;
    try{p=await i.apply(this,l)}catch(E){_=E}
    t?.responseHook?.(d,_);

    if (_) {
      d.recordException(_);
    }

    d.end();

    if (_) {
      await t?.errorHook?.(d,_);
      throw _;
    }

    return p
  });
};return a?o.call(this,a,c):o.call(this,c)
});}function cz(e,t,n,r,o,s){
  Gv(e,n);

  switch (s) {
  case "function":
    {
      t(e,"onRequest",mt(r,o,"http.request"));
      t(e,"onCall",mt(r,o,"http.call"));
      break;
    }
  case "firestore":
    {
      t(e,"onDocumentCreated",mt(r,o,"firestore.document.created"));
      t(e,"onDocumentUpdated",mt(r,o,"firestore.document.updated"));
      t(e,"onDocumentDeleted",mt(r,o,"firestore.document.deleted"));
      t(e,"onDocumentWritten",mt(r,o,"firestore.document.written"));
      t(e,"onDocumentCreatedWithAuthContext",mt(r,o,"firestore.document.created"));
      t(e,"onDocumentUpdatedWithAuthContext",mt(r,o,"firestore.document.updated"));
      t(e,"onDocumentDeletedWithAuthContext",mt(r,o,"firestore.document.deleted"));
      t(e,"onDocumentWrittenWithAuthContext",mt(r,o,"firestore.document.written"));
      break;
    }
  case "scheduler":
    {
      t(e,"onSchedule",mt(r,o,"scheduler.scheduled"));break;
    }
  case "storage":
    {
      t(e,"onObjectFinalized",mt(r,o,"storage.object.finalized"));
      t(e,"onObjectArchived",mt(r,o,"storage.object.archived"));
      t(e,"onObjectDeleted",mt(r,o,"storage.object.deleted"));
      t(e,"onObjectMetadataUpdated",mt(r,o,"storage.object.metadataUpdated"));
      break
    }
  }

  return e
}function Gv(e,t){const n=["onSchedule","onRequest","onCall","onObjectFinalized","onObjectArchived","onObjectDeleted","onObjectMetadataUpdated","onDocumentCreated","onDocumentUpdated","onDocumentDeleted","onDocumentWritten","onDocumentCreatedWithAuthContext","onDocumentUpdatedWithAuthContext","onDocumentDeletedWithAuthContext","onDocumentWrittenWithAuthContext"];for (const r of n) {
  if (ol(e[r])) {
    t(e,r);
  }
}return e}
const xy={};
const uz=[">=3.0.0 <5"];
const lz=[">=6.0.0 <7"];
class dz extends Ot{constructor(t=xy){super("@sentry/instrumentation-firebase",Ze,t)}setConfig(t={}){super.setConfig({...xy,...t})}init(){
  const t=[];
  t.push(ez(this.tracer,uz,this._wrap,this._unwrap,this.getConfig()));
  t.push(az(this.tracer,lz,this._wrap,this._unwrap,this.getConfig()));
  return t;
}}
const Vv="Firebase";

const fz={firestoreSpanCreationHook:e=>{
  yt(e,"auto.firebase.otel.firestore");
  e.setAttribute(Ee,"db.query");
},functions:{requestHook:e=>{
  yt(e,"auto.firebase.otel.functions");
  e.setAttribute(Ee,"http.request");
},errorHook:async(e,t)=>{
  if (t) {
    xe(t,{mechanism:{type:"auto.firebase.otel.functions",handled:false}});
    await Z1(2000/* 2e3 */);
  }
}}};

const _z=Ne(Vv,() => new dz(fz));

const pz=(() => ({
  name:Vv,
  setupOnce(){_z()}
}));

const Ez=pz;
function hz(){return[nj(),sq(),hq(),LK(),Kq(),nW(),dW(),mW(),FW(),QW(),hK(),OK(),BK(),ZK(),i2(),_2(),Cq(),R2(),Dq(),z2(),J2(),P2(),D2(),x2(),F2(),nK(),Ez()]}const Af=1000000/* 1e6 */;function Tz(e,t={}){
  if (e.getOptions().debug) {
    sY();
  }

  const n=Sz(e,t);e.traceProvider=n
}function Sz(e,t={}){
  const n=new MB({sampler:new SH(e),resource:QP().merge(XP({[Q.ATTR_SERVICE_NAME]:"node",[Q.SEMRESATTRS_SERVICE_NAMESPACE]:"sentry",[Q.ATTR_SERVICE_VERSION]:Ze})),forceFlushTimeoutMillis:500,spanProcessors:[new TH({timeout:mz(e.getOptions().maxSpanWaitDuration)}),...(t.spanProcessors || [])]});
  C.trace.setGlobalTracerProvider(n);
  C.propagation.setGlobalPropagator(new YB);
  C.context.setGlobalContextManager(new oY);
  return n;
}function mz(e){if(e!=null){if (e>Af) {
  if (io) {
    x.warn(`\`maxSpanWaitDuration\` is too high, using the maximum value of ${Af}`);
  }

  return Af;
}if(e<=0||Number.isNaN(e)){
  if (io) {
    x.warn("`maxSpanWaitDuration` must be a positive number, using default value instead.");
  }

  return
}return e}}function Az(){return xM().filter(t => t.name!=="Http"&&t.name!=="NodeFetch").concat(DY(),FY());}function gz(e){return [...Az(),...(zt(e) ? hz() : [])];}function Rz(e={}){return Nz(e,gz)}function Nz(e={},t){
  ME(e,"node");const n=yY({...e,defaultIntegrations:e.defaultIntegrations??t(e)});

  if (n&&!e.skipOpenTelemetrySetup) {
    Tz(n,{spanProcessors:e.openTelemetrySpanProcessors});
    bY();
  }

  return n;
}function W(e,t,n){
  function r(a,c){
    if (!a._zod) {
      Object.defineProperty(a,"_zod",{value:{def:c,constr:i,traits:new Set},enumerable:false});
    }

    if (a._zod.traits.has(e)) {
      return;
    }

    a._zod.traits.add(e);
    t(a,c);
    const l=i.prototype;
    const f=Object.keys(l);

    for (const u of f) {
      if (u in a) {
        (a[u] = l[u].bind(a));
      }
    }
  }const o=n?.Parent??Object;class s extends o{}Object.defineProperty(s,"name",{value:e});function i(a){
    let c;const l=n?.Parent?new s:this;
    r(l,a);
    (c=l._zod).deferred??(c.deferred=[]);
    for (const f of l._zod.deferred) {
      f();
    }return l
  }
  Object.defineProperty(i,"init",{value:r});

  Object.defineProperty(i,Symbol.hasInstance,{value:a => n?.Parent&&a instanceof n.Parent?true:a?._zod?.traits?.has(e)});

  Object.defineProperty(i,"name",{value:e});
  return i;
}class Uo extends Error{constructor(){super("Encountered Promise during synchronous parse. Use .parseAsync() instead.")}}class xv extends Error{constructor(t){
  super(`Encountered unidirectional transform during encode: ${t}`);
  this.name="ZodEncodeError";
}}const $v={};function ao(e){return $v}function yz(e){const t=Object.values(e).filter(r => typeof r=="number");return Object.entries(e).filter(([r,o]) => !t.includes(+r)).map(([r,o]) => o);}function Up(e,t){return typeof t=="bigint"?t.toString():t}function ih(e){return {get value() {{
  const t=e();
  Object.defineProperty(this,"value",{value:t});
  return t;
}}};}function ah(e){return e==null}function ch(e){
  const t=e.startsWith("^")?1:0;
  const n=e.endsWith("$")?e.length-1:e.length;
  return e.slice(t,n)
}function Oz(e,t){
  const n=(e.toString().split(".")[1]||"").length;
  const r=t.toString();
  let o=(r.split(".")[1]||"").length;if(o===0&&/\d?e-\d?/.test(r)){
  const c=r.match(/\d?e-(\d?)/);

  if (c?.[1]) {
    (o = Number.parseInt(c[1]));
  }
}
  const s=n>o?n:o;
  const i=Number.parseInt(e.toFixed(s).replace(".",""));
  const a=Number.parseInt(t.toFixed(s).replace(".",""));
  return i%a/10**s
}const $y=Symbol("evaluating");function ke(e,t,n){let r;Object.defineProperty(e,t,{get(){if (r!==$y) {
  if (r===void 0) {
    r=$y;
    r=n();
  }

  return r;
}},set(o){Object.defineProperty(e,t,{value:o})},configurable:true})}function Eo(e,t,n){Object.defineProperty(e,t,{value:n,writable:true,enumerable:true,configurable:true})}function ho(...e){const t={};for(const n of e){const r=Object.getOwnPropertyDescriptors(n);Object.assign(t,r)}return Object.defineProperties({},t)}function By(e){return JSON.stringify(e)}function bz(e){return e.toLowerCase().trim().replace(/[^\w\s-]/g,"").replace(/[\s_-]+/g,"-").replace(/^-+|-+$/g,"");}const Bv="captureStackTrace"in Error?Error.captureStackTrace:(...e)=>{};function Uu(e){return typeof e=="object"&&e!==null&&!Array.isArray(e)}const Cz=ih(()=>{if (typeof navigator !== "undefined"&&navigator?.userAgent?.includes("Cloudflare")) {
  return false;
}try{
  const e=Function;
  new e("");
  return true;
}catch{return false;}});function uc(e){if (Uu(e)===false) {
  return false;
}const t=e.constructor;if (t===void 0||typeof t!="function") {
  return true;
}const n=t.prototype;return !(Uu(n)===false||Object.prototype.hasOwnProperty.call(n,"isPrototypeOf")===false);}function Hv(e){return uc(e)?{...e}:Array.isArray(e)?[...e]:e}const Iz=new Set(["string","number","symbol"]);function Ll(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&");}function ir(e,t,n){
  const r=new e._zod.constr(t??e._zod.def);

  if ((!t || n?.parent)) {
    (r._zod.parent = e);
  }

  return r;
}function fe(e){
  const t=e;if (!t) {
    return{};
  }if (typeof t=="string") {
    return {error:() => t};
  }if(t?.message!==void 0){if (t?.error!==void 0) {
    throw new Error("Cannot specify both `message` and `error` params");
  }t.error=t.message}
  delete t.message;

  return typeof t.error=="string"?{...t,error:() => t.error}:t;
}function Pz(e){return Object.keys(e).filter(t => e[t]._zod.optin==="optional"&&e[t]._zod.optout==="optional");}const Mz={safeint:[Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER],int32:[-2147483648,2147483647],uint32:[0,4294967295],float32:[-3.4028234663852886e+38/* -34028234663852886e22 */,3.4028234663852886e+38/* 34028234663852886e22 */],float64:[-Number.MAX_VALUE,Number.MAX_VALUE]};function vz(e,t){
  const n=e._zod.def;

  const r=ho(e._zod.def,{get shape() {
    const o={};for(const s in t){
    if (!(s in n.shape)) {
        throw new Error(`Unrecognized key: "${s}"`);
      }

    if (t[s]) {
      (o[s] = n.shape[s]);
    }
  }
    Eo(this,"shape",o);
    return o;
  },checks:[]});

  return ir(e,r)
}function Lz(e,t){
  const n=e._zod.def;

  const r=ho(e._zod.def,{get shape() {
    const o={...e._zod.def.shape};for(const s in t){
    if (!(s in n.shape)) {
        throw new Error(`Unrecognized key: "${s}"`);
      }

    if (t[s]) {
      delete o[s];
    }
  }
    Eo(this,"shape",o);
    return o;
  },checks:[]});

  return ir(e,r)
}function wz(e,t){if (!uc(t)) {
  throw new Error("Invalid input to extend: expected a plain object");
}const n=e._zod.def.checks;if (n&&n.length>0) {
  throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
}const o=ho(e._zod.def,{get shape() {
  const s={...e._zod.def.shape,...t};
  Eo(this,"shape",s);
  return s;
},checks:[]});return ir(e,o)}function Dz(e,t){if (!uc(t)) {
  throw new Error("Invalid input to safeExtend: expected a plain object");
}const n={...e._zod.def,get shape() {
  const r={...e._zod.def.shape,...t};
  Eo(this,"shape",r);
  return r;
},checks:e._zod.def.checks};return ir(e,n)}function Uz(e,t){const n=ho(e._zod.def,{get shape() {
  const r={...e._zod.def.shape,...t._zod.def.shape};
  Eo(this,"shape",r);
  return r;
},get catchall() {return t._zod.def.catchall},checks:[]});return ir(e,n)}function kz(e,t,n){const r=ho(t._zod.def,{get shape() {
  const o=t._zod.def.shape;
  const s={...o};
  if (n) {
    for(const i in n){
      if (!(i in o)) {
        throw new Error(`Unrecognized key: "${i}"`);
      }

      if (n[i]) {
        (s[i] = e?new e({type:"optional",innerType:o[i]}):o[i]);
      }
    }
  } else {
    for (const i in o) {
      s[i]=e?new e({type:"optional",innerType:o[i]}):o[i];
    }
  }
  Eo(this,"shape",s);
  return s;
},checks:[]});return ir(t,r)}function Gz(e,t,n){const r=ho(t._zod.def,{get shape() {
  const o=t._zod.def.shape;
  const s={...o};
  if (n) {
    for(const i in n){
      if (!(i in s)) {
        throw new Error(`Unrecognized key: "${i}"`);
      }

      if (n[i]) {
        (s[i] = new e({type:"nonoptional",innerType:o[i]}));
      }
    }
  } else {
    for (const i in o) {
      s[i]=new e({type:"nonoptional",innerType:o[i]});
    }
  }
  Eo(this,"shape",s);
  return s;
},checks:[]});return ir(t,r)}function Co(e,t=0){if (e.aborted===true) {
  return true;
}for (let n=t; n<e.issues.length; n++) {
  if (e.issues[n]?.continue!==true) {
    return true;
  }
}return false;}function Fv(e,t){return t.map(n=>{
  let r;
  (r=n).path??(r.path=[]);
  n.path.unshift(e);
  return n;
});}function Yc(e){return typeof e=="string"?e:e?.message}function co(e,t,n){
  const r={...e,path:e.path??[]};if(!e.message){const o=Yc(e.inst?._zod.def?.error?.(e))??Yc(t?.error?.(e))??Yc(n.customError?.(e))??Yc(n.localeError?.(e))??"Invalid input";r.message=o}
  delete r.inst;
  delete r.continue;

  if (!t?.reportInput) {
    delete r.input;
  }

  return r;
}function uh(e){return Array.isArray(e)?"array":typeof e=="string"?"string":"unknown"}function lc(...e){const[t,n,r]=e;return typeof t=="string"?{message:t,code:"custom",input:n,inst:r}:{...t}}

const Yv=(e,t)=>{
  e.name="$ZodError";
  Object.defineProperty(e,"_zod",{value:e._zod,enumerable:false});
  Object.defineProperty(e,"issues",{value:t,enumerable:false});
  e.message=JSON.stringify(t,Up,2);

  Object.defineProperty(e,"toString",{value:() => e.message,enumerable:false});
};

const jv=W("$ZodError",Yv);
const qv=W("$ZodError",Yv,{Parent:Error});
function Vz(e,t=n => n.message){
  const n={};
  const r=[];
  for (const o of e.issues) {
    if (o.path.length>0) {
      n[o.path[0]]=n[o.path[0]]||[];
      n[o.path[0]].push(t(o));
    } else {
      r.push(t(o));
    }
  }return{formErrors:r,fieldErrors:n}
}function xz(e,t=n => n.message){
  const n={_errors:[]};

  const r=o=>{for (const s of o.issues) {
    if (s.code==="invalid_union"&&s.errors.length) {
      s.errors.map(i => r({issues:i}));
    } else if (s.code==="invalid_key") {
      r({issues:s.issues});
    } else if (s.code==="invalid_element") {
      r({issues:s.issues});
    } else if (s.path.length===0) {
      n._errors.push(t(s));
    } else {
      let i=n;
      let a=0;

      while (a<s.path.length) {
        const c=s.path[a];

        if (a===s.path.length-1) {
          i[c]=i[c]||{_errors:[]};
          i[c]._errors.push(t(s));
        } else {
          i[c]=i[c]||{_errors:[]};
        }

        i=i[c];
        a++;
      }
    }
  }};

  r(e);
  return n;
}

const lh=e => (t,n,r,o)=>{
  const s=r?Object.assign(r,{async:false}):{async:false};
  const i=t._zod.run({value:n,issues:[]},s);
  if (i instanceof Promise) {
    throw new Uo;
  }if(i.issues.length){
    const a=new(o?.Err??e)(i.issues.map(c => co(c,s,ao())));
    Bv(a,o?.callee);
    throw a;
  }return i.value
};

const dh=e => async(t,n,r,o)=>{
  const s=r?Object.assign(r,{async:true}):{async:true};let i=t._zod.run({value:n,issues:[]},s);

  if (i instanceof Promise) {
    (i = await i);
  }

  if (i.issues.length) {
    const a=new(o?.Err??e)(i.issues.map(c => co(c,s,ao())));
    Bv(a,o?.callee);
    throw a;
  }

  return i.value
};

const wl=e => (t,n,r)=>{
  const o=r?{...r,async:false}:{async:false};
  const s=t._zod.run({value:n,issues:[]},o);
  if (s instanceof Promise) {
    throw new Uo;
  }return s.issues.length?{success:false,error:new(e??jv)(s.issues.map(i => co(i,o,ao())))}:{success:true,data:s.value};
};

const $z=wl(qv);

const Dl=e => async(t,n,r)=>{
  const o=r?Object.assign(r,{async:true}):{async:true};let s=t._zod.run({value:n,issues:[]},o);

  if (s instanceof Promise) {
    (s = await s);
  }

  return s.issues.length?{success:false,error:new e(s.issues.map(i => co(i,o,ao())))}:{success:true,data:s.value};
};

const Bz=Dl(qv);

const Hz=e => (t,n,r)=>{const o=r?Object.assign(r,{direction:"backward"}):{direction:"backward"};return lh(e)(t,n,o)};

const Fz=e => (t, n, r) => lh(e)(t,n,r);

const Yz=e => async(t,n,r)=>{const o=r?Object.assign(r,{direction:"backward"}):{direction:"backward"};return dh(e)(t,n,o)};

const jz=e => async (t, n, r) => dh(e)(t,n,r);

const qz=e => (t,n,r)=>{const o=r?Object.assign(r,{direction:"backward"}):{direction:"backward"};return wl(e)(t,n,o)};

const Wz=e => (t, n, r) => wl(e)(t,n,r);

const Kz=e => async(t,n,r)=>{const o=r?Object.assign(r,{direction:"backward"}):{direction:"backward"};return Dl(e)(t,n,o)};

const zz=e => async (t, n, r) => Dl(e)(t,n,r);

const Zz=/^[cC][^\s-]{8,}$/;
const Xz=/^[0-9a-z]+$/;
const Qz=/^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
const Jz=/^[0-9a-vA-V]{20}$/;
const e3=/^[A-Za-z0-9]{27}$/;
const t3=/^[a-zA-Z0-9_-]{21}$/;
const n3=/^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
const r3=/^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;

const Hy=e => e?new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`):/^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;

const o3=/^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
const s3="^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function i3(){return new RegExp(s3,"u")}
const a3=/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const c3=/^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
const u3=/^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
const l3=/^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const d3=/^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
const Wv=/^[A-Za-z0-9_-]*$/;
const f3=/^\+(?:[0-9]){6,14}[0-9]$/;
const Kv="(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))";
const _3=new RegExp(`^${Kv}$`);
function zv(e){const t="(?:[01]\\d|2[0-3]):[0-5]\\d";return typeof e.precision=="number"?e.precision===-1?`${t}`:e.precision===0?`${t}:[0-5]\\d`:`${t}:[0-5]\\d\\.\\d{${e.precision}}`:`${t}(?::[0-5]\\d(?:\\.\\d+)?)?`}function p3(e){return new RegExp(`^${zv(e)}$`)}function E3(e){
  const t=zv({precision:e.precision});
  const n=["Z"];

  if (e.local) {
    n.push("");
  }

  if (e.offset) {
    n.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  }

  const r=`${t}(?:${n.join("|")})`;return new RegExp(`^${Kv}T(?:${r})$`)
}
const h3=e=>{const t=e?`[\\s\\S]{${e?.minimum??0},${e?.maximum??""}}`:"[\\s\\S]*";return new RegExp(`^${t}$`)};
const T3=/^-?\d+$/;
const S3=/^-?\d+(?:\.\d+)?/;
const m3=/^[^A-Z]*$/;
const A3=/^[^a-z]*$/;

const It=W("$ZodCheck",(e,t)=>{
  let n;
  e._zod??(e._zod={});
  e._zod.def=t;
  (n=e._zod).onattach??(n.onattach=[]);
});

const Zv={number:"number",bigint:"bigint",object:"date"};

const Xv=W("$ZodCheckLessThan",(e,t)=>{
  It.init(e,t);const n=Zv[typeof t.value];

  e._zod.onattach.push(r=>{
    const o=r._zod.bag;
    const s=(t.inclusive?o.maximum:o.exclusiveMaximum)??Number.POSITIVE_INFINITY;

    if (t.value<s) {
      if (t.inclusive) {
        o.maximum=t.value;
      } else {
        o.exclusiveMaximum=t.value;
      }
    }
  });

  e._zod.check=r=>{
    if (!t.inclusive ? r.value<t.value : r.value<=t.value) {
      r.issues.push({origin:n,code:"too_big",maximum:t.value,input:r.value,inclusive:t.inclusive,inst:e,continue:!t.abort});
    }
  };
});

const Qv=W("$ZodCheckGreaterThan",(e,t)=>{
  It.init(e,t);const n=Zv[typeof t.value];

  e._zod.onattach.push(r=>{
    const o=r._zod.bag;
    const s=(t.inclusive?o.minimum:o.exclusiveMinimum)??Number.NEGATIVE_INFINITY;

    if (t.value>s) {
      if (t.inclusive) {
        o.minimum=t.value;
      } else {
        o.exclusiveMinimum=t.value;
      }
    }
  });

  e._zod.check=r=>{
    if (!t.inclusive ? r.value>t.value : r.value>=t.value) {
      r.issues.push({origin:n,code:"too_small",minimum:t.value,input:r.value,inclusive:t.inclusive,inst:e,continue:!t.abort});
    }
  };
});

const g3=W("$ZodCheckMultipleOf",(e,t)=>{
  It.init(e,t);
  e._zod.onattach.push(n=>{let r;(r=n._zod.bag).multipleOf??(r.multipleOf=t.value);});

  e._zod.check=n=>{
    if (typeof n.value!=typeof t.value) {
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    }

    if (typeof n.value != "bigint" ? Oz(n.value,t.value)===0 : n.value%t.value===BigInt(0)) {
      n.issues.push({origin:typeof n.value,code:"not_multiple_of",divisor:t.value,input:n.value,inst:e,continue:!t.abort});
    }
  };
});

const R3=W("$ZodCheckNumberFormat",(e,t)=>{
  It.init(e,t);
  t.format=t.format||"float64";
  const n=t.format?.includes("int");
  const r=n?"int":"number";
  const [o,s]=Mz[t.format];

  e._zod.onattach.push(i=>{
    const a=i._zod.bag;
    a.format=t.format;
    a.minimum=o;
    a.maximum=s;

    if (n) {
      (a.pattern = T3);
    }
  });

  e._zod.check=i=>{
    const a=i.value;if(n){if(!Number.isInteger(a)){i.issues.push({expected:r,format:t.format,code:"invalid_type",continue:false,input:a,inst:e});return}if(!Number.isSafeInteger(a)){
      if (a>0) {
        i.issues.push({input:a,code:"too_big",maximum:Number.MAX_SAFE_INTEGER,note:"Integers must be within the safe integer range.",inst:e,origin:r,continue:!t.abort});
      } else {
        i.issues.push({input:a,code:"too_small",minimum:Number.MIN_SAFE_INTEGER,note:"Integers must be within the safe integer range.",inst:e,origin:r,continue:!t.abort});
      }

      return
    }}

    if (a<o) {
      i.issues.push({origin:"number",input:a,code:"too_small",minimum:o,inclusive:true,inst:e,continue:!t.abort});
    }

    if (a>s) {
      i.issues.push({origin:"number",input:a,code:"too_big",maximum:s,inst:e});
    }
  };
});

const N3=W("$ZodCheckMaxLength",(e,t)=>{
  let n;
  It.init(e,t);
  (n=e._zod.def).when??(n.when=r=>{const o=r.value;return!ah(o)&&o.length!==void 0});
  e._zod.onattach.push(r=>{
    const o=r._zod.bag.maximum??Number.POSITIVE_INFINITY;

    if (t.maximum<o) {
      (r._zod.bag.maximum = t.maximum);
    }
  });

  e._zod.check=r=>{const o=r.value;if (o.length<=t.maximum) {
    return;
  }const i=uh(o);r.issues.push({origin:i,code:"too_big",maximum:t.maximum,inclusive:true,input:o,inst:e,continue:!t.abort})};
});

const y3=W("$ZodCheckMinLength",(e,t)=>{
  let n;
  It.init(e,t);
  (n=e._zod.def).when??(n.when=r=>{const o=r.value;return!ah(o)&&o.length!==void 0});
  e._zod.onattach.push(r=>{
    const o=r._zod.bag.minimum??Number.NEGATIVE_INFINITY;

    if (t.minimum>o) {
      (r._zod.bag.minimum = t.minimum);
    }
  });

  e._zod.check=r=>{const o=r.value;if (o.length>=t.minimum) {
    return;
  }const i=uh(o);r.issues.push({origin:i,code:"too_small",minimum:t.minimum,inclusive:true,input:o,inst:e,continue:!t.abort})};
});

const O3=W("$ZodCheckLengthEquals",(e,t)=>{
  let n;
  It.init(e,t);
  (n=e._zod.def).when??(n.when=r=>{const o=r.value;return!ah(o)&&o.length!==void 0});

  e._zod.onattach.push(r=>{
    const o=r._zod.bag;
    o.minimum=t.length;
    o.maximum=t.length;
    o.length=t.length;
  });

  e._zod.check=r=>{
    const o=r.value;
    const s=o.length;
    if (s===t.length) {
      return;
    }
    const i=uh(o);
    const a=s>t.length;
    r.issues.push({origin:i,...(a ? {code:"too_big",maximum:t.length} : {code:"too_small",minimum:t.length}),inclusive:true,exact:true,input:r.value,inst:e,continue:!t.abort})
  };
});

const Ul=W("$ZodCheckStringFormat",(e,t)=>{
  let n;
  let r;
  It.init(e,t);

  e._zod.onattach.push(o=>{
    const s=o._zod.bag;
    s.format=t.format;

    if (t.pattern) {
      s.patterns??(s.patterns=new Set);
      s.patterns.add(t.pattern);
    }
  });

  if (t.pattern) {
    (n=e._zod).check??(n.check=o=>{
      t.pattern.lastIndex=0;

      if (!t.pattern.test(o.value)) {
        o.issues.push({origin:"string",code:"invalid_format",format:t.format,input:o.value,...(t.pattern ? {pattern:t.pattern.toString()} : {}),inst:e,continue:!t.abort});
      }
    });
  } else {
    (r=e._zod).check??(r.check=()=>{});
  }
});

const b3=W("$ZodCheckRegex",(e,t)=>{
  Ul.init(e,t);

  e._zod.check=n=>{
    t.pattern.lastIndex=0;

    if (!t.pattern.test(n.value)) {
      n.issues.push({origin:"string",code:"invalid_format",format:"regex",input:n.value,pattern:t.pattern.toString(),inst:e,continue:!t.abort});
    }
  };
});

const C3=W("$ZodCheckLowerCase",(e,t)=>{
  t.pattern??(t.pattern=m3);
  Ul.init(e,t);
});

const I3=W("$ZodCheckUpperCase",(e,t)=>{
  t.pattern??(t.pattern=A3);
  Ul.init(e,t);
});

const P3=W("$ZodCheckIncludes",(e,t)=>{
  It.init(e,t);
  const n=Ll(t.includes);
  const r=new RegExp(typeof t.position=="number"?`^.{${t.position}}${n}`:n);
  t.pattern=r;

  e._zod.onattach.push(o=>{
    const s=o._zod.bag;
    s.patterns??(s.patterns=new Set);
    s.patterns.add(r);
  });

  e._zod.check=o=>{
    if (!o.value.includes(t.includes,t.position)) {
      o.issues.push({origin:"string",code:"invalid_format",format:"includes",includes:t.includes,input:o.value,inst:e,continue:!t.abort});
    }
  };
});

const M3=W("$ZodCheckStartsWith",(e,t)=>{
  It.init(e,t);const n=new RegExp(`^${Ll(t.prefix)}.*`);
  t.pattern??(t.pattern=n);

  e._zod.onattach.push(r=>{
    const o=r._zod.bag;
    o.patterns??(o.patterns=new Set);
    o.patterns.add(n);
  });

  e._zod.check=r=>{
    if (!r.value.startsWith(t.prefix)) {
      r.issues.push({origin:"string",code:"invalid_format",format:"starts_with",prefix:t.prefix,input:r.value,inst:e,continue:!t.abort});
    }
  };
});

const v3=W("$ZodCheckEndsWith",(e,t)=>{
  It.init(e,t);const n=new RegExp(`.*${Ll(t.suffix)}$`);
  t.pattern??(t.pattern=n);

  e._zod.onattach.push(r=>{
    const o=r._zod.bag;
    o.patterns??(o.patterns=new Set);
    o.patterns.add(n);
  });

  e._zod.check=r=>{
    if (!r.value.endsWith(t.suffix)) {
      r.issues.push({origin:"string",code:"invalid_format",format:"ends_with",suffix:t.suffix,input:r.value,inst:e,continue:!t.abort});
    }
  };
});

const L3=W("$ZodCheckOverwrite",(e,t)=>{
  It.init(e,t);
  e._zod.check=n=>{n.value=t.tx(n.value)};
});

class w3{constructor(t=[]){
  this.content=[];
  this.indent=0;

  if (this) {
    (this.args = t);
  }
}indented(t){
  this.indent+=1;
  t(this);
  this.indent-=1;
}write(t){
  if(typeof t=="function"){
    t(this,{execution:"sync"});
    t(this,{execution:"async"});
    return
  }

  const r=t.split(`
  `).filter(i => i);

  const o=Math.min(...r.map(i => i.length-i.trimStart().length));

  const s=r.map(i => i.slice(o)).map(i => " ".repeat(this.indent*2)+i);

  for (const i of s) {
    this.content.push(i)
  }
}compile(){
  const t=Function;
  const n=this?.args;

  const o=[...(this?.content??[""]).map(s => `  ${s}`)];

  return new t(...n,o.join(`
  `))
}}
const D3={major:4,minor:1,patch:13};

const Xe=W("$ZodType",(e,t)=>{
  let n;
  e??(e={});
  e._zod.def=t;
  e._zod.bag=e._zod.bag||{};
  e._zod.version=D3;
  const r=[...(e._zod.def.checks ?? [])];

  if (e._zod.traits.has("$ZodCheck")) {
    r.unshift(e);
  }

  for (const o of r) {
      for (const s of o._zod.onattach) {
        s(e);
      }
    }if (r.length===0) {
      (n=e._zod).deferred??(n.deferred=[]);
      e._zod.deferred?.push(()=>{e._zod.run=e._zod.parse});
    } else {
      const o=(i,a,c)=>{
        let l=Co(i);
        let f;
        for(const d of a){
          if(d._zod.def.when){if (!d._zod.def.when(i)) {
            continue
          }}else if (l) {
            continue;
          }
          const u=i.issues.length;
          const _=d._zod.check(i);
          if (_ instanceof Promise&&c?.async===false) {
            throw new Uo;
          }if (f||_ instanceof Promise) {
            f=(f??Promise.resolve()).then(async()=>{
              await _;

              if (i.issues.length!==u) {
                if (!l) {
                  (l = Co(i,u));
                }
              }
            });
          } else {
          if (i.issues.length===u) {
              continue;
            }

          if (!l) {
            (l = Co(i,u));
          }
        }
        }return f?f.then(() => i):i;
      };

      const s=(i,a,c)=>{if (Co(i)) {
        i.aborted=true;
        return i;
      }const l=o(a,r,c);if(l instanceof Promise){if (c.async===false) {
        throw new Uo;
      }return l.then(f => e._zod.parse(f,c));}return e._zod.parse(l,c)};

      e._zod.run=(i,a)=>{if (a.skipChecks) {
        return e._zod.parse(i,a);
      }if(a.direction==="backward"){const l=e._zod.parse({value:i.value,issues:[]},{...a,skipChecks:true});return l instanceof Promise?l.then(f => s(f,i,a)):s(l,i,a);}const c=e._zod.parse(i,a);if(c instanceof Promise){if (a.async===false) {
        throw new Uo;
      }return c.then(l => o(l,r,a));}return o(c,r,a)}
    }e["~standard"]={validate:o=>{try{const s=$z(e,o);return s.success?{value:s.data}:{issues:s.error?.issues}}catch{return Bz(e,o).then(i => i.success?{value:i.data}:{issues:i.error?.issues});}},vendor:"zod",version:1}
});

const fh=W("$ZodString",(e,t)=>{
  Xe.init(e,t);
  e._zod.pattern=[...(e?._zod.bag?.patterns ?? [])].pop()??h3(e._zod.bag);

  e._zod.parse=(n,r)=>{
    if (t.coerce) {
      try{n.value=String(n.value)}catch{}
    }

    if (typeof n.value != "string") {
      n.issues.push({expected:"string",code:"invalid_type",input:n.value,inst:e});
    }

    return n;
  };
});

const $e=W("$ZodStringFormat",(e,t)=>{
  Ul.init(e,t);
  fh.init(e,t);
});

const U3=W("$ZodGUID",(e,t)=>{
  t.pattern??(t.pattern=r3);
  $e.init(e,t);
});

const k3=W("$ZodUUID",(e,t)=>{if (t.version) {const r={v1:1,v2:2,v3:3,v4:4,v5:5,v6:6,v7:7,v8:8}[t.version];if (r===void 0) {
  throw new Error(`Invalid UUID version: "${t.version}"`);
}t.pattern??(t.pattern=Hy(r));} else {
  t.pattern??(t.pattern=Hy());
}$e.init(e,t)});

const G3=W("$ZodEmail",(e,t)=>{
  t.pattern??(t.pattern=o3);
  $e.init(e,t);
});

const V3=W("$ZodURL",(e,t)=>{
  $e.init(e,t);

  e._zod.check=n=>{try{
    const r=n.value.trim();
    const o=new URL(r);

    if (t.hostname) {
      t.hostname.lastIndex=0;
      t.hostname.test(o.hostname)||n.issues.push({code:"invalid_format",format:"url",note:"Invalid hostname",pattern:t.hostname.source,input:n.value,inst:e,continue:!t.abort});
    }

    if (t.protocol) {
      t.protocol.lastIndex=0;
      t.protocol.test(o.protocol.endsWith(":")?o.protocol.slice(0,-1):o.protocol)||n.issues.push({code:"invalid_format",format:"url",note:"Invalid protocol",pattern:t.protocol.source,input:n.value,inst:e,continue:!t.abort});
    }

    if (t.normalize) {
      n.value=o.href;
    } else {
      n.value=r;
    }

    return
  }catch{n.issues.push({code:"invalid_format",format:"url",input:n.value,inst:e,continue:!t.abort})}};
});

const x3=W("$ZodEmoji",(e,t)=>{
  t.pattern??(t.pattern=i3());
  $e.init(e,t);
});

const $3=W("$ZodNanoID",(e,t)=>{
  t.pattern??(t.pattern=t3);
  $e.init(e,t);
});

const B3=W("$ZodCUID",(e,t)=>{
  t.pattern??(t.pattern=Zz);
  $e.init(e,t);
});

const H3=W("$ZodCUID2",(e,t)=>{
  t.pattern??(t.pattern=Xz);
  $e.init(e,t);
});

const F3=W("$ZodULID",(e,t)=>{
  t.pattern??(t.pattern=Qz);
  $e.init(e,t);
});

const Y3=W("$ZodXID",(e,t)=>{
  t.pattern??(t.pattern=Jz);
  $e.init(e,t);
});

const j3=W("$ZodKSUID",(e,t)=>{
  t.pattern??(t.pattern=e3);
  $e.init(e,t);
});

const q3=W("$ZodISODateTime",(e,t)=>{
  t.pattern??(t.pattern=E3(t));
  $e.init(e,t);
});

const W3=W("$ZodISODate",(e,t)=>{
  t.pattern??(t.pattern=_3);
  $e.init(e,t);
});

const K3=W("$ZodISOTime",(e,t)=>{
  t.pattern??(t.pattern=p3(t));
  $e.init(e,t);
});

const z3=W("$ZodISODuration",(e,t)=>{
  t.pattern??(t.pattern=n3);
  $e.init(e,t);
});

const Z3=W("$ZodIPv4",(e,t)=>{
  t.pattern??(t.pattern=a3);
  $e.init(e,t);
  e._zod.bag.format="ipv4";
});

const X3=W("$ZodIPv6",(e,t)=>{
  t.pattern??(t.pattern=c3);
  $e.init(e,t);
  e._zod.bag.format="ipv6";
  e._zod.check=n=>{try{new URL(`http://[${n.value}]`)}catch{n.issues.push({code:"invalid_format",format:"ipv6",input:n.value,inst:e,continue:!t.abort})}};
});

const Q3=W("$ZodCIDRv4",(e,t)=>{
  t.pattern??(t.pattern=u3);
  $e.init(e,t);
});

const J3=W("$ZodCIDRv6",(e,t)=>{
  t.pattern??(t.pattern=l3);
  $e.init(e,t);

  e._zod.check=n=>{const r=n.value.split("/");try{if (r.length!==2) {
    throw new Error;
  }const[o,s]=r;if (!s) {
    throw new Error;
  }const i=Number(s);if (`${i}`!==s) {
    throw new Error;
  }if (i<0||i>128) {
    throw new Error;
  }new URL(`http://[${o}]`)}catch{n.issues.push({code:"invalid_format",format:"cidrv6",input:n.value,inst:e,continue:!t.abort})}};
});

function Jv(e){if (e==="") {
  return true;
}if (e.length%4!==0) {
  return false;
}try{
  atob(e);
  return true;
}catch{return false;}}const eZ=W("$ZodBase64",(e,t)=>{
  t.pattern??(t.pattern=d3);
  $e.init(e,t);
  e._zod.bag.contentEncoding="base64";
  e._zod.check=n=>{
    if (!Jv(n.value)) {
      n.issues.push({code:"invalid_format",format:"base64",input:n.value,inst:e,continue:!t.abort});
    }
  };
});function tZ(e){
  if (!Wv.test(e)) {
    return false;
  }

  const t=e.replace(/[-_]/g,r => r==="-"?"+":"/");

  const n=t.padEnd(Math.ceil(t.length/4)*4,"=");
  return Jv(n)
}

const nZ=W("$ZodBase64URL",(e,t)=>{
  t.pattern??(t.pattern=Wv);
  $e.init(e,t);
  e._zod.bag.contentEncoding="base64url";
  e._zod.check=n=>{
    if (!tZ(n.value)) {
      n.issues.push({code:"invalid_format",format:"base64url",input:n.value,inst:e,continue:!t.abort});
    }
  };
});

const rZ=W("$ZodE164",(e,t)=>{
  t.pattern??(t.pattern=f3);
  $e.init(e,t);
});

function oZ(e,t=null){try{const n=e.split(".");if (n.length!==3) {
  return false;
}const[r]=n;if (!r) {
  return false;
}const o=JSON.parse(atob(r));return!("typ"in o&&o?.typ!=="JWT"||!o.alg||t&&(!("alg"in o)||o.alg!==t))}catch{return false;}}

const sZ=W("$ZodJWT",(e,t)=>{
  $e.init(e,t);
  e._zod.check=n=>{
    if (!oZ(n.value,t.alg)) {
      n.issues.push({code:"invalid_format",format:"jwt",input:n.value,inst:e,continue:!t.abort});
    }
  };
});

const eL=W("$ZodNumber",(e,t)=>{
  Xe.init(e,t);
  e._zod.pattern=e._zod.bag.pattern??S3;

  e._zod.parse=(n,r)=>{
    if (t.coerce) {
      try{n.value=Number(n.value)}catch{}
    }const o=n.value;if (typeof o=="number"&&!Number.isNaN(o)&&Number.isFinite(o)) {
      return n;
    }const s=typeof o=="number"?Number.isNaN(o)?"NaN":Number.isFinite(o)?void 0:"Infinity":void 0;
    n.issues.push({expected:"number",code:"invalid_type",input:o,inst:e,...(s ? {received:s} : {})});
    return n;
  };
});

const iZ=W("$ZodNumberFormat",(e,t)=>{
  R3.init(e,t);
  eL.init(e,t);
});

const aZ=W("$ZodUnknown",(e,t)=>{
  Xe.init(e,t);

  e._zod.parse=n => n;
});

const cZ=W("$ZodNever",(e,t)=>{
  Xe.init(e,t);

  e._zod.parse=(n, r) => {
    n.issues.push({expected:"never",code:"invalid_type",input:n.value,inst:e});
    return n;
  };
});

function Fy(e,t,n){
  if (e.issues.length) {
    t.issues.push(...Fv(n,e.issues));
  }

  t.value[n]=e.value;
}const uZ=W("$ZodArray",(e,t)=>{
  Xe.init(e,t);

  e._zod.parse=(n,r)=>{
    const o=n.value;if (!Array.isArray(o)) {
      n.issues.push({expected:"array",code:"invalid_type",input:o,inst:e});
      return n;
    }n.value=Array(o.length);const s=[];

    o.forEach((a, i) => {
      const c=t.element._zod.run({value:a,issues:[]},r);

      if (c instanceof Promise) {
        s.push(c.then(l => Fy(l,n,i)));
      } else {
        Fy(c,n,i);
      }
    });

    return s.length?Promise.all(s).then(() => n):n;
  };
});function ku(e,t,n,r){
  if (e.issues.length) {
    t.issues.push(...Fv(n,e.issues));
  }

  if (e.value===void 0) {
    if (n in r) {
      (t.value[n] = void 0);
    }
  } else {
    t.value[n]=e.value;
  }
}function tL(e){const t=Object.keys(e.shape);for (const r of t) {
  if (!e.shape?.[r]?._zod?.traits?.has("$ZodType")) {
    throw new Error(`Invalid element at key "${r}": expected a Zod schema`);
  }
}const n=Pz(e.shape);return{...e,keys:t,keySet:new Set(t),numKeys:t.length,optionalKeys:new Set(n)}}function nL(e,t,n,r,o,s){
  const i=[];
  const a=o.keySet;
  const c=o.catchall._zod;
  const l=c.def.type;
  for(const f in t){
    if (a.has(f)) {
      continue;
    }if(l==="never"){i.push(f);continue}const d=c.run({value:t[f],issues:[]},r);

    if (d instanceof Promise) {
      e.push(d.then(u => ku(u,n,f,t)));
    } else {
      ku(d,n,f,t);
    }
  }

  if (i.length) {
    n.issues.push({code:"unrecognized_keys",keys:i,input:t,inst:s});
  }

  return e.length?Promise.all(e).then(() => n):n;
}

const lZ=W("$ZodObject",(e,t)=>{
  Xe.init(e,t);

  if (!Object.getOwnPropertyDescriptor(t,"shape")?.get) {const a=t.shape;Object.defineProperty(t,"shape",{get:()=>{
    const c={...a};
    Object.defineProperty(t,"shape",{value:c});
    return c;
  }})}

  const r=ih(() => tL(t));ke(e._zod,"propValues",()=>{
    const a=t.shape;
    const c={};
    for(const l in a){const f=a[l]._zod;if(f.values){c[l]??(c[l]=new Set);for (const d of f.values) {
      c[l].add(d)
    }}}return c
  });
  const o=Uu;
  const s=t.catchall;
  let i;e._zod.parse=(a,c)=>{
    i??(i=r.value);const l=a.value;if (!o(l)) {
      a.issues.push({expected:"object",code:"invalid_type",input:l,inst:e});
      return a;
    }a.value={};
    const f=[];
    const d=i.shape;
    for(const u of i.keys){
      const p=d[u]._zod.run({value:l[u],issues:[]},c);

      if (p instanceof Promise) {
        f.push(p.then(E => ku(E,a,u,l)));
      } else {
        ku(p,a,u,l);
      }
    }return s?nL(f,l,a,c,r.value,e):f.length?Promise.all(f).then(() => a):a;
  }
});

const dZ=W("$ZodObjectJIT",(e,t)=>{
  lZ.init(e,t);
  const n=e._zod.parse;

  const r=ih(() => tL(t));

  const o=u=>{
    const _=new w3(["shape","payload","ctx"]);
    const p=r.value;
    const E=A=>{const g=By(A);return`shape[${g}]._zod.run({ value: input[${g}], issues: [] }, ctx)`};
    _.write("const input = payload.value;");const h=Object.create(null);let T=0;for (const A of p.keys) {
      h[A]=`key_${T++}`;
    }_.write("const newResult = {};");for(const A of p.keys){
      const g=h[A];
      const R=By(A);
      _.write(`const ${g} = ${E(A)};`);

      _.write(`
              if (${g}.issues.length) {
                payload.issues = payload.issues.concat(${g}.issues.map(iss => ({
                  ...iss,
                  path: iss.path ? [${R}, ...iss.path] : [${R}]
                })));
              }
              
              
              if (${g}.value === undefined) {
                if (${R} in input) {
                  newResult[${R}] = undefined;
                }
              } else {
                newResult[${R}] = ${g}.value;
              }
              
            `);
    }
    _.write("payload.value = newResult;");
    _.write("return payload;");
    const m=_.compile();return (A, g) => m(u,A,g);
  };

  let s;
  const i=Uu;
  const a=!$v.jitless;
  const l=a&&Cz.value;
  const f=t.catchall;
  let d;e._zod.parse=(u,_)=>{
  d??(d=r.value);
  const p=u.value;

  if (i(p)) {
    if (a&&l&&_?.async===false&&_.jitless!==true) {
      s||(s=o(t.shape));
      u=s(u,_);
      return f?nL([],p,u,_,d,e):u;
    }

    return n(u,_);
  }

  u.issues.push({expected:"object",code:"invalid_type",input:p,inst:e});
  return u;
}
});

function Yy(e,t,n,r){for (const s of e) {
  if (s.issues.length===0) {
    t.value=s.value;
    return t;
  }
}const o=e.filter(s => !Co(s));return o.length===1?(t.value=o[0].value,o[0]):(t.issues.push({code:"invalid_union",input:t.value,inst:n,errors:e.map(s => s.issues.map(i => co(i,r,ao())))}),t);}

const fZ=W("$ZodUnion",(e,t)=>{
  Xe.init(e,t);

  ke(e._zod,"optin",() => t.options.some(o => o._zod.optin==="optional")?"optional":void 0);

  ke(e._zod,"optout",() => t.options.some(o => o._zod.optout==="optional")?"optional":void 0);

  ke(e._zod,"values",()=>{if (t.options.every(o => o._zod.values)) {
    return new Set(t.options.flatMap(o => Array.from(o._zod.values)));
  }});

  ke(e._zod,"pattern",()=>{if(t.options.every(o => o._zod.pattern)){const o=t.options.map(s => s._zod.pattern);return new RegExp(`^(${o.map(s => ch(s.source)).join("|")})$`);}});

  const n=t.options.length===1;
  const r=t.options[0]._zod.run;
  e._zod.parse=(o,s)=>{if (n) {
    return r(o,s);
  }let i=false;const a=[];for(const c of t.options){const l=c._zod.run({value:o.value,issues:[]},s);if (l instanceof Promise) {
    a.push(l);
    i=true;
  } else {if (l.issues.length===0) {
    return l;
  }a.push(l)}}return i?Promise.all(a).then(c => Yy(c,o,e,s)):Yy(a,o,e,s);}
});

const _Z=W("$ZodIntersection",(e,t)=>{
  Xe.init(e,t);

  e._zod.parse=(n,r)=>{
    const o=n.value;
    const s=t.left._zod.run({value:o,issues:[]},r);
    const i=t.right._zod.run({value:o,issues:[]},r);
    return s instanceof Promise||i instanceof Promise?Promise.all([s,i]).then(([c,l]) => jy(n,c,l)):jy(n,s,i);
  };
});

function kp(e,t){if (e===t) {
  return {valid:true,data:e};
}if (e instanceof Date&&t instanceof Date&&+e==+t) {
  return {valid:true,data:e};
}if(uc(e)&&uc(t)){
  const n=Object.keys(t);

  const r=Object.keys(e).filter(s => n.includes(s));

  const o={...e,...t};
  for(const s of r){const i=kp(e[s],t[s]);if (!i.valid) {
    return {valid:false,mergeErrorPath:[s,...i.mergeErrorPath]};
  }o[s]=i.data}return {valid:true,data:o};
}if(Array.isArray(e)&&Array.isArray(t)){if (e.length!==t.length) {
  return {valid:false,mergeErrorPath:[]};
}const n=[];for(let r=0;r<e.length;r++){
  const o=e[r];
  const s=t[r];
  const i=kp(o,s);
  if (!i.valid) {
    return {valid:false,mergeErrorPath:[r,...i.mergeErrorPath]};
  }n.push(i.data)
}return {valid:true,data:n};}return {valid:false,mergeErrorPath:[]};}function jy(e,t,n){
  if (t.issues.length) {
    e.issues.push(...t.issues);
  }

  if (n.issues.length) {
    e.issues.push(...n.issues);
  }

  if (Co(e)) {
    return e;
  }

  const r=kp(t.value,n.value);if (!r.valid) {
      throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(r.mergeErrorPath)}`);
    }
  e.value=r.data;
  return e;
}

const pZ=W("$ZodEnum",(e,t)=>{
  Xe.init(e,t);
  const n=yz(t.entries);
  const r=new Set(n);
  e._zod.values=r;

  e._zod.pattern=new RegExp(`^(${n.filter(o => Iz.has(typeof o)).map(o => typeof o=="string"?Ll(o):o.toString()).join("|")})$`);

  e._zod.parse=(o,s)=>{
    const i=o.value;

    if (!r.has(i)) {
      o.issues.push({code:"invalid_value",values:n,input:i,inst:e});
    }

    return o;
  };
});

const EZ=W("$ZodTransform",(e,t)=>{
  Xe.init(e,t);

  e._zod.parse=(n,r)=>{
    if (r.direction==="backward") {
      throw new xv(e.constructor.name);
    }const o=t.transform(n.value,n);if (r.async) {
      return (o instanceof Promise?o:Promise.resolve(o)).then(i => {
        n.value=i;
        return n;
      });
    }if (o instanceof Promise) {
      throw new Uo;
    }
    n.value=o;
    return n;
  };
});

function qy(e,t){return e.issues.length&&t===void 0?{issues:[],value:void 0}:e}

const hZ=W("$ZodOptional",(e,t)=>{
  Xe.init(e,t);
  e._zod.optin="optional";
  e._zod.optout="optional";

  ke(e._zod,"values",() => t.innerType._zod.values?new Set([...t.innerType._zod.values,void 0]):void 0);

  ke(e._zod,"pattern",()=>{const n=t.innerType._zod.pattern;return n?new RegExp(`^(${ch(n.source)})?$`):void 0});

  e._zod.parse=(n,r)=>{if(t.innerType._zod.optin==="optional"){const o=t.innerType._zod.run(n,r);return o instanceof Promise?o.then(s => qy(s,n.value)):qy(o,n.value);}return n.value===void 0?n:t.innerType._zod.run(n,r)};
});

const TZ=W("$ZodNullable",(e,t)=>{
  Xe.init(e,t);

  ke(e._zod,"optin",() => t.innerType._zod.optin);

  ke(e._zod,"optout",() => t.innerType._zod.optout);

  ke(e._zod,"pattern",()=>{const n=t.innerType._zod.pattern;return n?new RegExp(`^(${ch(n.source)}|null)$`):void 0});

  ke(e._zod,"values",() => t.innerType._zod.values?new Set([...t.innerType._zod.values,null]):void 0);

  e._zod.parse=(n, r) => n.value===null?n:t.innerType._zod.run(n,r);
});

const SZ=W("$ZodDefault",(e,t)=>{
  Xe.init(e,t);
  e._zod.optin="optional";

  ke(e._zod,"values",() => t.innerType._zod.values);

  e._zod.parse=(n,r)=>{if (r.direction==="backward") {
    return t.innerType._zod.run(n,r);
  }if (n.value===void 0) {
    n.value=t.defaultValue;
    return n;
  }const o=t.innerType._zod.run(n,r);return o instanceof Promise?o.then(s => Wy(s,t)):Wy(o,t);};
});

function Wy(e,t){
  if (e.value===void 0) {
    (e.value = t.defaultValue);
  }

  return e;
}

const mZ=W("$ZodPrefault",(e,t)=>{
  Xe.init(e,t);
  e._zod.optin="optional";

  ke(e._zod,"values",() => t.innerType._zod.values);

  e._zod.parse=(n, r) => {
    if (r.direction !== "backward") {
      if (n.value===void 0) {
        (n.value = t.defaultValue);
      }
    }

    return t.innerType._zod.run(n,r);
  };
});

const AZ=W("$ZodNonOptional",(e,t)=>{
  Xe.init(e,t);

  ke(e._zod,"values",()=>{const n=t.innerType._zod.values;return n?new Set([...n].filter(r => r!==void 0)):void 0;});

  e._zod.parse=(n,r)=>{const o=t.innerType._zod.run(n,r);return o instanceof Promise?o.then(s => Ky(s,e)):Ky(o,e);};
});

function Ky(e,t){
  if (!e.issues.length&&e.value===void 0) {
    e.issues.push({code:"invalid_type",expected:"nonoptional",input:e.value,inst:t});
  }

  return e;
}

const gZ=W("$ZodCatch",(e,t)=>{
  Xe.init(e,t);

  ke(e._zod,"optin",() => t.innerType._zod.optin);

  ke(e._zod,"optout",() => t.innerType._zod.optout);

  ke(e._zod,"values",() => t.innerType._zod.values);

  e._zod.parse=(n,r)=>{if (r.direction==="backward") {
    return t.innerType._zod.run(n,r);
  }const o=t.innerType._zod.run(n,r);return o instanceof Promise?o.then(s => {
    n.value=s.value;

    if (s.issues.length) {
      n.value=t.catchValue({...n,error:{issues:s.issues.map(i => co(i,r,ao()))},input:n.value});
      n.issues=[];
    }

    return n;
  }):(n.value=o.value,o.issues.length&&(n.value=t.catchValue({...n,error:{issues:o.issues.map(s => co(s,r,ao()))},input:n.value}),n.issues=[]),n);};
});

const RZ=W("$ZodPipe",(e,t)=>{
  Xe.init(e,t);

  ke(e._zod,"values",() => t.in._zod.values);

  ke(e._zod,"optin",() => t.in._zod.optin);

  ke(e._zod,"optout",() => t.out._zod.optout);

  ke(e._zod,"propValues",() => t.in._zod.propValues);

  e._zod.parse=(n,r)=>{if(r.direction==="backward"){const s=t.out._zod.run(n,r);return s instanceof Promise?s.then(i => jc(i,t.in,r)):jc(s,t.in,r);}const o=t.in._zod.run(n,r);return o instanceof Promise?o.then(s => jc(s,t.out,r)):jc(o,t.out,r);};
});

function jc(e,t,n){return e.issues.length?(e.aborted=true,e):t._zod.run({value:e.value,issues:e.issues},n);}const NZ=W("$ZodReadonly",(e,t)=>{
  Xe.init(e,t);

  ke(e._zod,"propValues",() => t.innerType._zod.propValues);

  ke(e._zod,"values",() => t.innerType._zod.values);

  ke(e._zod,"optin",() => t.innerType?._zod?.optin);

  ke(e._zod,"optout",() => t.innerType?._zod?.optout);

  e._zod.parse=(n,r)=>{if (r.direction==="backward") {
    return t.innerType._zod.run(n,r);
  }const o=t.innerType._zod.run(n,r);return o instanceof Promise?o.then(zy):zy(o)};
});function zy(e){
  e.value=Object.freeze(e.value);
  return e;
}const yZ=W("$ZodCustom",(e,t)=>{
  It.init(e,t);
  Xe.init(e,t);

  e._zod.parse=(n, r) => n;

  e._zod.check=n=>{
    const r=n.value;
    const o=t.fn(r);
    if (o instanceof Promise) {
      return o.then(s => Zy(s,n,r,e));
    }Zy(o,n,r,e)
  };
});function Zy(e,t,n,r){if(!e){
  const o={code:"custom",input:n,inst:r,path:[...(r._zod.def.path ?? [])],continue:!r._zod.def.abort};

  if (r._zod.def.params) {
    (o.params = r._zod.def.params);
  }

  t.issues.push(lc(o));
}}let Xy;class OZ{constructor(){
  this._map=new WeakMap;
  this._idmap=new Map;
}add(t,...n){
  const r=n[0];
  this._map.set(t,r);

  if (r&&typeof r=="object"&&"id"in r) {if (this._idmap.has(r.id)) {
    throw new Error(`ID ${r.id} already exists in the registry`);
  }this._idmap.set(r.id,t)}

  return this
}clear(){
  this._map=new WeakMap;
  this._idmap=new Map;
  return this;
}remove(t){
  const n=this._map.get(t);

  if (n&&typeof n=="object"&&"id"in n) {
    this._idmap.delete(n.id);
  }

  this._map.delete(t);
  return this;
}get(t){const n=t._zod.parent;if(n){const r={...(this.get(n) ?? {})};delete r.id;const o={...r,...this._map.get(t)};return Object.keys(o).length?o:void 0}return this._map.get(t)}has(t){return this._map.has(t)}}function bZ(){return new OZ}
(Xy=globalThis).__zod_globalRegistry??(Xy.__zod_globalRegistry=bZ());
const qc=globalThis.__zod_globalRegistry;function CZ(e,t){return new e({type:"string",...fe(t)})}function IZ(e,t){return new e({type:"string",format:"email",check:"string_format",abort:false,...fe(t)});}function Qy(e,t){return new e({type:"string",format:"guid",check:"string_format",abort:false,...fe(t)});}function PZ(e,t){return new e({type:"string",format:"uuid",check:"string_format",abort:false,...fe(t)});}function MZ(e,t){return new e({type:"string",format:"uuid",check:"string_format",abort:false,version:"v4",...fe(t)});}function vZ(e,t){return new e({type:"string",format:"uuid",check:"string_format",abort:false,version:"v6",...fe(t)});}function LZ(e,t){return new e({type:"string",format:"uuid",check:"string_format",abort:false,version:"v7",...fe(t)});}function wZ(e,t){return new e({type:"string",format:"url",check:"string_format",abort:false,...fe(t)});}function DZ(e,t){return new e({type:"string",format:"emoji",check:"string_format",abort:false,...fe(t)});}function UZ(e,t){return new e({type:"string",format:"nanoid",check:"string_format",abort:false,...fe(t)});}function kZ(e,t){return new e({type:"string",format:"cuid",check:"string_format",abort:false,...fe(t)});}function GZ(e,t){return new e({type:"string",format:"cuid2",check:"string_format",abort:false,...fe(t)});}function VZ(e,t){return new e({type:"string",format:"ulid",check:"string_format",abort:false,...fe(t)});}function xZ(e,t){return new e({type:"string",format:"xid",check:"string_format",abort:false,...fe(t)});}function $Z(e,t){return new e({type:"string",format:"ksuid",check:"string_format",abort:false,...fe(t)});}function BZ(e,t){return new e({type:"string",format:"ipv4",check:"string_format",abort:false,...fe(t)});}function HZ(e,t){return new e({type:"string",format:"ipv6",check:"string_format",abort:false,...fe(t)});}function FZ(e,t){return new e({type:"string",format:"cidrv4",check:"string_format",abort:false,...fe(t)});}function YZ(e,t){return new e({type:"string",format:"cidrv6",check:"string_format",abort:false,...fe(t)});}function jZ(e,t){return new e({type:"string",format:"base64",check:"string_format",abort:false,...fe(t)});}function qZ(e,t){return new e({type:"string",format:"base64url",check:"string_format",abort:false,...fe(t)});}function WZ(e,t){return new e({type:"string",format:"e164",check:"string_format",abort:false,...fe(t)});}function KZ(e,t){return new e({type:"string",format:"jwt",check:"string_format",abort:false,...fe(t)});}function zZ(e,t){return new e({type:"string",format:"datetime",check:"string_format",offset:false,local:false,precision:null,...fe(t)});}function ZZ(e,t){return new e({type:"string",format:"date",check:"string_format",...fe(t)})}function XZ(e,t){return new e({type:"string",format:"time",check:"string_format",precision:null,...fe(t)})}function QZ(e,t){return new e({type:"string",format:"duration",check:"string_format",...fe(t)})}function JZ(e,t){return new e({type:"number",checks:[],...fe(t)})}function e4(e,t){return new e({type:"number",check:"number_format",abort:false,format:"safeint",...fe(t)});}function t4(e){return new e({type:"unknown"})}function n4(e,t){return new e({type:"never",...fe(t)})}function Jy(e,t){return new Xv({check:"less_than",...fe(t),value:e,inclusive:false});}function gf(e,t){return new Xv({check:"less_than",...fe(t),value:e,inclusive:true});}function eO(e,t){return new Qv({check:"greater_than",...fe(t),value:e,inclusive:false});}function Rf(e,t){return new Qv({check:"greater_than",...fe(t),value:e,inclusive:true});}function tO(e,t){return new g3({check:"multiple_of",...fe(t),value:e})}function rL(e,t){return new N3({check:"max_length",...fe(t),maximum:e})}function Gu(e,t){return new y3({check:"min_length",...fe(t),minimum:e})}function oL(e,t){return new O3({check:"length_equals",...fe(t),length:e})}function r4(e,t){return new b3({check:"string_format",format:"regex",...fe(t),pattern:e})}function o4(e){return new C3({check:"string_format",format:"lowercase",...fe(e)})}function s4(e){return new I3({check:"string_format",format:"uppercase",...fe(e)})}function i4(e,t){return new P3({check:"string_format",format:"includes",...fe(t),includes:e})}function a4(e,t){return new M3({check:"string_format",format:"starts_with",...fe(t),prefix:e})}function c4(e,t){return new v3({check:"string_format",format:"ends_with",...fe(t),suffix:e})}function ns(e){return new L3({check:"overwrite",tx:e})}function u4(e){return ns(t => t.normalize(e));}function l4(){return ns(e => e.trim());}function d4(){return ns(e => e.toLowerCase());}function f4(){return ns(e => e.toUpperCase());}function _4(){return ns(e => bz(e));}function p4(e,t,n){return new e({type:"array",element:t,...fe(n)})}function E4(e,t,n){return new e({type:"custom",check:"custom",fn:t,...fe(n)})}function h4(e){const t=T4(n => {
  n.addIssue=r=>{if (typeof r=="string") {
    n.issues.push(lc(r,n.value,t._zod.def));
  } else {
    const o=r;

    if (o.fatal) {
      (o.continue = false);
    }

    o.code??(o.code="custom");
    o.input??(o.input=n.value);
    o.inst??(o.inst=t);
    o.continue??(o.continue=!t._zod.def.abort);
    n.issues.push(lc(o));
  }};

  return e(n.value,n);
});return t}function T4(e,t){
  const n=new It({check:"custom",...fe(t)});
  n._zod.check=e;
  return n;
}const S4=W("ZodISODateTime",(e,t)=>{
  q3.init(e,t);
  Ye.init(e,t);
});function m4(e){return zZ(S4,e)}const A4=W("ZodISODate",(e,t)=>{
  W3.init(e,t);
  Ye.init(e,t);
});function g4(e){return ZZ(A4,e)}const R4=W("ZodISOTime",(e,t)=>{
  K3.init(e,t);
  Ye.init(e,t);
});function N4(e){return XZ(R4,e)}const y4=W("ZodISODuration",(e,t)=>{
  z3.init(e,t);
  Ye.init(e,t);
});function O4(e){return QZ(y4,e)}

const b4=(e,t)=>{
  jv.init(e,t);
  e.name="ZodError";

  Object.defineProperties(e,{format:{value:n => xz(e,n)},flatten:{value:n => Vz(e,n)},addIssue:{value:n=>{
    e.issues.push(n);
    e.message=JSON.stringify(e.issues,Up,2);
  }},addIssues:{value:n=>{
    e.issues.push(...n);
    e.message=JSON.stringify(e.issues,Up,2);
  }},isEmpty:{get(){return e.issues.length===0}}});
};

const Zt=W("ZodError",b4,{Parent:Error});
const C4=lh(Zt);
const I4=dh(Zt);
const P4=wl(Zt);
const M4=Dl(Zt);
const v4=Hz(Zt);
const L4=Fz(Zt);
const w4=Yz(Zt);
const D4=jz(Zt);
const U4=qz(Zt);
const k4=Wz(Zt);
const G4=Kz(Zt);
const V4=zz(Zt);

const tt=W("ZodType",(e, t) => {
  Xe.init(e,t);
  e.def=t;
  e.type=t.type;
  Object.defineProperty(e,"_def",{value:t});

  e.check=(...n) => e.clone(ho(t,{checks:[...(t.checks ?? []),...n.map(r => typeof r=="function"?{_zod:{check:r,def:{check:"custom"},onattach:[]}}:r)]}));

  e.clone=(n, r) => ir(e,n,r);

  e.brand=() => e;

  e.register=((n, r) => {
    n.add(e,r);
    return e;
  });

  e.parse=(n, r) => C4(e,n,r,{callee:e.parse});

  e.safeParse=(n, r) => P4(e,n,r);

  e.parseAsync=async (n, r) => I4(e,n,r,{callee:e.parseAsync});

  e.safeParseAsync=async (n, r) => M4(e,n,r);

  e.spa=e.safeParseAsync;

  e.encode=(n, r) => v4(e,n,r);

  e.decode=(n, r) => L4(e,n,r);

  e.encodeAsync=async (n, r) => w4(e,n,r);

  e.decodeAsync=async (n, r) => D4(e,n,r);

  e.safeEncode=(n, r) => U4(e,n,r);

  e.safeDecode=(n, r) => k4(e,n,r);

  e.safeEncodeAsync=async (n, r) => G4(e,n,r);

  e.safeDecodeAsync=async (n, r) => V4(e,n,r);

  e.refine=(n, r) => e.check(C9(n,r));

  e.superRefine=n => e.check(I9(n));

  e.overwrite=n => e.check(ns(n));

  e.optional=() => sO(e);

  e.nullable=() => iO(e);

  e.nullish=() => sO(iO(e));

  e.nonoptional=n => A9(e,n);

  e.array=() => kl(e);

  e.or=n => l9([e,n]);

  e.and=n => f9(e,n);

  e.transform=n => aO(e,p9(n));

  e.default=n => T9(e,n);

  e.prefault=n => m9(e,n);

  e.catch=n => R9(e,n);

  e.pipe=n => aO(e,n);

  e.readonly=() => O9(e);

  e.describe=n=>{
    const r=e.clone();
    qc.add(r,{description:n});
    return r;
  };

  Object.defineProperty(e,"description",{get(){return qc.get(e)?.description},configurable:true});

  e.meta=(...n)=>{
    if (n.length===0) {
      return qc.get(e);
    }const r=e.clone();
    qc.add(r,n[0]);
    return r;
  };

  e.isOptional=() => e.safeParse(void 0).success;

  e.isNullable=() => e.safeParse(null).success;

  return e;
});

const sL=W("_ZodString",(e,t)=>{
  fh.init(e,t);
  tt.init(e,t);
  const n=e._zod.bag;
  e.format=n.format??null;
  e.minLength=n.minimum??null;
  e.maxLength=n.maximum??null;

  e.regex=(...r) => e.check(r4(...r));

  e.includes=(...r) => e.check(i4(...r));

  e.startsWith=(...r) => e.check(a4(...r));

  e.endsWith=(...r) => e.check(c4(...r));

  e.min=(...r) => e.check(Gu(...r));

  e.max=(...r) => e.check(rL(...r));

  e.length=(...r) => e.check(oL(...r));

  e.nonempty=(...r) => e.check(Gu(1,...r));

  e.lowercase=r => e.check(o4(r));

  e.uppercase=r => e.check(s4(r));

  e.trim=() => e.check(l4());

  e.normalize=(...r) => e.check(u4(...r));

  e.toLowerCase=() => e.check(d4());

  e.toUpperCase=() => e.check(f4());

  e.slugify=() => e.check(_4());
});

const x4=W("ZodString",(e,t)=>{
  fh.init(e,t);
  sL.init(e,t);

  e.email=n => e.check(IZ($4,n));

  e.url=n => e.check(wZ(B4,n));

  e.jwt=n => e.check(KZ(n9,n));

  e.emoji=n => e.check(DZ(H4,n));

  e.guid=n => e.check(Qy(nO,n));

  e.uuid=n => e.check(PZ(Wc,n));

  e.uuidv4=n => e.check(MZ(Wc,n));

  e.uuidv6=n => e.check(vZ(Wc,n));

  e.uuidv7=n => e.check(LZ(Wc,n));

  e.nanoid=n => e.check(UZ(F4,n));

  e.guid=n => e.check(Qy(nO,n));

  e.cuid=n => e.check(kZ(Y4,n));

  e.cuid2=n => e.check(GZ(j4,n));

  e.ulid=n => e.check(VZ(q4,n));

  e.base64=n => e.check(jZ(J4,n));

  e.base64url=n => e.check(qZ(e9,n));

  e.xid=n => e.check(xZ(W4,n));

  e.ksuid=n => e.check($Z(K4,n));

  e.ipv4=n => e.check(BZ(z4,n));

  e.ipv6=n => e.check(HZ(Z4,n));

  e.cidrv4=n => e.check(FZ(X4,n));

  e.cidrv6=n => e.check(YZ(Q4,n));

  e.e164=n => e.check(WZ(t9,n));

  e.datetime=n => e.check(m4(n));

  e.date=n => e.check(g4(n));

  e.time=n => e.check(N4(n));

  e.duration=n => e.check(O4(n));
});

function dt(e){return CZ(x4,e)}

const Ye=W("ZodStringFormat",(e,t)=>{
  $e.init(e,t);
  sL.init(e,t);
});

const $4=W("ZodEmail",(e,t)=>{
  G3.init(e,t);
  Ye.init(e,t);
});

const nO=W("ZodGUID",(e,t)=>{
  U3.init(e,t);
  Ye.init(e,t);
});

const Wc=W("ZodUUID",(e,t)=>{
  k3.init(e,t);
  Ye.init(e,t);
});

const B4=W("ZodURL",(e,t)=>{
  V3.init(e,t);
  Ye.init(e,t);
});

const H4=W("ZodEmoji",(e,t)=>{
  x3.init(e,t);
  Ye.init(e,t);
});

const F4=W("ZodNanoID",(e,t)=>{
  $3.init(e,t);
  Ye.init(e,t);
});

const Y4=W("ZodCUID",(e,t)=>{
  B3.init(e,t);
  Ye.init(e,t);
});

const j4=W("ZodCUID2",(e,t)=>{
  H3.init(e,t);
  Ye.init(e,t);
});

const q4=W("ZodULID",(e,t)=>{
  F3.init(e,t);
  Ye.init(e,t);
});

const W4=W("ZodXID",(e,t)=>{
  Y3.init(e,t);
  Ye.init(e,t);
});

const K4=W("ZodKSUID",(e,t)=>{
  j3.init(e,t);
  Ye.init(e,t);
});

const z4=W("ZodIPv4",(e,t)=>{
  Z3.init(e,t);
  Ye.init(e,t);
});

const Z4=W("ZodIPv6",(e,t)=>{
  X3.init(e,t);
  Ye.init(e,t);
});

const X4=W("ZodCIDRv4",(e,t)=>{
  Q3.init(e,t);
  Ye.init(e,t);
});

const Q4=W("ZodCIDRv6",(e,t)=>{
  J3.init(e,t);
  Ye.init(e,t);
});

const J4=W("ZodBase64",(e,t)=>{
  eZ.init(e,t);
  Ye.init(e,t);
});

const e9=W("ZodBase64URL",(e,t)=>{
  nZ.init(e,t);
  Ye.init(e,t);
});

const t9=W("ZodE164",(e,t)=>{
  rZ.init(e,t);
  Ye.init(e,t);
});

const n9=W("ZodJWT",(e,t)=>{
  sZ.init(e,t);
  Ye.init(e,t);
});

const iL=W("ZodNumber",(e,t)=>{
  eL.init(e,t);
  tt.init(e,t);

  e.gt=(r, o) => e.check(eO(r,o));

  e.gte=(r, o) => e.check(Rf(r,o));

  e.min=(r, o) => e.check(Rf(r,o));

  e.lt=(r, o) => e.check(Jy(r,o));

  e.lte=(r, o) => e.check(gf(r,o));

  e.max=(r, o) => e.check(gf(r,o));

  e.int=r => e.check(rO(r));

  e.safe=r => e.check(rO(r));

  e.positive=r => e.check(eO(0,r));

  e.nonnegative=r => e.check(Rf(0,r));

  e.negative=r => e.check(Jy(0,r));

  e.nonpositive=r => e.check(gf(0,r));

  e.multipleOf=(r, o) => e.check(tO(r,o));

  e.step=(r, o) => e.check(tO(r,o));

  e.finite=() => e;

  const n=e._zod.bag;
  e.minValue=Math.max(n.minimum??Number.NEGATIVE_INFINITY,n.exclusiveMinimum??Number.NEGATIVE_INFINITY)??null;
  e.maxValue=Math.min(n.maximum??Number.POSITIVE_INFINITY,n.exclusiveMaximum??Number.POSITIVE_INFINITY)??null;
  e.isInt=(n.format??"").includes("int")||Number.isSafeInteger(n.multipleOf??0.5/* .5 */);
  e.isFinite=true;
  e.format=n.format??null;
});

function Za(e){return JZ(iL,e)}const r9=W("ZodNumberFormat",(e,t)=>{
  iZ.init(e,t);
  iL.init(e,t);
});function rO(e){return e4(r9,e)}const o9=W("ZodUnknown",(e,t)=>{
  aZ.init(e,t);
  tt.init(e,t);
});function oO(){return t4(o9)}const s9=W("ZodNever",(e,t)=>{
  cZ.init(e,t);
  tt.init(e,t);
});function i9(e){return n4(s9,e)}const a9=W("ZodArray",(e,t)=>{
  uZ.init(e,t);
  tt.init(e,t);
  e.element=t.element;

  e.min=(n, r) => e.check(Gu(n,r));

  e.nonempty=n => e.check(Gu(1,n));

  e.max=(n, r) => e.check(rL(n,r));

  e.length=(n, r) => e.check(oL(n,r));

  e.unwrap=() => e.element;
});function kl(e,t){return p4(a9,e,t)}const c9=W("ZodObject",(e,t)=>{
  dZ.init(e,t);
  tt.init(e,t);

  ke(e,"shape",() => t.shape);

  e.keyof=() => Vu(Object.keys(e._zod.def.shape));

  e.catchall=n => e.clone({...e._zod.def,catchall:n});

  e.passthrough=() => e.clone({...e._zod.def,catchall:oO()});

  e.loose=() => e.clone({...e._zod.def,catchall:oO()});

  e.strict=() => e.clone({...e._zod.def,catchall:i9()});

  e.strip=() => e.clone({...e._zod.def,catchall:void 0});

  e.extend=n => wz(e,n);

  e.safeExtend=n => Dz(e,n);

  e.merge=n => Uz(e,n);

  e.pick=n => vz(e,n);

  e.omit=n => Lz(e,n);

  e.partial=(...n) => kz(aL,e,n[0]);

  e.required=(...n) => Gz(cL,e,n[0]);
});function ar(e,t){const n={type:"object",shape:e??{},...fe(t)};return new c9(n)}const u9=W("ZodUnion",(e,t)=>{
  fZ.init(e,t);
  tt.init(e,t);
  e.options=t.options;
});function l9(e,t){return new u9({type:"union",options:e,...fe(t)})}const d9=W("ZodIntersection",(e,t)=>{
  _Z.init(e,t);
  tt.init(e,t);
});function f9(e,t){return new d9({type:"intersection",left:e,right:t})}const Gp=W("ZodEnum",(e,t)=>{
  pZ.init(e,t);
  tt.init(e,t);
  e.enum=t.entries;
  e.options=Object.values(t.entries);
  const n=new Set(Object.keys(t.entries));

  e.extract=(r,o)=>{const s={};for (const i of r) {
    if (n.has(i)) {
      s[i]=t.entries[i];
    } else {
      throw new Error(`Key ${i} not found in enum`);
    }
  }return new Gp({...t,checks:[],...fe(o),entries:s})};

  e.exclude=(r,o)=>{const s={...t.entries};for (const i of r) {
    if (n.has(i)) {
      delete s[i];
    } else {
      throw new Error(`Key ${i} not found in enum`);
    }
  }return new Gp({...t,checks:[],...fe(o),entries:s})};
});function Vu(e,t){const n=Array.isArray(e)?Object.fromEntries(e.map(r => [r,r])):e;return new Gp({type:"enum",entries:n,...fe(t)})}const _9=W("ZodTransform",(e,t)=>{
  EZ.init(e,t);
  tt.init(e,t);

  e._zod.parse=(n,r)=>{if (r.direction==="backward") {
    throw new xv(e.constructor.name);
  }n.addIssue=s=>{if (typeof s=="string") {
    n.issues.push(lc(s,n.value,t));
  } else {
    const i=s;

    if (i.fatal) {
      (i.continue = false);
    }

    i.code??(i.code="custom");
    i.input??(i.input=n.value);
    i.inst??(i.inst=e);
    n.issues.push(lc(i));
  }};const o=t.transform(n.value,n);return o instanceof Promise?o.then(s => {
    n.value=s;
    return n;
  }):(n.value=o,n);};
});function p9(e){return new _9({type:"transform",transform:e})}const aL=W("ZodOptional",(e,t)=>{
  hZ.init(e,t);
  tt.init(e,t);

  e.unwrap=() => e._zod.def.innerType;
});function sO(e){return new aL({type:"optional",innerType:e})}const E9=W("ZodNullable",(e,t)=>{
  TZ.init(e,t);
  tt.init(e,t);

  e.unwrap=() => e._zod.def.innerType;
});function iO(e){return new E9({type:"nullable",innerType:e})}const h9=W("ZodDefault",(e,t)=>{
  SZ.init(e,t);
  tt.init(e,t);

  e.unwrap=() => e._zod.def.innerType;

  e.removeDefault=e.unwrap;
});function T9(e,t){return new h9({type:"default",innerType:e,get defaultValue() {return typeof t=="function"?t():Hv(t)}});}const S9=W("ZodPrefault",(e,t)=>{
  mZ.init(e,t);
  tt.init(e,t);

  e.unwrap=() => e._zod.def.innerType;
});function m9(e,t){return new S9({type:"prefault",innerType:e,get defaultValue() {return typeof t=="function"?t():Hv(t)}});}const cL=W("ZodNonOptional",(e,t)=>{
  AZ.init(e,t);
  tt.init(e,t);

  e.unwrap=() => e._zod.def.innerType;
});function A9(e,t){return new cL({type:"nonoptional",innerType:e,...fe(t)})}const g9=W("ZodCatch",(e,t)=>{
  gZ.init(e,t);
  tt.init(e,t);

  e.unwrap=() => e._zod.def.innerType;

  e.removeCatch=e.unwrap;
});function R9(e,t){return new g9({type:"catch",innerType:e,catchValue:typeof t=="function"?t:() => t});}const N9=W("ZodPipe",(e,t)=>{
  RZ.init(e,t);
  tt.init(e,t);
  e.in=t.in;
  e.out=t.out;
});function aO(e,t){return new N9({type:"pipe",in:e,out:t})}const y9=W("ZodReadonly",(e,t)=>{
  NZ.init(e,t);
  tt.init(e,t);

  e.unwrap=() => e._zod.def.innerType;
});function O9(e){return new y9({type:"readonly",innerType:e})}const b9=W("ZodCustom",(e,t)=>{
  yZ.init(e,t);
  tt.init(e,t);
});function C9(e,t={}){return E4(b9,e,t)}function I9(e){return h4(e)}const P9=Vu(["ACTIVE","PAUSED","DELETED"]);ar({version:Za().optional(),id:dt(),name:dt(),prompt:dt(),status:P9,rrule:dt().optional(),cwds:kl(dt()),created_at:Za(),updated_at:Za()});
const M9={Dev:"dev",InternalAlpha:"internal-alpha",PublicBeta:"public-beta",Prod:"prod"};
const v9=Object.values(M9);
v9.join(", ");function Ue(e){return e==null?false:e.kind==="ssh"||e.kind==="brix";}
const L9="codex.localEnvironmentConfigPath";
const w9="__none__";
const D9=["tool","run","debug","test"];
const U9=["darwin","linux","win32"];
const k9=ar({name:dt(),icon:Vu(D9).nullable().catch(null),command:dt(),platform:Vu(U9).optional()});
const Nf=ar({script:dt()});
const G9=ar({script:dt(),darwin:Nf.optional(),linux:Nf.optional(),win32:Nf.optional()});
const V9=ar({version:Za().int().min(1).default(1),name:dt(),setup:G9,actions:kl(k9).optional()});
function st(e){switch(typeof e){case "undefined":
  {
    return"null";
  }case "string":
  {
    return`string(len=${e.length})`;
  }case"number":case "boolean":
  {
    return String(e);
  }case "bigint":
  {
    return e.toString();
  }case"function":case "symbol":
  {
    return typeof e
  }}if (e==null) {
  return"null";
}switch(Object.prototype.toString.call(e)){case "[object Date]":
  {
    try{const n=e;return Number.isNaN(n.getTime())?"date(invalid)":n.toISOString()}catch{return"date(invalid)"}
  }case"[object Error]":{
  const n=e;
  const r=n.code;
  return typeof r=="string"&&r.length>0?`error(name=${n.name},code=${r})`:`error(name=${n.name})`
}case "[object Uint8Array]":
  {
    return`bytes(len=${e.byteLength})`;
  }case "[object Array]":
  {
    return`array(len=${e.length})`
  }}try{return`object(keys=${Object.keys(e).length})`}catch{return"object(keys=unknown)"}}function Oe(e){return{type:"ok",value:e}}function Va(e){return{type:"error",error:{message:e instanceof Error?e.message:String(e)}}}
const x9="https://17de4aef18bcd467f0a250b004f16737@o33249.ingest.us.sentry.io/4510507758977024";
const $9="codex-desktop@";
function B9(e){return`${$9}${e}`}function H9(e){switch(e){case"dev":case"internal-alpha":case "public-beta":
  {
    return true;
  }case "prod":
  {
    return false;
  }}}function F9(e){return H9(e)?1:0}
let yf;
let cO;
function Y9(){
  if (!cO) {
    cO=1;
    yf=() => {};
  }

  return yf;
}
let Of;
let uO;
function To(){
  if (uO) {
    return Of;
  }uO=1;const e=Y9()();
  Of=t => t!==e&&t!==null;
  return Of;
}
let bf;
let lO;
function uL(...args) {
  if (lO) {
    return bf;
  }lO=1;
  const e=To();
  const t=Array.prototype.forEach;
  const n=Object.create;

  const r=(o, s) => {let i;for (i in o) {
    s[i]=o[i]
  }};

  bf=function(o){
    const s=n(null);
    t.call(args,i => {
      if (e(i)) {
        r(Object(i),s);
      }
    });
    return s;
  };

  return bf;
}
let Cf;
let dO;
function j9(){
  if (!dO) {
    dO=1;
    Cf=() => {const e=Math.sign;return typeof e!="function"?false:e(10)===1&&e(-20)===-1;};
  }

  return Cf;
}
let If;
let fO;
function q9(){
  if (!fO) {
    fO=1;

    If=e => {
      e=Number(e);
      return isNaN(e)||e===0?e:e>0?1:-1;
    };
  }

  return If;
}
let Pf;
let _O;
function W9(){
  if (!_O) {
    _O=1;
    Pf=j9()()?Math.sign:q9();
  }

  return Pf;
}
let Mf;
let pO;
function K9(){
  if (pO) {
    return Mf;
  }pO=1;
  const e=W9();
  const t=Math.abs;
  const n=Math.floor;
  Mf=r => isNaN(r)?0:(r=Number(r),r===0||!isFinite(r)?r:e(r)*n(t(r)));
  return Mf;
}
let vf;
let EO;
function So(){
  if (EO) {
    return vf;
  }EO=1;
  const e=K9();
  const t=Math.max;
  vf=n => t(0,e(n));
  return vf;
}
let Lf;
let hO;
function lL(){
  if (hO) {
    return Lf;
  }hO=1;const e=So();
  Lf=(t, n, r) => {let o;return isNaN(t)?(o=n,o>=0?r&&o?o-1:o:1):t===false?false:e(t);};
  return Lf;
}
let wf;
let TO;
function cr(){
  if (!TO) {
    TO=1;

    wf=e => {if (typeof e!="function") {
      throw new TypeError(`${e} is not a function`);
    }return e};
  }

  return wf;
}
let Df;
let SO;
function rs(){
  if (SO) {
    return Df;
  }SO=1;const e=To();

  Df=t => {if (!e(t)) {
    throw new TypeError("Cannot use null or undefined");
  }return t};

  return Df;
}
let Uf;
let mO;
function z9(...args) {
  if (mO) {
    return Uf;
  }mO=1;
  const e=cr();
  const t=rs();
  const n=Function.prototype.bind;
  const r=Function.prototype.call;
  const o=Object.keys;
  const s=Object.prototype.propertyIsEnumerable;

  Uf=(i, a) => (function(c, l) {
    let f;
    const d=args[2];
    const u=args[3];
    c=Object(t(c));
    e(l);
    f=o(c);

    if (u) {
      f.sort(typeof u=="function"?n.call(u,c):void 0);
    }

    if (typeof i!="function") {
      (i = f[i]);
    }

    return r.call(i,f,(_, p) => s.call(c,_)?r.call(l,d,c[_],_,c,p):a);
  });

  return Uf;
}
let kf;
let AO;
function Gl(){
  if (!AO) {
    AO=1;
    kf=z9()("forEach");
  }

  return kf;
}
const gO={};
let RO;
function mo(){
  if (!RO) {
    (RO = 1);
  }

  return gO;
}
const Gf={exports:{}};
let Vf;
let NO;
function Z9(){
  if (!NO) {
    NO=1;

    Vf=() => {
      const e=Object.assign;
      let t;
      return typeof e!="function"?false:(t={foo:"raz"},e(t,{bar:"dwa"},{trzy:"trzy"}),t.foo+t.bar+t.trzy==="razdwatrzy");
    };
  }

  return Vf;
}
let xf;
let yO;
function X9(){
  if (!yO) {
    yO=1;

    xf=() => {try{
      Object.keys("primitive");
      return true;
    }catch{return false;}};
  }

  return xf;
}
let $f;
let OO;
function Q9(){
  if (OO) {
    return $f;
  }OO=1;
  const e=To();
  const t=Object.keys;
  $f=n => t(e(n)?Object(n):n);
  return $f;
}
let Bf;
let bO;
function J9(){
  if (!bO) {
    bO=1;
    Bf=X9()()?Object.keys:Q9();
  }

  return Bf;
}
let Hf;
let CO;
function eX(...args) {
  if (CO) {
    return Hf;
  }CO=1;
  const e=J9();
  const t=rs();
  const n=Math.max;

  Hf=function(r,o){
    let s;
    let i;
    const a=n(args.length,2);
    let c;
    r=Object(t(r));
    c=l => {try{r[l]=o[l]}catch(f){
      if (!s) {
        (s = f);
      }
    }};

    for (i=1; i<a; ++i) {
      o=args[i];
      e(o).forEach(c);
    }

    if (s!==void 0) {
      throw s;
    }return r
  };

  return Hf;
}
let Ff;
let IO;
function dL(){
  if (!IO) {
    IO=1;
    Ff=Z9()()?Object.assign:eX();
  }

  return Ff;
}
let Yf;
let PO;
function tX(){
  if (PO) {
    return Yf;
  }PO=1;
  const e=To();
  const t={function:true,object:true};
  Yf=n => e(n)&&t[typeof n]||false;
  return Yf;
}let MO;function nX(...args) {
  if (!MO) {
    MO=1;

    (e => {
      const t=dL();
      const n=tX();
      const r=To();
      const o=Error.captureStackTrace;
      e.exports=function(s){
        const i=new Error(s);
        let a=args[1];
        let c=args[2];

        if (!r(c)) {
          if (n(a)) {
            c=a;
            a=null;
          }
        }

        if (r(c)) {
          t(i,c);
        }

        if (r(a)) {
          (i.code = a);
        }

        if (o) {
          o(i,e.exports);
        }

        return i;
      }
    })(Gf);
  }

  return Gf.exports;
}
const Kc={exports:{}};
let jf;
let vO;
function fL(){
  if (vO) {
    return jf;
  }vO=1;
  const e=rs();
  const t=Object.defineProperty;
  const n=Object.getOwnPropertyDescriptor;
  const r=Object.getOwnPropertyNames;
  const o=Object.getOwnPropertySymbols;

  jf=(s, i) => {
    let a;
    const c=Object(e(i));
    s=Object(e(s));
    r(c).forEach(l => {try{t(s,l,n(i,l))}catch(f){a=f}});

    if (typeof o=="function") {
      o(c).forEach(l => {try{t(s,l,n(i,l))}catch(f){a=f}});
    }

    if (a!==void 0) {
      throw a;
    }

    return s
  };

  return jf;
}let LO;function _L(){
  if (LO) {
    return Kc.exports;
  }LO=1;
  const e=So();
  const t=(i, a) => a;
  let n;
  let r;
  let o;
  let s;
  try{Object.defineProperty(t,"length",{configurable:true,writable:false,enumerable:false,value:1})}catch{}

  if (t.length===1) {
    n={configurable:true,writable:false,enumerable:false};
    r=Object.defineProperty;

    Kc.exports=(i, a) => {
      a=e(a);
      return i.length===a?i:(n.value=a,r(i,"length",n));
    };
  } else {
    s=fL();

    o = (() => {const i=[];return a => {
      let c;
      let l=0;
      if (i[a]) {
        return i[a];
      }for (c=[]; a--; ) {
        c.push(`a${(++l).toString(36)}`);
      }return new Function("fn",`return function (${c.join(", ")}) { return fn.apply(this, arguments); };`);
    };})();

    Kc.exports=(i, a) => {
      let c;
      a=e(a);

      if (i.length===a) {
        return i;
      }

      c=o(a)(i);try{s(c,i)}catch{}return c
    };
  }

  return Kc.exports;
}
const qf={exports:{}};
let Wf;
let wO;
function pL(){
  if (wO) {
    return Wf;
  }wO=1;const e=void 0;
  Wf=t => t!==e&&t!==null;
  return Wf;
}
let Kf;
let DO;
function rX(){
  if (DO) {
    return Kf;
  }DO=1;
  const e=pL();
  const t={object:true,function:true,undefined:true};
  Kf=n => e(n)?hasOwnProperty.call(t,typeof n):false;
  return Kf;
}
let zf;
let UO;
function oX(){
  if (UO) {
    return zf;
  }UO=1;const e=rX();

  zf=t => {if (!e(t)) {
    return false;
  }try{return t.constructor?t.constructor.prototype===t:false;}catch{return false;}};

  return zf;
}
let Zf;
let kO;
function sX(){
  if (kO) {
    return Zf;
  }kO=1;const e=oX();

  Zf=t => {if (typeof t!="function"||!hasOwnProperty.call(t,"length")) {
    return false;
  }try{if (typeof t.length!="number"||typeof t.call!="function"||typeof t.apply!="function") {
    return false;
  }}catch{return false;}return!e(t)};

  return Zf;
}
let Xf;
let GO;
function iX(){
  if (GO) {
    return Xf;
  }GO=1;
  const e=sX();
  const t=/^\s*class[\s{/}]/;
  const n=Function.prototype.toString;
  Xf=r => !(!e(r)||t.test(n.call(r)));
  return Xf;
}
let Qf;
let VO;
function aX(){
  if (VO) {
    return Qf;
  }VO=1;const e="razdwatrzy";
  Qf=() => typeof e.contains!="function"?false:e.contains("dwa")===true&&e.contains("foo")===false;
  return Qf;
}
let Jf;
let xO;
function cX(...args) {
  if (xO) {
    return Jf;
  }xO=1;const e=String.prototype.indexOf;
  Jf=function(t){return e.call(this,t,args[1])>-1;};
  return Jf;
}
let e_;
let $O;
function uX(){
  if (!$O) {
    $O=1;
    e_=aX()()?String.prototype.contains:cX();
  }

  return e_;
}let BO;function Ao(...args) {
  if (BO) {
    return qf.exports;
  }BO=1;
  const e=pL();
  const t=iX();
  const n=dL();
  const r=uL();
  const o=uX();

  const s=qf.exports=function(i,a){
    let c;
    let l;
    let f;
    let d;
    let u;

    if (args.length<2||typeof i!="string") {
      d=a;
      a=i;
      i=null;
    } else {
      d=args[2];
    }

    if (e(i)) {
      c=o.call(i,"c");
      l=o.call(i,"e");
      f=o.call(i,"w");
    } else {
      c=f=true;
      l=false;
    }

    u={value:a,configurable:c,enumerable:l,writable:f};
    return d?n(r(d),u):u;
  };

  s.gs=function(i,a,c){
    let l;
    let f;
    let d;
    let u;

    if (typeof i!="string") {
      d=c;
      c=a;
      a=i;
      i=null;
    } else {
      d=args[3];
    }

    if (e(a)) {
      if (t(a)) {
        if (e(c)) {
          if (!t(c)) {
            d=c;
            c=void 0;
          }
        } else {
          c=void 0;
        }
      } else {
        d=a;
        a=c=void 0;
      }
    } else {
      a=void 0;
    }

    if (e(i)) {
      l=o.call(i,"c");
      f=o.call(i,"e");
    } else {
      l=true;
      f=false;
    }

    u={get:a,set:c,configurable:l,enumerable:f};
    return d?n(r(d),u):u;
  };

  return qf.exports;
}
const zc={exports:{}};
let HO;
function lX(...args) {
  if (!HO) {
    HO=1;

    ((e, t) => {
      const n=Ao();
      const r=cr();
      const o=Function.prototype.apply;
      const s=Function.prototype.call;
      const i=Object.create;
      const a=Object.defineProperty;
      const c=Object.defineProperties;
      const l=Object.prototype.hasOwnProperty;
      const f={configurable:true,enumerable:false,writable:true};
      let d;
      let u;
      let _;
      let p;
      let E;
      let h;
      let T;

      d=function(m,A){
        let g;
        r(A);

        if (l.call(this,"__ee__")) {
          g=this.__ee__;
        } else {
          g=f.value=i(null);
          a(this,"__ee__",f);
          f.value=null;
        }

        if (g[m]) {
          if (typeof g[m]=="object") {
            g[m].push(A);
          } else {
            g[m]=[g[m],A];
          }
        } else {
          g[m]=A;
        }

        return this;
      };

      u=function(m,A){
        let g;
        let R;
        r(A);
        R=this;

        d.call(this,m,g=function(...args) {
          _.call(R,m,g);
          o.call(A,this,args);
        });

        g.__eeOnceListener__=A;
        return this;
      };

      _=function(m,A){
        let g;
        let R;
        let O;
        let I;
        r(A);

        if (!l.call(this,"__ee__")) {
          return this;
        }

        g=this.__ee__;

        if (!g[m]) {
          return this;
        }

        R=g[m];

        if (typeof R=="object") {
          for (I=0; O=R[I]; ++I) {
            if ((O===A || O.__eeOnceListener__===A)) {
              if (R.length===2) {
                g[m]=R[I?0:1];
              } else {
                R.splice(I,1);
              }
            }
          }
        } else {
          if ((R===A || R.__eeOnceListener__===A)) {
            delete g[m];
          }
        }

        return this
      };

      p=function(m){
        let A;
        let g;
        let R;
        let O;
        let I;
        if (l.call(this,"__ee__")&&(O=this.__ee__[m],!!O)) {
          if (typeof O=="object") {
            g=args.length;
            I=new Array(g-1);

            for (A=1; A<g; ++A) {
              I[A-1]=args[A];
            }

            O=O.slice();

            for (A=0; R=O[A]; ++A) {
              o.call(R,this,I)
            }
          } else {
            switch(args.length){case 1:
              {
                s.call(O,this);break;
              }case 2:
              {
                s.call(O,this,args[1]);break;
              }case 3:
              {
                s.call(O,this,args[1],args[2]);break;
              }default:
              {
                g=args.length;
                I=new Array(g-1);

                for (A=1; A<g; ++A) {
                  I[A-1]=args[A];
                }

                o.call(O,this,I)
              }}
          }
        }
      };

      E={on:d,once:u,off:_,emit:p};
      h={on:n(d),once:n(u),off:n(_),emit:n(p)};
      T=c({},h);
      e.exports=t=m => m==null?i(T):c(Object(m),h);
      t.methods=E;
    })(zc, zc.exports);
  }

  return zc.exports;
}
let t_;
let FO;
function dX(){
  if (!FO) {
    FO=1;

    t_=() => {
      const e=Array.from;
      let t;
      let n;
      return typeof e!="function"?false:(t=["raz","dwa"],n=e(t),!!(n&&n!==t&&n[1]==="dwa"));
    };
  }

  return t_;
}
let n_;
let YO;
function fX(){
  if (!YO) {
    YO=1;
    n_=() => typeof globalThis!="object"||!globalThis?false:globalThis.Array===Array;
  }

  return n_;
}
let r_;
let jO;
function _X(){
  if (jO) {
    return r_;
  }jO=1;const e=() => {if (typeof self=="object"&&self) {
    return self;
  }if (typeof window=="object"&&window) {
    return window;
  }throw new Error("Unable to resolve global `this`")};

  r_=(function(){if (this) {
    return this;
  }try{Object.defineProperty(Object.prototype,"__global__",{get() {return this},configurable:true})}catch{return e()}try{return __global__||e()}finally{delete Object.prototype.__global__}})();

  return r_;
}
let o_;
let qO;
function Vl(){
  if (!qO) {
    qO=1;
    o_=fX()()?globalThis:_X();
  }

  return o_;
}
let s_;
let WO;
function pX(){
  if (WO) {
    return s_;
  }WO=1;
  const e=Vl();
  const t={object:true,symbol:true};

  s_=() => {
    const n=e.Symbol;
    let r;
    if (typeof n!="function") {
      return false;
    }r=n("test symbol");try{String(r)}catch{return false;}return!(!t[typeof n.iterator]||!t[typeof n.toPrimitive]||!t[typeof n.toStringTag])
  };

  return s_;
}
let i_;
let KO;
function EX(){
  if (!KO) {
    KO=1;
    i_=e => e?typeof e=="symbol"?true:!e.constructor||e.constructor.name!=="Symbol"?false:e[e.constructor.toStringTag]==="Symbol":false;
  }

  return i_;
}
let a_;
let zO;
function EL(){
  if (zO) {
    return a_;
  }zO=1;const e=EX();

  a_=t => {if (!e(t)) {
    throw new TypeError(`${t} is not a symbol`);
  }return t};

  return a_;
}
let c_;
let ZO;
function hX(){
  if (ZO) {
    return c_;
  }ZO=1;
  const e=Ao();
  const t=Object.create;
  const n=Object.defineProperty;
  const r=Object.prototype;
  const o=t(null);

  c_=s => {
    let a;
    let c;
    for (var i=0; o[s+(i||"")]; ) {
      ++i;
    }
    s+=i||"";
    o[s]=true;
    a=`@@${s}`;
    n(r,a,e.gs(null,function(l){
      if (!c) {
        c=true;
        n(this,a,e(l));
        c=false;
      }
    }));
    return a;
  };

  return c_;
}
let u_;
let XO;
function TX(){
  if (XO) {
    return u_;
  }XO=1;
  const e=Ao();
  const t=Vl().Symbol;
  u_=n => Object.defineProperties(n,{hasInstance:e("",t&&t.hasInstance||n("hasInstance")),isConcatSpreadable:e("",t&&t.isConcatSpreadable||n("isConcatSpreadable")),iterator:e("",t&&t.iterator||n("iterator")),match:e("",t&&t.match||n("match")),replace:e("",t&&t.replace||n("replace")),search:e("",t&&t.search||n("search")),species:e("",t&&t.species||n("species")),split:e("",t&&t.split||n("split")),toPrimitive:e("",t&&t.toPrimitive||n("toPrimitive")),toStringTag:e("",t&&t.toStringTag||n("toStringTag")),unscopables:e("",t&&t.unscopables||n("unscopables"))});
  return u_;
}
let l_;
let QO;
function SX(){
  if (QO) {
    return l_;
  }QO=1;
  const e=Ao();
  const t=EL();
  const n=Object.create(null);

  l_=r => Object.defineProperties(r,{for:e(o => n[o]?n[o]:n[o]=r(String(o))),keyFor:e(o => {let s;t(o);for (s in n) {
    if (n[s]===o) {
      return s
    }
  }})});

  return l_;
}
let d_;
let JO;
function mX(){
  if (JO) {
    return d_;
  }JO=1;
  const e=Ao();
  const t=EL();
  let n=Vl().Symbol;
  const r=hX();
  const o=TX();
  const s=SX();
  const i=Object.create;
  const a=Object.defineProperties;
  const c=Object.defineProperty;
  let l;
  let f;
  let d;
  if (typeof n=="function") {
    try{
      String(n());
      d=true;
    }catch{}
  } else {
    n=null;
  }

  f=function(_){if (this instanceof f) {
    throw new TypeError("Symbol is not a constructor");
  }return l(_)};

  d_=l=function u(_){let p;if (this instanceof u) {
    throw new TypeError("Symbol is not a constructor");
  }return d?n(_):(p=i(f.prototype),_=_===void 0?"":String(_),a(p,{__description__:e("",_),__name__:e("",r(_))}))};

  o(l);
  s(l);
  a(f.prototype,{constructor:e(l),toString:e("",function(){return this.__name__})});
  a(l.prototype,{toString:e(function(){return `Symbol (${t(this).__description__})`;}),valueOf:e(function(){return t(this)})});
  c(l.prototype,l.toPrimitive,e("",function(){const u=t(this);return typeof u=="symbol"?u:u.toString()}));
  c(l.prototype,l.toStringTag,e("c","Symbol"));
  c(f.prototype,l.toStringTag,e("c",l.prototype[l.toStringTag]));
  c(f.prototype,l.toPrimitive,e("c",l.prototype[l.toPrimitive]));
  return d_;
}
let f_;
let eb;
function AX(){
  if (!eb) {
    eb=1;
    f_=pX()()?Vl().Symbol:mX();
  }

  return f_;
}
let __;
let tb;
function gX(){
  if (tb) {
    return __;
  }tb=1;
  const e=Object.prototype.toString;
  const t=e.call((function(...args) {return args;})());
  __=n => e.call(n)===t;
  return __;
}
let p_;
let nb;
function RX(){
  if (nb) {
    return p_;
  }nb=1;
  const e=Object.prototype.toString;
  const t=RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);
  p_=n => typeof n=="function"&&t(e.call(n));
  return p_;
}
let E_;
let rb;
function NX(){
  if (rb) {
    return E_;
  }rb=1;
  const e=Object.prototype.toString;
  const t=e.call("");
  E_=n => typeof n=="string"||n&&typeof n=="object"&&(n instanceof String||e.call(n)===t)||false;
  return E_;
}
let h_;
let ob;
function yX(...args) {
  if (ob) {
    return h_;
  }ob=1;
  const e=AX().iterator;
  const t=gX();
  const n=RX();
  const r=So();
  const o=cr();
  const s=rs();
  const i=To();
  const a=NX();
  const c=Array.isArray;
  const l=Function.prototype.call;
  const f={configurable:true,enumerable:true,writable:true,value:null};
  const d=Object.defineProperty;

  h_=function(u){
    const _=args[1];
    const p=args[2];
    let E;
    let h;
    let T;
    let m;
    let A;
    let g;
    let R;
    let O;
    let I;
    let b;
    u=Object(s(u));

    if (i(_)) {
      o(_);
    }

    if (!this||this===Array||!n(this)) {if(!_){if (t(u)) {
      A=u.length;
      return A!==1?Array(...u):(m=new Array(1),m[0]=u[0],m);
    }if(c(u)){
      m=new Array(A=u.length);

      for (h=0; h<A; ++h) {
        m[h]=u[h];
      }

      return m
    }}m=[]} else {
      E=this;
    }

    if(!c(u)){if((I=u[e])!==void 0){
      R=o(I).call(u);

      if (E) {
        (m = new E);
      }

      O=R.next();

      for (h=0; !O.done; ) {
        b=_?l.call(_,p,O.value,h):O.value;

        if (E) {
          f.value=b;
          d(m,h,f);
        } else {
          m[h]=b;
        }

        O=R.next();
        ++h;
      }

      A=h
    }else if(a(u)){
      A=u.length;

      if (E) {
        (m = new E);
      }

      h=0;

      for (T=0; h<A; ++h) {
        b=u[h];

        if (h+1<A) {
          g=b.charCodeAt(0);
          g>=55296&&g<=56319&&(b+=u[++h]);
        }

        b=_?l.call(_,p,b,T):b;

        if (E) {
          f.value=b;
          d(m,T,f);
        } else {
          m[T]=b;
        }

        ++T;
      }

      A=T
    }}if (A===void 0) {
      A=r(u.length);

      if (E) {
        (m = new E(A));
      }

      for (h=0; h<A; ++h) {
        b=_?l.call(_,p,u[h],h):u[h];

        if (E) {
          f.value=b;
          d(m,h,f);
        } else {
          m[h]=b;
        }
      }
    }

    if (E) {
      f.value=null;
      m.length=A;
    }

    return m;
  };

  return h_;
}
let T_;
let sb;
function _h(){
  if (!sb) {
    sb=1;
    T_=dX()()?Array.from:yX();
  }

  return T_;
}
let S_;
let ib;
function OX(){
  if (ib) {
    return S_;
  }ib=1;
  const e=_h();
  const t=Array.isArray;
  S_=n => t(n)?n:e(n);
  return S_;
}
let m_;
let ab;
function bX(){
  if (ab) {
    return m_;
  }ab=1;
  const e=OX();
  const t=To();
  const n=cr();
  const r=Array.prototype.slice;
  let o;
  o=function(s){return this.map((i, a) => i?i(s[a]):s[a]).concat(r.call(s,this.length));};

  m_=s => {
    s=e(s);
    s.forEach(i => {
      if (t(i)) {
        n(i);
      }
    });
    return o.bind(s);
  };

  return m_;
}
let A_;
let cb;
function CX(){
  if (cb) {
    return A_;
  }cb=1;const e=cr();
  A_=t => {let n;return typeof t=="function"?{set:t,get:t}:(n={get:e(t.get)},t.set!==void 0?(n.set=e(t.set),t.delete&&(n.delete=e(t.delete)),t.clear&&(n.clear=e(t.clear)),n):(n.set=n.get,n))};
  return A_;
}
let g_;
let ub;
function IX(...args) {
  if (ub) {
    return g_;
  }ub=1;
  const e=nX();
  const t=_L();
  const n=Ao();
  const r=lX().methods;
  const o=bX();
  const s=CX();
  const i=Function.prototype.apply;
  const a=Function.prototype.call;
  const c=Object.create;
  const l=Object.defineProperties;
  const f=r.on;
  const d=r.emit;

  g_=(u, _, p) => {
    let E=c(null);
    let h;
    let T;
    let m;
    let A;
    let g;
    let R;
    let O;
    let I;
    let b;
    let L;
    let U;
    let q;
    let H;
    let $;
    let B;

    if (_!==false) {
      T=_;
    } else if (isNaN(u.length)) {
      T=1;
    } else {
      T=u.length;
    }

    if (p.normalizer) {
      L=s(p.normalizer);
      m=L.get;
      A=L.set;
      g=L.delete;
      R=L.clear;
    }

    if (p.resolvers!=null) {
      (B = o(p.resolvers));
    }

    if (m) {
      $=t(function(F){
        let D;
        let k;
        let Y=args;

        if (B) {
          (Y = B(Y));
        }

        D=m(Y);

        if (D!==null&&hasOwnProperty.call(E,D)) {
          if (U) {
            h.emit("get",D,Y,this);
          }

          return E[D];
        }

        if (Y.length===1) {
          k=a.call(u,this,Y[0]);
        } else {
          k=i.call(u,this,Y);
        }

        if (D===null) {
          D=m(Y);

          if (D!==null) {
            throw e("Circular invocation","CIRCULAR_INVOCATION");
          }

          D=A(Y)
        } else if (hasOwnProperty.call(E,D)) {
          throw e("Circular invocation","CIRCULAR_INVOCATION");
        }

        E[D]=k;

        if (q) {
          h.emit("set",D,null,k);
        }

        return k;
      },T);
    } else if (_===0) {
      $=function(...args) {
        let F;if (hasOwnProperty.call(E,"data")) {
          if (U) {
            h.emit("get","data",args,this);
          }

          return E.data;
        }

        if (args.length) {
          F=i.call(u,this,args);
        } else {
          F=a.call(u,this);
        }

        if (hasOwnProperty.call(E,"data")) {
          throw e("Circular invocation","CIRCULAR_INVOCATION");
        }

        E.data=F;

        if (q) {
          h.emit("set","data",null,F);
        }

        return F;
      };
    } else {
      $=function(F){
        let D;
        let k=args;
        let Y;

        if (B) {
          (k = B(args));
        }

        Y=String(k[0]);

        if (hasOwnProperty.call(E,Y)) {
          if (U) {
            h.emit("get",Y,k,this);
          }

          return E[Y];
        }

        if (k.length===1) {
          D=a.call(u,this,k[0]);
        } else {
          D=i.call(u,this,k);
        }

        if (hasOwnProperty.call(E,Y)) {
          throw e("Circular invocation","CIRCULAR_INVOCATION");
        }

        E[Y]=D;

        if (q) {
          h.emit("set",Y,null,D);
        }

        return D;
      };
    }

    h={original:u,memoized:$,profileName:p.profileName,get(F) {
      if (B) {
        (F = B(F));
      }

      return m?m(F):String(F[0]);
    },has(F) {return hasOwnProperty.call(E,F)},delete(F) {
      let D;

      if (hasOwnProperty.call(E,F)) {
        g&&g(F);
        D=E[F];
        delete E[F];
        H&&h.emit("delete",F,D);
      }
    },clear() {
      const F=E;

      if (R) {
        R();
      }

      E=c(null);
      h.emit("clear",F);
    },on(F, D) {
      switch (F) {
      case "get":
        U=true;
        break;
      case "set":
        q=true;
        break;
      case "delete":
        (H = true);
        break;
      }

      return f.call(this,F,D);
    },emit:d,updateEnv() {u=h.original}};

    if (m) {
      O=t(function(F){
        let D;
        let k=args;

        if (B) {
          (k = B(k));
        }

        D=m(k);

        if (D!==null) {
          h.delete(D);
        }
      },T);
    } else if (_===0) {
      O=() => h.delete("data");
    } else {
      O=function(F){
        if (B) {
          (F = B(args)[0]);
        }

        return h.delete(F);
      };
    }

    I=t(function(...args) {
      let F;
      let D=args;
      return _===0?E.data:(B&&(D=B(D)),m?F=m(D):F=String(D[0]),E[F])
    });

    b=t(function(...args) {
      let F;
      let D=args;
      return _===0?h.has("data"):(B&&(D=B(D)),m?F=m(D):F=String(D[0]),F===null?false:h.has(F));
    });

    l($,{__memoized__:n(true),delete:n(O),clear:n(h.clear),_get:n(I),_has:n(b)});
    return h;
  };

  return g_;
}
let R_;
let lb;
function PX(...args) {
  if (lb) {
    return R_;
  }lb=1;
  const e=cr();
  const t=Gl();
  const n=mo();
  const r=IX();
  const o=lL();

  R_=function s(i){
    let a;
    let c;
    let l;
    e(i);
    a=Object(args[1]);

    if (a.async&&a.promise) {
      throw new Error("Options 'async' and 'promise' cannot be used together");
    }

    return hasOwnProperty.call(i,"__memoized__")&&!a.force?i:(c=o(a.length,i.length,a.async&&n.async),l=r(i,c,a),t(n,(f, d) => {
      if (a[d]) {
        f(a[d],l,a);
      }
    }),s.__profiler__&&s.__profiler__(l),l.updateEnv(),l.memoized);
  };

  return R_;
}
let N_;
let db;
function MX(){
  if (!db) {
    db=1;

    N_=e => {
      let t;
      let n;
      let r=e.length;
      if (!r) {
        return"";
      }for (t=String(e[n=0]); --r; ) {
        t+=`${e[++n]}`;
      }return t
    };
  }

  return N_;
}
let y_;
let fb;
function vX(){
  if (!fb) {
    fb=1;

    y_=e => e?t => {
      let n=String(t[0]);
      let r=0;
      for (let o=e; --o; ) {
        n+=`${t[++r]}`;
      }return n
    }:() => "";
  }

  return y_;
}
let O_;
let _b;
function LX(){
  if (!_b) {
    _b=1;
    O_=() => {const e=Number.isNaN;return typeof e!="function"?false:!e({})&&e(NaN)&&!e(34);};
  }

  return O_;
}
let b_;
let pb;
function wX(){
  if (!pb) {
    pb=1;
    b_=e => e!==e;
  }

  return b_;
}
let C_;
let Eb;
function DX(){
  if (!Eb) {
    Eb=1;
    C_=LX()()?Number.isNaN:wX();
  }

  return C_;
}
let I_;
let hb;
function ph(...args) {
  if (hb) {
    return I_;
  }hb=1;
  const e=DX();
  const t=So();
  const n=rs();
  const r=Array.prototype.indexOf;
  const o=Object.prototype.hasOwnProperty;
  const s=Math.abs;
  const i=Math.floor;

  I_=function(a){
    let c;
    let l;
    let f;
    let d;
    if (!e(a)) {
      return r.apply(this,args);
    }
    l=t(n(this).length);
    f=args[1];

    if (isNaN(f)) {
      f=0;
    } else if (f>=0) {
      f=i(f);
    } else {
      f=t(this.length)-i(s(f));
    }

    for (c=f; c<l; ++c) {
      if (o.call(this,c)&&(d=this[c],e(d))) {
        return c;
      }
    }

    return-1
  };

  return I_;
}
let P_;
let Tb;
function UX(){
  if (Tb) {
    return P_;
  }Tb=1;
  const e=ph();
  const t=Object.create;

  P_=() => {
    let n=0;
    let r=[];
    let o=t(null);
    return {get(s) {
      let i=0;
      let a=r;
      let c;
      const l=s.length;
      if (l===0) {
        return a[l]||null;
      }if(a=a[l]){
      while (i<l-1) {
        c=e.call(a[0],s[i]);

        if (c===-1) {
          return null;
        }

        a=a[1][c];
        ++i;
      }

      c=e.call(a[0],s[i]);
      return c===-1?null:a[1][c]||null;
    }return null
    },set(s) {
      let i=0;
      let a=r;
      let c;
      const l=s.length;
      if (l===0) {
        a[l]=++n;
      } else {
        if (!a[l]) {
          (a[l] = [[],[]]);
        }

        for (a=a[l]; i<l-1; ) {
          c=e.call(a[0],s[i]);

          if (c===-1) {
            c=a[0].push(s[i])-1;
            a[1].push([[],[]]);
          }

          a=a[1][c];
          ++i;
        }

        c=e.call(a[0],s[i]);

        if (c===-1) {
          (c = a[0].push(s[i])-1);
        }

        a[1][c]=++n;
      }
      o[n]=s;
      return n;
    },delete(s) {
      let i=0;
      let a=r;
      let c;
      const l=o[s];
      const f=l.length;
      const d=[];
      if (f===0) {
        delete a[f];
      } else if(a=a[f]){
        while (i<f-1) {
          c=e.call(a[0],l[i]);

          if (c===-1) {
            return;
          }

          d.push(a,c);
          a=a[1][c];
          ++i;
        }

        c=e.call(a[0],l[i]);

        if (c===-1) {
          return;
        }

        s=a[1][c];
        a[0].splice(c,1);
        a[1].splice(c,1);

        while (!a[0].length&&d.length) {
          c=d.pop();
          a=d.pop();
          a[0].splice(c,1);
          a[1].splice(c,1);
        }
      }delete o[s]
    },clear() {
      r=[];
      o=t(null);
    }};
  };

  return P_;
}
let M_;
let Sb;
function kX(){
  if (Sb) {
    return M_;
  }Sb=1;const e=ph();

  M_=() => {
    let t=0;
    let n=[];
    let r=[];
    return {get(o) {const s=e.call(n,o[0]);return s===-1?null:r[s]},set(o) {
      n.push(o[0]);
      r.push(++t);
      return t;
    },delete(o) {
      const s=e.call(r,o);

      if (s!==-1) {
        n.splice(s,1);
        r.splice(s,1);
      }
    },clear() {
      n=[];
      r=[];
    }};
  };

  return M_;
}
let v_;
let mb;
function GX(){
  if (mb) {
    return v_;
  }mb=1;
  const e=ph();
  const t=Object.create;

  v_=n => {
    let r=0;
    let o=[[],[]];
    let s=t(null);
    return {get(i) {
      let c=o;
      let l;
      for(var a=0;a<n-1;){
        l=e.call(c[0],i[a]);

        if (l===-1) {
          return null;
        }

        c=c[1][l];
        ++a;
      }
      l=e.call(c[0],i[a]);
      return l===-1?null:c[1][l]||null;
    },set(i) {
      let c=o;
      let l;
      for (var a=0; a<n-1; ) {
        l=e.call(c[0],i[a]);

        if (l===-1) {
          l=c[0].push(i[a])-1;
          c[1].push([[],[]]);
        }

        c=c[1][l];
        ++a;
      }
      l=e.call(c[0],i[a]);

      if (l===-1) {
        (l = c[0].push(i[a])-1);
      }

      c[1][l]=++r;
      s[r]=i;
      return r;
    },delete(i) {
      let c=o;
      let l;
      const f=[];
      const d=s[i];
      for(var a=0;a<n-1;){
        l=e.call(c[0],d[a]);

        if (l===-1) {
          return;
        }

        f.push(c,l);
        c=c[1][l];
        ++a;
      }
      l=e.call(c[0],d[a]);

      if (l!==-1) {
        i=c[1][l];
        c[0].splice(l,1);
        c[1].splice(l,1);

        while (!c[0].length&&f.length) {
          l=f.pop();
          c=f.pop();
          c[0].splice(l,1);
          c[1].splice(l,1);
        }

        delete s[i]
      }
    },clear() {
      o=[[],[]];
      s=t(null);
    }};
  };

  return v_;
}
const Ab={};
let L_;
let gb;
function hL(...args) {
  if (gb) {
    return L_;
  }gb=1;
  const e=cr();
  const t=Gl();
  const n=Function.prototype.call;

  L_=function(r,o){
    const s={};
    const i=args[2];
    e(o);
    t(r,(a, c, l, f) => {s[c]=n.call(o,i,a,c,l,f)});
    return s;
  };

  return L_;
}
let w_;
let Rb;
function Eh(){
  if (Rb) {
    return w_;
  }Rb=1;

  const e=n => {if (typeof n!="function") {
    throw new TypeError(`${n} is not a function`);
  }return n};

  const t=n => {
    const r=document.createTextNode("");
    let o;
    let s;
    let i=0;

    new n(() => {
      let a;if (o) {
      if (s) {
        (o = s.concat(o));
      }
    } else {if (!s) {
        return;
      }o=s}
      s=o;
      o=null;

      if (typeof s=="function") {
        a=s;
        s=null;
        a();
        return
      }

      for (r.data=i=++i%2; s; ) {
        a=s.shift();

        if (!s.length) {
          (s = null);
        }

        a();
      }
    }).observe(r,{characterData:true});

    return a => {
      e(a);

      if (o)
        {
          if (typeof o=="function") {
            o=[o,a];
          } else {
            o.push(a);
          }

          return
        }

      o=a;
      r.data=i=++i%2;
    };
  };

  w_ = (() => {if (typeof process=="object"&&process&&typeof process.nextTick=="function") {
    return process.nextTick;
  }if (typeof queueMicrotask=="function") {
    return n => {queueMicrotask(e(n))};
  }if(typeof document=="object"&&document){if (typeof MutationObserver=="function") {
    return t(MutationObserver);
  }if (typeof WebKitMutationObserver=="function") {
    return t(WebKitMutationObserver)
  }}return typeof setImmediate=="function"?n => {setImmediate(e(n))}:typeof setTimeout=="function"||typeof setTimeout=="object"?n => {setTimeout(e(n),0)}:null;})();

  return w_;
}let Nb;function VX(...args) {
  if (Nb) {
    return Ab;
  }Nb=1;
  const e=_h();
  const t=hL();
  const n=fL();
  const r=_L();
  const o=Eh();
  const s=Array.prototype.slice;
  const i=Function.prototype.apply;
  const a=Object.create;

  mo().async=(c, l) => {
    const f=a(null);
    let d=a(null);
    const u=l.memoized;
    const _=l.original;
    let p;
    let E;
    let h;
    l.memoized=r(function(T){
      let m=args;
      const A=m[m.length-1];

      if (typeof A=="function") {
        p=A;
        m=s.call(m,0,-1);
      }

      return u.apply(E=this,h=m);
    },u);try{n(l.memoized,u)}catch{}

    l.on("get",T => {
      let m;
      let A;
      let g;
      if(p){
        if(f[T]){
          if (typeof f[T]=="function") {
            f[T]=[f[T],p];
          } else {
            f[T].push(p);
          }

          p=null;
          return
        }
        m=p;
        A=E;
        g=h;
        p = null;
        E = null;
        h = null;
        o(() => {
          let R;

          if (hasOwnProperty.call(d,T)) {
            R=d[T];
            l.emit("getasync",T,g,A);
            i.call(m,R.context,R.args);
          } else {
            p=m;
            E=A;
            h=g;
            u.apply(A,g);
          }
        });
      }
    });

    l.original=function(...args) {
      let T;
      let m;
      let A;
      let g;
      return p?(T=e(args),m=function R(O){
        let I;
        let b;
        const L=R.id;
        if(L==null){o(i.bind(R,this,args));return}
        delete R.id;
        I=f[L];
        delete f[L];

        if (!!I) {
          b=e(args);

          if (l.has(L)) {
            if (O) {
              l.delete(L);
            } else {
              d[L]={context:this,args:b};
              l.emit("setasync",L,typeof I=="function"?1:I.length);
            }
          }

          if (typeof I=="function") {
            g=i.call(I,this,b);
          } else {
            I.forEach(function(U){g=i.call(U,this,b)},this);
          }

          return g;
        }
      },A=p,p=E=h=null,T.push(m),g=i.call(_,this,T),m.cb=A,p=m,g):i.call(_,this,args);
    };

    l.on("set",T => {
      if(!p){l.delete(T);return}

      if (f[T]) {
        if (typeof f[T]=="function") {
          f[T]=[f[T],p.cb];
        } else {
          f[T].push(p.cb);
        }
      } else {
        f[T]=p.cb;
      }

      delete p.cb;
      p.id=T;
      p=null;
    });

    l.on("delete",T => {
      let m;

      if (!hasOwnProperty.call(f,T)) {
        if (d[T]) {
          m=d[T];
          delete d[T];
          l.emit("deleteasync",T,s.call(m.args,1));
        }
      }
    });

    l.on("clear",() => {
      const T=d;
      d=a(null);
      l.emit("clearasync",t(T,m => s.call(m.args,1)));
    });
  };

  return Ab;
}
const yb={};
let D_;
let Ob;
function xX(...args) {
  if (Ob) {
    return D_;
  }Ob=1;
  const e=Array.prototype.forEach;
  const t=Object.create;

  D_=function(n){
    const r=t(null);
    e.call(args,o => {r[o]=true});
    return r;
  };

  return D_;
}
let U_;
let bb;
function TL(){
  if (!bb) {
    bb=1;
    U_=e => typeof e=="function";
  }

  return U_;
}
let k_;
let Cb;
function $X(){
  if (Cb) {
    return k_;
  }Cb=1;const e=TL();
  k_=t => {try{return t&&e(t.toString)?t.toString():String(t)}catch{throw new TypeError("Passed argument cannot be stringifed")}};
  return k_;
}
let G_;
let Ib;
function BX(){
  if (Ib) {
    return G_;
  }Ib=1;
  const e=rs();
  const t=$X();
  G_=n => t(e(n));
  return G_;
}
let V_;
let Pb;
function HX(){
  if (Pb) {
    return V_;
  }Pb=1;const e=TL();
  V_=t => {try{return t&&e(t.toString)?t.toString():String(t)}catch{return"<Non-coercible to string value>"}};
  return V_;
}
let x_;
let Mb;
function FX(){
  if (Mb) {
    return x_;
  }Mb=1;
  const e=HX();
  const t=/[\n\r\u2028\u2029]/g;

  x_=n => {
    let r=e(n);

    if (r.length>100) {
      (r = `${r.slice(0,99)}`);
    }

    r=r.replace(t,o => JSON.stringify(o).slice(1,-1));
    return r;
  };

  return x_;
}
const Zc={exports:{}};
let vb;
function SL(){
  if (vb) {
    return Zc.exports;
  }
  vb=1;
  Zc.exports=e;
  Zc.exports.default=e;
  function e(t){return!!t&&(typeof t=="object"||typeof t=="function")&&typeof t.then=="function"}return Zc.exports
}let Lb;function YX(){
  if (Lb) {
    return yb;
  }Lb=1;
  const e=hL();
  const t=xX();
  const n=BX();
  const r=FX();
  const o=SL();
  const s=Eh();
  const i=Object.create;
  const a=t("then","then:finally","done","done:finally");

  mo().promise=(c, l) => {
    let f=i(null);
    let d=i(null);
    let u=i(null);
    if (c===true) {
      c=null;
    } else {
      c=n(c);

      if (!a[c]) {
        throw new TypeError(`'${r(c)}' is not valid promise mode`);
      }
    }

    l.on("set",(_, p, E) => {
      let h=false;if(!o(E)){
          d[_]=E;
          l.emit("setasync",_,1);
          return
        }
      f[_]=1;
      u[_]=E;

      const T=R => {
        const O=f[_];if (h) {
          throw new Error(`Memoizee error: Detected unordered then|done & finally resolution, which in turn makes proper detection of success/failure impossible (when in 'done:finally' mode)
          Consider to rely on 'then' or 'done' mode instead.`);
        }

        if (O) {
          delete f[_];
          d[_]=R;
          l.emit("setasync",_,O);
        }
      };

      const m=() => {
        h=true;

        if (f[_]) {
          delete f[_];
          delete u[_];
          l.delete(_);
        }
      };

      let A=c;

      if (!A) {
        (A = "then");
      }

      if (A==="then") {
        const g=() => {s(m)};
        E=E.then(function(R){s(T.bind(this,R))},g);

        if (typeof E.finally=="function") {
          E.finally(g);
        }
      } else if(A==="done"){if (typeof E.done!="function") {
        throw new Error("Memoizee error: Retrieved promise does not implement 'done' in 'done' mode");
      }E.done(T,m)}else if(A==="done:finally"){
        if (typeof E.done!="function") {
          throw new Error("Memoizee error: Retrieved promise does not implement 'done' in 'done:finally' mode");
        }if (typeof E.finally!="function") {
          throw new Error("Memoizee error: Retrieved promise does not implement 'finally' in 'done:finally' mode");
        }
        E.done(T);
        E.finally(m);
      }
    });

    l.on("get",(_, p, E) => {
      let h;if(f[_]){++f[_];return}h=u[_];const T=() => {l.emit("getasync",_,p,E)};

      if (o(h)) {
        if (typeof h.done=="function") {
          h.done(T);
        } else {
          h.then(() => {s(T)});
        }
      } else {
        T();
      }
    });

    l.on("delete",_ => {
      delete u[_];

      if (f[_])
        {delete f[_];return}

      if(hasOwnProperty.call(d,_)){
        const p=d[_];
        delete d[_];
        l.emit("deleteasync",_,[p]);
      }
    });

    l.on("clear",() => {
      const _=d;
      d=i(null);
      f=i(null);
      u=i(null);
      l.emit("clearasync",e(_,p => [p]));
    });
  };

  return yb;
}
const wb={};
let Db;
function jX(){
  if (Db) {
    return wb;
  }Db=1;
  const e=cr();
  const t=Gl();
  const n=mo();
  const r=Function.prototype.apply;

  n.dispose=(o, s, i) => {
    let a;
    e(o);

    if (i.async&&n.async||i.promise&&n.promise) {
      s.on("deleteasync",a=(c, l) => {r.call(o,null,l)});
      s.on("clearasync",c => {t(c,(l, f) => {a(f,l)})});
      return
    }

    s.on("delete",a=(c, l) => {o(l)});
    s.on("clear",c => {t(c,(l, f) => {a(f,l)})});
  };

  return wb;
}
const Ub={};
let $_;
let kb;
function qX(){
  if (!kb) {
    kb=1;
    $_=2147483647;
  }

  return $_;
}
let B_;
let Gb;
function WX(){
  if (Gb) {
    return B_;
  }Gb=1;
  const e=So();
  const t=qX();

  B_=n => {
    n=e(n);

    if (n>t) {
      throw new TypeError(`${n} exceeds maximum possible timeout`);
    }

    return n
  };

  return B_;
}let Vb;function KX(){
  if (Vb) {
    return Ub;
  }Vb=1;
  const e=_h();
  const t=Gl();
  const n=Eh();
  const r=SL();
  const o=WX();
  const s=mo();
  const i=Function.prototype;
  const a=Math.max;
  const c=Math.min;
  const l=Object.create;

  s.maxAge=(f, d, u) => {
    let _;
    let p;
    let E;
    let h;
    f=o(f);

    if (f) {
      _=l(null);
      p=u.async&&s.async||u.promise&&s.promise?"async":"";

      d.on(`set${p}`,T => {
        _[T]=setTimeout(() => {d.delete(T)},f);

        if (typeof _[T].unref=="function") {
          _[T].unref();
        }

        if (h) {
          h[T]&&h[T]!=="nextTick"&&clearTimeout(h[T]);
          h[T]=setTimeout(() => {delete h[T]},E);
          typeof h[T].unref=="function"&&h[T].unref();
        }
      });

      d.on(`delete${p}`,T => {
        clearTimeout(_[T]);
        delete _[T];

        if (h) {
          h[T]!=="nextTick"&&clearTimeout(h[T]);
          delete h[T];
        }
      });

      u.preFetch&&(u.preFetch===true||isNaN(u.preFetch)?E=0.333/* .333 */:E=a(c(Number(u.preFetch),1),0),E&&(h={},E=(1-E)*f,d.on(`get${p}`,(T, m, A) => {
        if (!h[T]) {
          h[T]="nextTick";

          n(() => {
            let g;

            if (h[T]==="nextTick") {
              delete h[T];
              d.delete(T);
              u.async&&(m=e(m),m.push(i));
              g=d.memoized.apply(A,m);
              u.promise&&r(g)&&(typeof g.done=="function"?g.done(i,i):g.then(i,i));
            }
          });
        }
      })));

      d.on(`clear${p}`,() => {
        t(_,T => {clearTimeout(T)});
        _={};

        if (h) {
          t(h,T => {
            if (T!=="nextTick") {
              clearTimeout(T);
            }
          });

          h={};
        }
      });
    }
  };

  return Ub;
}
const xb={};
let H_;
let $b;
function zX(){
  if ($b) {
    return H_;
  }$b=1;
  const e=So();
  const t=Object.create;
  const n=Object.prototype.hasOwnProperty;

  H_=r => {
    let o=0;
    let s=1;
    let i=t(null);
    let a=t(null);
    let c=0;
    let l;
    r=e(r);

    return {hit(f) {
      const d=a[f];
      const u=++c;
      i[u]=f;
      a[f]=u;

      if (!d) {
        ++o;
        return o<=r?void 0:(f=i[s],l(f),f);
      }

      delete i[d];

      if (s===d) {
        while (!n.call(i,++s))
          {}
      }
    },delete:l=f => {const d=a[f];if(d&&(delete i[d],delete a[f],--o,s===d)){
      if(!o){
        c=0;
        s=1;
        return
      }

      while (!n.call(i,++s))
        {}
    }},clear() {
      o=0;
      s=1;
      i=t(null);
      a=t(null);
      c=0;
    }};
  };

  return H_;
}let Bb;function ZX(){
  if (Bb) {
    return xb;
  }Bb=1;
  const e=So();
  const t=zX();
  const n=mo();

  n.max=(r, o, s) => {
    let i;
    let a;
    let c;
    r=e(r);

    if (r) {
      a=t(r);
      i=s.async&&n.async||s.promise&&n.promise?"async":"";

      o.on(`set${i}`,c=l => {
        l=a.hit(l);

        if (l!==void 0) {
          o.delete(l);
        }
      });

      o.on(`get${i}`,c);
      o.on(`delete${i}`,a.delete);
      o.on(`clear${i}`,a.clear);
    }
  };

  return xb;
}
const Hb={};
let Fb;
function XX(){
  if (Fb) {
    return Hb;
  }Fb=1;
  const e=Ao();
  const t=mo();
  const n=Object.create;
  const r=Object.defineProperties;

  t.refCounter=(o, s, i) => {
    let a;
    let c;
    a=n(null);
    c=i.async&&t.async||i.promise&&t.promise?"async":"";
    s.on(`set${c}`,(l, f) => {a[l]=f||1});
    s.on(`get${c}`,l => {++a[l]});
    s.on(`delete${c}`,l => {delete a[l]});
    s.on(`clear${c}`,() => {a={}});
    r(s.memoized,{deleteRef:e(function(...args) {const l=s.get(args);return l===null||!a[l]?null:--a[l]?false:(s.delete(l),true);}),getRefCount:e(function(...args) {const l=s.get(args);return l===null||!a[l]?0:a[l]})});
  };

  return Hb;
}
let F_;
let Yb;
function QX(...args) {
  if (Yb) {
    return F_;
  }Yb=1;
  const e=uL();
  const t=lL();
  const n=PX();

  F_=function(r){
    const o=e(args[1]);
    let s;

    if (!o.normalizer) {
      s=o.length=t(o.length,r.length,o.async);
      s!==0&&(o.primitive?s===false?o.normalizer=MX():s>1&&(o.normalizer=vX()(s)):s===false?o.normalizer=UX()():s===1?o.normalizer=kX()():o.normalizer=GX()(s));
    }

    if (o.async) {
      VX();
    }

    if (o.promise) {
      YX();
    }

    if (o.dispose) {
      jX();
    }

    if (o.maxAge) {
      KX();
    }

    if (o.max) {
      ZX();
    }

    if (o.refCounter) {
      XX();
    }

    return n(r,o);
  };

  return F_;
}const JX=QX();const dc=zp(JX);class eQ{constructor(t){
  this.i=0;
  this.string=t;

  this.whitespace=` 	\r
  `;

  this.quotes=`'"`;
  this.escapes="\\";
  this.escapedQuotes='"';
  this.ansiCQuotes=true;
  this.localeQuotes=true;
  this.debug=false;
}readChar(){return this.string.charAt(this.i++)}processEscapes(t,n,r){if (!r&&!this.escapedQuotes.includes(n)) {
  return t;
}const o=`[${this.escapes.replace(/(.)/g,"\\$1")}]`;if(!r&&this.escapedQuotes.includes(n)){const s=new RegExp(`${o}(${o}|\\${n})`,"g");return t.replace(s,"$1")}if(r){
  const s={"([\\\\'\"?])":a => a,a:() => "\x07",b:() => "\b","e|E":() => "\x1B",f:() => "\f",n:() => `
  `,r:() => "\r",t:() => "	",v:() => "\v","([0-7]{1,3})":a => String.fromCharCode(parseInt(a,8)),"x([0-9a-fA-F]{1,2})":a => String.fromCharCode(parseInt(a,16)),"u([0-9a-fA-F]{1,4})":a => String.fromCharCode(parseInt(a,16)),"U([0-9a-fA-F]{1,8})":a => String.fromCharCode(parseInt(a,16)),"c(.)":a => a==="?"?"":a==="@"?"\0":String.fromCharCode(a.charCodeAt(0)&31)};

  const i=new RegExp(`${o}(${Object.keys(s).join("|")})`,"g");
  return t.replace(i,(a, c) => {for(const l in s){const f=new RegExp(`^${l}$`).exec(c);if (f!==null) {
    return s[l].apply(null,f.slice(1))
  }}});
}}*[Symbol.iterator](){
  let t=false;
  let n=false;
  let r=false;
  let o=-2;
  let s;
  for(this.debug&&console.log("full input:",`>${this.string}<`);;){
    const i=this.i;
    const a=this.readChar();

    if (this.debug) {
      console.log("position:",i,"input:",`>${a}<`,"accumulated:",s,"inQuote:",t,"inDollarQuote:",n,"lastDollar:",o,"escaped:",r);
    }

    if (a==="") {
      if (t) {
        throw new Error("Got EOF while in a quoted string");
      }if (r) {
        throw new Error("Got EOF while in an escape sequence");
      }

      if (s!==void 0) {
        (yield s);
      }

      return
    }

    if(r){
      if (a !== `
      `) {
        if (t) {
          s=(s||"")+r+a;
        } else {
          s=(s||"")+a;
        }
      }

      r=false;
      continue
    }if(this.escapes.includes(a)&&(!t||n!==false||this.escapedQuotes.includes(t))){r=a;continue}if(t!==false){if(a===t){
        s=this.processEscapes(s,t,n==="'");
        t=false;
        n=false;
        continue
      }s=(s||"")+a;continue}if(this.quotes.includes(a)){
      t=a;

      if (o===i-1) {
        if ((a !== "'" || this.ansiCQuotes) && (a !== '"' || this.localeQuotes)) {
          (n = a);
        }
      }

      s=s||"";

      if (n!==false) {
        (s = s.slice(0,-1));
      }

      continue
    }

    if (t===false&&a==="$") {
      (o = i);
    }

    if (this.whitespace.includes(a)) {
      if (s!==void 0) {
        (yield s);
      }

      s=void 0;
      continue
    }

    s=(s||"")+a
  }
}}function tQ(e){return Array.from(new eQ(e))}function Vt(e){return e===""?"''":/[^\w@%\-+=:,./]/.test(e)?(`'${e.replace(/('+)/g,`'"$1"'`)}'`).replace(/^''|''$/g,""):e;}function nQ(e){if (!Array.isArray(e)) {
  throw new TypeError("args should be an array");
}return e.map(Vt).join(" ")}function rQ(e){if (!e.startsWith("[")) {
  return{loggerName:null,message:e};
}const t=e.indexOf("]");if (t===-1) {
  return{loggerName:null,message:e};
}if (e[t+1]!==" ") {
  return{loggerName:null,message:e};
}const n=e.slice(1,t).trim();if (!n) {
  return{loggerName:null,message:e};
}const r=e.slice(t+2);return{loggerName:n,message:r}}class mL{buffer=[];maxBufferSize=500;hasLoggedDroppedLogMessage=false;push(t){if(this.buffer.length>=this.maxBufferSize){
  if (!this.hasLoggedDroppedLogMessage) {
    this.hasLoggedDroppedLogMessage=true;
    this.buffer.push({level:"warning",message:"Dropped buffered log message after maxBufferSize was reached",args:[]});
  }

  return
}this.buffer.push(t)}createLogMethod(t){return(n,...r)=>{this.push({level:t,message:n,args:r})}}trace=this.createLogMethod("trace");debug=this.createLogMethod("debug");info=this.createLogMethod("info");warning=this.createLogMethod("warning");error=this.createLogMethod("error");log=(t,n,...r)=>{this.push({level:t,message:n,args:r})};flushTo(t){for (const n of this.buffer) {
  t.log(n.level,n.message,...n.args);
}this.buffer.length=0}dispose(){this.buffer=[]}}
let ru=new mL;
let jb=false;
function oQ(e){
  if (jb&&process.env.NODE_ENV!=="test") {
    throw new Error("Logger already set");
  }
  jb=true;

  if (ru instanceof mL) {
    ru.flushTo(e);
  }

  ru=e;
}function fc(){return ru}function xl(e){
  const t=`[${e}] `;
  const n=(o,s,...i)=>{fc().log(o,`${t}${s}`,...i)};

  const r=o => (s,...i)=>{n(o,s,...i)};

  return{trace:r("trace"),debug:r("debug"),info:r("info"),warning:r("warning"),error:r("error"),log:(o,s,...i)=>{n(o,s,...i)},dispose:()=>{fc().dispose()}}
}function Pt(e){let t=null;return () => {
  if (!t) {
    (t = xl(e));
  }

  return t;
};}function AL(e){
  const t=Date.now();
  const n=xl(e);

  const r=(o, ...s) => [`[${((Date.now()-t)/1000/* 1e3 */).toFixed(3)}] ${o}`,...s];

  return{trace:(o,...s)=>{n.trace(...r(o,...s))},debug:(o,...s)=>{n.debug(...r(o,...s))},info:(o,...s)=>{n.info(...r(o,...s))},warning:(o,...s)=>{n.warning(...r(o,...s))},error:(o,...s)=>{n.error(...r(o,...s))},log:(o,s,...i)=>{n.log(o,...r(s,...i))},dispose:()=>{n.dispose()}}
}
const Ln={};
let qb;
function sQ(){
  if (qb) {
    return Ln;
  }qb=1;const e=Ln&&Ln.__importDefault||(d => d&&d.__esModule?d:{default:d});
  Object.defineProperty(Ln,"__esModule",{value:true});
  Ln.RateLimit = void 0;
  Ln.Sema = void 0;
  const t=e(zu);function n(d,u,_,p,E){for (let h=0; h<E; ++h) {
    _[h+p]=d[h+u];
    d[h+u]=void 0;
  }}function r(d){
    d=d>>>0;
    d=d-1;
    d=d|d>>1;
    d=d|d>>2;
    d=d|d>>4;
    d=d|d>>8;
    d=d|d>>16;
    return d+1;
  }function o(d){return r(Math.min(Math.max(16,d),1073741824))}class s{constructor(u){
    this._capacity=o(u);
    this._length=0;
    this._front=0;
    this.arr=[];
  }push(u){
    const _=this._length;this.checkCapacity(_+1);const p=this._front+_&this._capacity-1;
    this.arr[p]=u;
    this._length=_+1;
    return _+1;
  }pop(){
    const u=this._length;if (u===0) {
      return;
    }
    const _=this._front+u-1&this._capacity-1;
    const p=this.arr[_];
    this.arr[_]=void 0;
    this._length=u-1;
    return p;
  }shift(){
    const u=this._length;if (u===0) {
      return;
    }
    const _=this._front;
    const p=this.arr[_];
    this.arr[_]=void 0;
    this._front=_+1&this._capacity-1;
    this._length=u-1;
    return p;
  }get length(){return this._length}checkCapacity(u){
  if (this._capacity<u) {
    this.resizeTo(o(this._capacity*1.5+16));
  }
}resizeTo(u){
    const _=this._capacity;this._capacity=u;
    const p=this._front;
    const E=this._length;
    if(p+E>_){const h=p+E&_-1;n(this.arr,0,this.arr,_,h)}
  }}class i extends t.default{}function a(d){return typeof d=="function"}function c(){return"1"}class l{constructor(u,{initFn:_=c,pauseFn:p,resumeFn:E,capacity:h=10}={}){
    if (a(p)!==a(E)) {
      throw new Error("pauseFn and resumeFn must be both set for pausing");
    }
    this.nrTokens=u;
    this.free=new s(u);
    this.waiting=new s(h);
    this.releaseEmitter=new i;
    this.noTokens=_===c;
    this.pauseFn=p;
    this.resumeFn=E;
    this.paused=false;
    this.releaseEmitter.on("release",T=>{
      const m=this.waiting.shift();

      if (m) {
        m.resolve(T);
      } else {
        this.resumeFn&&this.paused&&(this.paused=false,this.resumeFn());
        this.free.push(T);
      }
    });
    for (let T=0; T<u; T++) {
      this.free.push(_())
    }
  }tryAcquire(){return this.free.pop()}async acquire(){let u=this.tryAcquire();return u!==void 0?u:new Promise((_,p)=>{
  if (this.pauseFn&&!this.paused) {
    this.paused=true;
    this.pauseFn();
  }

  this.waiting.push({resolve:_,reject:p});
});}release(u){this.releaseEmitter.emit("release",this.noTokens?"1":u)}drain(){const u=new Array(this.nrTokens);for (let _=0; _<this.nrTokens; _++) {
    u[_]=this.acquire();
  }return Promise.all(u)}nrWaiting(){return this.waiting.length}}Ln.Sema=l;function f(d,{timeUnit:u=1000/* 1e3 */,uniformDistribution:_=false}={}){
    const p=new l(_?1:d);
    const E=_?u/d:u;
    return async () => {
      await p.acquire();

      setTimeout(() => p.release(),E);
    };
  }
  Ln.RateLimit=f;
  return Ln;
}const gL=sQ();class RL{constructor(t,n=[],r=[],o){
  this.child=t;
  this.stdoutChunks=n;
  this.stderrChunks=r;

  this.promise=o.then(({code,signal}) => ({
    type:"resolve",
    code:code,
    signal:signal
  }),s => ({
    type:"reject",
    error:s
  }));
}result=null;promise;check(){return this.wait().then(({stdout,stderr,code,signal})=>{if (code===0) {
  return {stdout:stdout,stderr:stderr};
}throw new Error(`process exited with code ${code}, signal ${signal}`)});}wait(){return this.promise.then(t=>{switch(t.type){case"resolve":{const{code,signal}=t;return {stdout:Buffer.concat(this.stdoutChunks).toString("utf8"),stderr:Buffer.concat(this.stderrChunks).toString("utf8"),code:code,signal:signal};}case "reject":
  {
    throw t.error
  }}});}getStdout(){return Buffer.concat(this.stdoutChunks)}getStderr(){return Buffer.concat(this.stderrChunks)}getExitCode(){return this.result?.type==="resolve"?this.result.code:null}isDone(){return this.result!=null}kill(){this.child.kill()}}const iQ={startSpan:(e, t) => t()};let NL=iQ;function aQ(e){NL=e}function cQ(){return NL}function hh(e,t){return cQ().startSpan(e,t)}let xu;function uQ(e){if (xu) {
  throw new Error("shouldSpawnInsideWsl already set");
}xu=e}function lQ(){if(!xu){if (process.env.NODE_ENV==="test"||process.env.VITEST!=null) {
  return false;
}throw new Error("shouldSpawnInsideWsl not set")}return xu()}function dQ(){
  const e=fc();
  const t=fQ(e);
  if (!t) {
    return;
  }if (EQ(t)) {
    return Vp(t);
  }if (pQ(t)) {
    return Vp(hQ(t));
  }const n=_Q(t,e);if (n) {
    return n;
  }e.warning(`[resolveCodexHomeFromWsl] Unable to translate Linux path (${st(t)}) to a Windows path`)
}function fQ(e){return yL(["/usr/bin/env","bash","-lc",'printf %s "${CODEX_HOME:-$HOME/.codex}"'],"readCodexHomePathFromWslEnv",e)}function _Q(e,t){const n=yL(["wslpath","-w",e],`resolveCodexHomeFromWsl:wslpath(${e})`,t);return n?Vp(n):void 0}function yL(e,t,n){try{const r=Kp.spawnSync("wsl.exe",e,{encoding:"utf8",windowsHide:true});if(r.error){n.debug(`[${t}] command error (${st(r.error)})`);return}if(r.status!==0){n.debug(`[${t}] non-zero exit (${st(r.status)}): ${st(r.stderr?.toString()??"")}`);return}const o=r.stdout?.toString().trim();if(!o){n.warning(`[${t}] command returned empty output`);return}return o}catch(r){n.warning(`[${t}] unexpected error (${st(r)})`);return}}function Vp(e){return e.replace(/\//g,"\\");}function pQ(e){return /^\/mnt\/[a-zA-Z]\//.test(e)?true:/^\\{1,2}mnt\\[a-zA-Z]\\/.test(e);}function EQ(e){return !!(/^[a-zA-Z]:[\\/]/.test(e)||/^\\\\/.test(e));}function hQ(e){const t=e.match(/^\/mnt\/([a-zA-Z])\/(.*)$/);if(t){
  const o=t[1].toUpperCase();
  const s=t[2].replace(/\//g,"\\");
  return`${o}:\\${s}`
}const n=e.match(/^\\{1,2}[Mm][Nn][Tt]\\([a-zA-Z])\\(.*)$/i);if(n){
  const o=n[1].toUpperCase();
  const s=n[2].replace(/[\\/]/g,"\\");
  return`${o}:\\${s}`
}const r=e.match(/^C:\\mnt\\c(.*)$/i);return r?`C:\\${r[1].replace(/^([\\/])+/,"").replace(/[\\/]/g,"\\")}`:e.replace(/\//g,"\\");}function OL(e){if(/^(\\\\|\/\/)(wsl\$|wsl\.localhost)/i.test(e)){const r=e.replace(/^((\\\\|\/\/)(wsl\$|wsl\.localhost)[\\/]+)/i,"").split(/[\\/]/);r.shift();const o=r.join("/").replace(/\\/g,"/");return o.length===0?"/":o.startsWith("/")?o:`/${o}`}if (e.startsWith("/")) {
  return e;
}const t=e.match(/^([a-zA-Z]):[\\/](.*)$/);if(t){
  const n=t[1].toLowerCase();
  const r=t[2].replace(/\\/g,"/");
  return`/mnt/${n}/${r}`
}return e.replace(/\\/g,"/");}const bL=Pt("spawn-async");function CL(e){const t=e[0]??"process";return t==="git"&&e[1]?{op:"git.exec",name:`git ${e[1]}`}:{op:"process.exec",name:t}}function IL({args,cwd,env,signal,stdoutChunkHandler,stderrChunkHandler,onExitHandler}){
  if (lQ()) {
    bL().info("Spawning process inside WSL");
    return TQ(args,cwd,env?SQ(env):void 0,signal,stdoutChunkHandler,stderrChunkHandler);
  }
  const a=args[0];
  const c=args.slice(1);
  const l={cwd:cwd,env:{...process.env,...env},stdio:["ignore","pipe","pipe"]};
  const f=Kp.spawn(a,c,l);
  const d=[];
  const u=[];

  const _=new Promise((E,h)=>{
    const T=PL(f,signal);

    f.stdout?.on("data",m=>{
      d.push(m);
      stdoutChunkHandler?.(m);
    });

    f.stderr?.on("data",m=>{
      u.push(m);
      stderrChunkHandler?.(m);
    });

    f.on("close",(m,A)=>{
      onExitHandler?.();
      T?.();
      E({code:m,signal:A});
    });

    f.on("error",m=>{
      onExitHandler?.();
      T?.();
      h(m);
    });
  });

  const p=CL(args);
  return new RL(f,d,u,hh(p,() => _));
}function TQ(e,t,n,r,o,s){
  const i=t?OL(t):".";
  const a=["RUST_LOG=warn"];

  if (n) {
    a.push(...mQ(n));
  }

  const c=["-d","Ubuntu"];
  c.push("--cd",i);
  c.push("--exec","/usr/bin/env",...a,...e);
  const l={env:{...process.env},stdio:["ignore","pipe","pipe"]};bL().debug("Spawning process inside WSL: wsl.exe %s",c.join(" "));
  const f=Kp.spawn("wsl.exe",c,l);
  const d=[];
  const u=[];

  const _=new Promise((E,h)=>{
    const T=PL(f,r);

    f.stdout?.on("data",m=>{
      d.push(m);
      o?.(m);
    });

    f.stderr?.on("data",m=>{
      u.push(m);
      s?.(m);
    });

    f.on("close",(m,A)=>{
      T?.();
      E({code:m,signal:A});
    });

    f.on("error",m=>{
      T?.();
      h(m);
    });
  });

  const p=CL(e);
  return new RL(f,d,u,hh(p,() => _));
}function PL(e,t){
  if (!t) {
    return;
  }const n=()=>{e.kill()};
  t.addEventListener("abort",n);

  if (t.aborted) {
    n();
  }

  return ()=>{t.removeEventListener("abort",n)};
}function SQ(e){const t={};for (const[n,r] of Object.entries(e)) {
  if (r!=null&&process.env[n]!==r) {
    (t[n] = r);
  }
}return t}function mQ(e){const t=[];for(const[n,r]of Object.entries(e)){const o=AQ(r)?OL(r):r;t.push(`${n}=${o}`)}return t}function AQ(e){return e.includes(";")?false:!!(/^(?:[a-zA-Z]:[\\/]|\\\\|\/\/)/.test(e)||/^(\\\\|\/\/)(wsl\$|wsl\.localhost)[\\/]/i.test(e));}
const gQ=4;
const RQ=1000/* 1e3 */;
const Y_=new Map;
const j_=Pt("spawn-remote-async");
function NQ(e){
  if (!Y_.has(e)) {
    Y_.set(e,new gL.Sema(gQ));
  }

  return Y_.get(e);
}class yQ{constructor(t,n){
  this.semaphore=t;
  this.timeout=n;
}releaseTimeout=null;released=false;async acquire(){
  await this.semaphore.acquire();
  this.releaseTimeout=setTimeout(()=>{this.release()},this.timeout);
}release(){
  if (!this.released) {
    this.released=true;
    this.releaseTimeout&&clearTimeout(this.releaseTimeout);
    this.semaphore.release();
  }
}}async function ur({hostConfig,args,env,signal,timeoutMs,noConcurrencyLimit,stdoutChunkHandler,stderrChunkHandler}){
  const c=env?Object.entries(env).map(([p,E]) => `${p}=${E}`):[];

  const l=[...hostConfig.terminal_command,"--",...c,...args];
  let f=null;if(!noConcurrencyLimit){
      const p=NQ(hostConfig.id);
      f=new yQ(p,RQ);
      await f.acquire();
    }
  let d=false;
  let u=null;
  const _=IL({args:l,signal:signal,stdoutChunkHandler:stdoutChunkHandler,stderrChunkHandler:stderrChunkHandler,onExitHandler:()=>{
    d=true;

    if (u) {
      clearTimeout(u);
    }

    if (f) {
      f.release();
    }
  }});

  if (timeoutMs!=null) {
    u=setTimeout(()=>{_.kill()},timeoutMs);
    d&&u&&(clearTimeout(u),u=null);
  }

  return _;
}async function wn({hostConfig,args,errorOnNonZeroExitCode=true}){
  const r=crypto.randomUUID().slice(0,8);j_().debug(`[${r}] Spawning process with args: ${args.join(" ")}`);
  const o=await ur({hostConfig:hostConfig,args:args});
  const {stdout,stderr,code}=await o.wait();
  if (code!==0) {
    j_().debug(`[${r}] Process errored with code ${code} stderr=${stderr}`);

    if (errorOnNonZeroExitCode) {
      throw new Error(`Process errored with code ${code} stderr=${stderr}`)
    }
  } else {
    j_().debug(`[${r}] Process exited successfully with code ${code}`);
  }return {stdout:stdout,stderr:stderr,code:code};
}
const OQ=60000/* 6e4 */;
const bQ=60*OQ;
const Th=24*bQ;
function CQ(e){
  const {preferWsl=false}=e;
  const n=fc();
  if(preferWsl&&process.platform==="win32"){const r=dQ();if (r) {
    return r;
  }n.info("[resolveCodexHome] Falling back to host home directory because WSL CODEX_HOME could not be resolved")}return process.env.CODEX_HOME??FC.join(wt.homedir(),".codex")
}const IQ=dc(async e=>{const t=typeof e=="string"?MQ(e):e;return PQ(t)},{length:1,normalizer:([e]) => typeof e=="string"?e:e.id,promise:true,maxAge:Th});async function PQ(e){
  const t=fc();
  const r=["sh","-lc",Vt('if [ -n "$CODEX_HOME" ]; then printf "%s" "$CODEX_HOME"; else printf "%s" "$HOME/.codex"; fi')];
  let o;
  let s=false;
  const i=setTimeout(()=>{
    s=true;
    o?.kill();
  },10000/* 1e4 */);try{
    o=await ur({hostConfig:e,args:r});const{stdout,stderr,code}=await o.wait();
    clearTimeout(i);

    if (s) {
      t.warning("[resolveRemoteSshCodexHome] timed out");
      throw new Error("resolveRemoteSshCodexHome timed out");
    }

    if (code!==0) {
      throw new Error(`[resolveRemoteSshCodexHome] failed (${code}): ${stderr||stdout}`);
    }return stdout.trim();
  }catch(a){
    clearTimeout(i);
    t.warning(`[resolveRemoteSshCodexHome] error: ${st(a)}`);
    throw a;
  }
}function MQ(e){return{id:e,display_name:e,kind:"ssh",codex_cli_command:[],terminal_command:tQ(e)}}const lr={async readFile(e,t){if(Ue(t)){const{stdout}=await wn({hostConfig:t,args:["cat",e]});return stdout;}return de.promises.readFile(e,"utf-8")},async readFileBase64(e,t){if(Ue(t)){const{stdout}=await wn({hostConfig:t,args:["base64",e]});return Buffer.from(stdout,"base64");}return de.promises.readFile(e,"base64")},async writeFile(e,t,n){if(Ue(n)){await wn({hostConfig:n,args:["sh","-c",Vt(`cat > ${e} << "EOF"
${t}
EOF`)]});return}await de.promises.writeFile(e,t,"utf8")},async mkdir(e,t={},n){if(Ue(n)){
  const r=["mkdir"];

  if (t.recursive!==false) {
    r.push("-p");
  }

  r.push(e);
  await wn({hostConfig:n,args:r});
  return
}await de.promises.mkdir(e,{recursive:t.recursive??true})},async stat(e,t){if (!Ue(t)) {
  return de.promises.stat(e);
}const{stdout,code}=await wn({hostConfig:t,args:["sh","-c",Vt('if [ -d "$1" ]; then echo "dir"; elif [ -f "$1" ]; then echo "file"; elif [ -L "$1" ]; then echo "link"; else exit 1; fi'),"sh",e],errorOnNonZeroExitCode:false});if (code===1) {
  throw new Error(`File not found: ${e}`);
}const o=stdout.trim();return {isDirectory:() => o==="dir",isFile:() => o==="file"||o==="link"};},async readdir(e,t){if(Ue(t)){const{stdout}=await wn({hostConfig:t,args:["sh","-c",Vt('ls -A "$1"'),"sh",e]});return stdout.split(/\r?\n/).map(r => r.trim()).filter(r => r.length>0);}return de.promises.readdir(e)},async rm(e,t={},n){if(Ue(n)){
  const r=["rm"];

  if (t.recursive!==false) {
    r.push("-r");
  }

  if (t.force!==false) {
    r.push("-f");
  }

  r.push(e);
  await wn({hostConfig:n,args:r});
  return
}await de.promises.rm(e,{recursive:t.recursive??true,force:t.force??true})},async copyFile(e,t,n){if(Ue(n)){await wn({hostConfig:n,args:["cp",e,t]});return}await de.promises.copyFile(e,t)},async cp(e,t,n={},r){if(Ue(r)){
  const o=["cp"];

  if (n.recursive) {
    o.push("-R");
  }

  o.push(e,t);
  await wn({hostConfig:r,args:o});
  return
}await de.promises.cp(e,t,{recursive:n.recursive??false})}};function fn(e){return Ue(e)?ce.posix:ce}class vQ{handlers=new Set;subscribe(t){
  this.handlers.add(t);
  return {dispose:()=>{this.handlers.delete(t)}};
}emit(t,n=Date.now()){for (const r of this.handlers) {
  r({type:t,at:n})
}}}
const LQ=["IN_PROGRESS","PENDING_REVIEW"];
const wQ=["IN_PROGRESS","PENDING_REVIEW","ACCEPTED","ARCHIVED"];

const ML=e => `(${e.map(t => `'${t}'`).join(", ")})`;

ML(LQ);ML(wQ);
const xp=["MO","TU","WE","TH","FR","SA","SU"];

const gt = (() => {
  function e(t,n){
    if (n===0) {
      throw new Error("Can't create weekday with n == 0");
    }
    this.weekday=t;
    this.n=n;
  }
  e.fromStr=t => new e(xp.indexOf(t));
  e.prototype.nth=function(t){return this.n===t?this:new e(this.weekday,t)};
  e.prototype.equals=function(t){return this.weekday===t.weekday&&this.n===t.n};

  e.prototype.toString=function(){
    let t=xp[this.weekday];

    if (this.n) {
      (t = (this.n>0?"+":"")+String(this.n)+t);
    }

    return t;
  };

  e.prototype.getJsWeekday=function(){return this.weekday===6?0:this.weekday+1};
  return e;
})();

const ze=e => e!=null;
const hn=e => typeof e=="number";
const Wb=e => typeof e=="string"&&xp.includes(e);
const kt=Array.isArray;

const bn=function(e, t = e) {
  if (arguments.length===1) {
    t=e;
    e=0;
  }

  const n=[];
  for (let r=e; r<t; r++) {
    n.push(r);
  }return n
};

const be=(e, t) => {
  let n=0;
  const r=[];
  if (kt(e)) {
    for (; n<t; n++) {
      r[n]=[].concat(e);
    }
  } else {
    for (; n<t; n++) {
      r[n]=e;
    }
  }return r
};

const DQ=e => kt(e)?e:[e];
function Ro(e, t, n = " ") {
  const r=String(e);
  t=t>>0;
  return r.length>t?String(r):(t=t-r.length,t>n.length&&(n+=be(n,t/n.length)),n.slice(0,t)+String(r));
}
const UQ=(e, t, n) => {const r=e.split(t);return n?r.slice(0,n).concat([r.slice(n).join(t)]):r};
const Ht=(e, t) => {const n=e%t;return n*t<0?n+t:n};
const q_=(e, t) => ({
  div:Math.floor(e/t),
  mod:Ht(e,t)
});
const mn=e => !ze(e)||e.length===0;
const rt=e => !mn(e);
const De=(e, t) => rt(e)&&e.includes(t);

const uo=(e, t, n, r = 0, o = 0, s = 0) => {
  return new Date(Date.UTC(e,t-1,n,r,o,s));
};

const kQ=[31,28,31,30,31,30,31,31,30,31,30,31];
const vL=1000/* 1e3 */*60*60*24;
const LL=9999;
const wL=uo(1970,1,1);
const GQ=[6,0,1,2,3,4,5];
const Xa=e => e%4===0&&e%100!==0||e%400===0;
const DL=e => e instanceof Date;
const qa=e => DL(e)&&!isNaN(e.getTime());

const VQ=(e, t) => {
  const n=e.getTime();
  const r=t.getTime();
  const o=n-r;
  return Math.round(o/vL)
};

const $p=e => VQ(e,wL);
const UL=e => new Date(wL.getTime()+e*vL);
const xQ=e => {const t=e.getUTCMonth();return t===1&&Xa(e.getUTCFullYear())?29:kQ[t]};
const Fo=e => GQ[e.getUTCDay()];
const Kb=(e, t) => {const n=uo(e,t+1,1);return[Fo(n),xQ(n)]};

const kL=(e, t) => {
  t=t||e;
  return new Date(Date.UTC(e.getUTCFullYear(),e.getUTCMonth(),e.getUTCDate(),t.getHours(),t.getMinutes(),t.getSeconds(),t.getMilliseconds()));
};

const Bp=e => {const t=new Date(e.getTime());return t};

const zb=e => {
  const t=[];
  for (let n=0; n<e.length; n++) {
    t.push(Bp(e[n]));
  }return t
};

const _c=e => {e.sort((t, n) => t.getTime()-n.getTime())};
const Sh=(e, t = true) => {
  const n=new Date(e);return[Ro(n.getUTCFullYear().toString(),4,"0"),Ro(n.getUTCMonth()+1,2,"0"),Ro(n.getUTCDate(),2,"0"),"T",Ro(n.getUTCHours(),2,"0"),Ro(n.getUTCMinutes(),2,"0"),Ro(n.getUTCSeconds(),2,"0"),t?"Z":""].join("")
};

const mh=e => {
  const t=/^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/;
  const n=t.exec(e);
  if (!n) {
    throw new Error(`Invalid UNTIL value: ${e}`);
  }return new Date(Date.UTC(parseInt(n[1],10),parseInt(n[2],10)-1,parseInt(n[3],10),parseInt(n[5],10)||0,parseInt(n[6],10)||0,parseInt(n[7],10)||0))
};

const Zb=(e, t) => {const n=e.toLocaleString("sv-SE",{timeZone:t});return `${n.replace(" ","T")}Z`;};

const $Q=(e, t) => {
  const n=Intl.DateTimeFormat().resolvedOptions().timeZone;
  const r=new Date(Zb(e,n));
  const o=new Date(Zb(e,t??"UTC"));
  const s=o.getTime()-r.getTime();
  return new Date(e.getTime()-s)
};

const Io = (() => {
  function e(t,n){
    this.minDate=null;
    this.maxDate=null;
    this._result=[];
    this.total=0;
    this.method=t;
    this.args=n;

    switch (t) {
    case "between":
      this.maxDate=n.inc?n.before:new Date(n.before.getTime()-1);
      this.minDate=n.inc?n.after:new Date(n.after.getTime()+1);
      break;
    case "before":
      this.maxDate=n.inc?n.dt:new Date(n.dt.getTime()-1);
      break;
    case "after":
      (this.minDate = n.inc?n.dt:new Date(n.dt.getTime()+1));
      break;
    }
  }

  e.prototype.accept=function(t){
    ++this.total;
    const n=this.minDate&&t<this.minDate;
    const r=this.maxDate&&t>this.maxDate;
    if(this.method==="between"){if (n) {
      return true;
    }if (r) {
      return false;
    }}else if(this.method==="before"){if (r) {
      return false;
    }}else if (this.method==="after") {
      return n?true:(this.add(t),false);
    }return this.add(t)
  };

  e.prototype.add=function(t){
    this._result.push(t);
    return true;
  };

  e.prototype.getValue=function(){const t=this._result;switch(this.method){case"all":case "between":
    {
      return t;
    }case"before":case"after":default:
    {
      return t.length?t[t.length-1]:null
    }}};

  e.prototype.clone=function(){return new e(this.method,this.args)};
  return e;
})();

const W_={exports:{}};
let Xb;
function BQ(...args) {
  if (!Xb) {
    Xb=1;

    (e => {
      let t;
      let n;
      let r;
      let o;
      let s;
      let i;
      let a;
      let c;
      let l;
      let f;
      let d;
      let u;
      let _;
      let p;
      let E;
      let h;
      let T;
      let m;
      let A;
      let g;
      let R;
      let O;
      let I;
      let b;
      let L;
      let U;
      let q;
      let H;
      let $;
      let B;
      let F;
      let D;
      (function(k){const Y=typeof rp=="object"?rp:typeof self=="object"?self:typeof this=="object"?this:{};k(oe(Y,oe(e.exports)));function oe(ae,ne){
        if (ae!==Y) {
          if (typeof Object.create=="function") {
            Object.defineProperty(ae,"__esModule",{value:true});
          } else {
            ae.__esModule=true;
          }
        }

        return (P, M) => ae[P]=ne?ne(P,M):M;
      }})(k => {
        const Y=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&((P, M) => {P.__proto__=M})||((P, M) => {for (const G in M) {
          if (Object.prototype.hasOwnProperty.call(M,G)) {
            (P[G] = M[G]);
          }
        }});

        t=(P, M) => {if (typeof M!="function"&&M!==null) {
          throw new TypeError(`Class extends value ${String(M)} is not a constructor or null`);
        }Y(P,M);function G(){this.constructor=P}P.prototype=M===null?Object.create(M):(G.prototype=M.prototype,new G)};

        n=Object.assign||function(P){
          let M;
          for(let G=1, V=args.length;G<V;G++){M=args[G];for (const K in M) {
            if (Object.prototype.hasOwnProperty.call(M,K)) {
              (P[K] = M[K]);
            }
          }}return P
        };

        r=(P, M) => {const G={};for (var V in P) {
          if (Object.prototype.hasOwnProperty.call(P,V)&&!M.includes(V)) {
            (G[V] = P[V]);
          }
        }if (P!=null&&typeof Object.getOwnPropertySymbols=="function") {
          for (var K=0,V=Object.getOwnPropertySymbols(P); K<V.length; K++) {
            if (!M.includes(V[K])&&Object.prototype.propertyIsEnumerable.call(P,V[K])) {
              (G[V[K]] = P[V[K]]);
            }
          }
        }return G};

        o=function(P,M,G,V){
          const K=args.length;
          let X=K<3?M:V===null?V=Object.getOwnPropertyDescriptor(M,G):V;
          let v;
          if (typeof Reflect=="object"&&typeof Reflect.decorate=="function") {
            X=Reflect.decorate(P,M,G,V);
          } else {
            for (let w=P.length-1; w>=0; w--) {
              if ((v = P[w])) {
                (X = (K<3?v(X):K>3?v(M,G,X):v(M,G))||X);
              }
            }
          }

          if (K>3&&X) {
            Object.defineProperty(M,G,X);
          }

          return X;
        };

        s=(P, M) => (G, V) => {M(G,V,P)};

        i=(P, M, G, V, K, X) => {
          function v(we){if (we!==void 0&&typeof we!="function") {
            throw new TypeError("Function expected");
          }return we}
          const w=V.kind;
          const z=w==="getter"?"get":w==="setter"?"set":"value";
          const j=!M&&P?V.static?P:P.prototype:null;
          const ee=M||(j?Object.getOwnPropertyDescriptor(j,V.name):{});
          let te;
          let _e=false;
          for(let se=G.length-1;se>=0;se--){const ue={};for (var Te in V) {
            ue[Te]=Te==="access"?{}:V[Te];
          }for (var Te in V.access) {
            ue.access[Te]=V.access[Te];
          }ue.addInitializer=we => {if (_e) {
            throw new TypeError("Cannot add initializers after decoration has completed");
          }X.push(v(we||null))};const ve=(0,G[se])(w==="accessor"?{get:ee.get,set:ee.set}:ee[z],ue);if (w==="accessor") {
            if (ve===void 0) {
              continue;
            }if (ve===null||typeof ve!="object") {
                throw new TypeError("Object expected");
              }

            if ((te = v(ve.get))) {
              (ee.get = te);
            }

            if ((te = v(ve.set))) {
              (ee.set = te);
            }

            if ((te = v(ve.init))) {
              K.unshift(te);
            }
          } else {
            if ((te = v(ve))) {
              if (w==="field") {
                K.unshift(te);
              } else {
                ee[z]=te;
              }
            }
          }}

          if (j) {
            Object.defineProperty(j,V.name,ee);
          }

          _e=true;
        };

        a=function(P,M,G){
          const V=args.length>2;
          for (let K=0; K<M.length; K++) {
            G=V?M[K].call(P,G):M[K].call(P);
          }return V?G:void 0
        };

        c=P => typeof P=="symbol"?P:`${P}`;

        l=(P, M, G) => {
          if (typeof M=="symbol") {
            (M = M.description?`[${M.description}]`:"");
          }

          return Object.defineProperty(P,"name",{configurable:true,value:G?`${G} ${M}`:M});
        };

        f=(P, M) => {if (typeof Reflect=="object"&&typeof Reflect.metadata=="function") {
          return Reflect.metadata(P,M)
        }};

        d=(P, M, G, V) => {function K(X){return X instanceof G?X:new G(v => {v(X)});}return new(G||(G=Promise))((X, v) => {function w(ee){try{j(V.next(ee))}catch(te){v(te)}}function z(ee){try{j(V.throw(ee))}catch(te){v(te)}}function j(ee){
          if (ee.done) {
            X(ee.value);
          } else {
            K(ee.value).then(w,z);
          }
        }j((V=V.apply(P,M||[])).next())});};

        u=(P, M) => {
          let G={label:0,sent() {if (X[0]&1) {
            throw X[1];
          }return X[1]},trys:[],ops:[]};

          let V;
          let K;
          var X;
          let v=Object.create((typeof Iterator=="function"?Iterator:Object).prototype);
          v.next=w(0);
          v.throw=w(1);
          v.return=w(2);

          if (typeof Symbol=="function") {
            (v[Symbol.iterator] = function(){return this});
          }

          return v;
          function w(j){return ee => z([j,ee]);}function z(j){
            if (V) {
                throw new TypeError("Generator is already executing.");
              }

            while ((v&&(v=0,j[0]&&(G=0)), G)) {
                try{
                  V=1;

                  if (K&&(X=j[0]&2?K.return:j[0]?K.throw||((X=K.return)&&X.call(K),0):K.next)&&!(X=X.call(K,j[1])).done) {
                    return X;
                  }

                  K=0;

                  if (X) {
                    (j = [j[0]&2,X.value]);
                  }

                  switch (j[0]) {
                  case 0:
                  case 1:
                    {
                      X=j;break;
                    }
                  case 4:
                    {
                      G.label++;
                      return {value:j[1],done:false};
                    }
                  case 5:
                    {
                      G.label++;
                      K=j[1];
                      j=[0];
                      continue;
                    }
                  case 7:
                    {
                      j=G.ops.pop();
                      G.trys.pop();
                      continue;
                    }
                  default:
                    {
                      X=G.trys;

                      if (!(X=X.length>0&&X[X.length-1])&&(j[0]===6||j[0]===2))
                        {G=0;continue}

                      if(j[0]===3&&(!X||j[1]>X[0]&&j[1]<X[3])){G.label=j[1];break}if(j[0]===6&&G.label<X[1]){
                          G.label=X[1];
                          X=j;
                          break
                        }if(X&&G.label<X[2]){
                          G.label=X[2];
                          G.ops.push(j);
                          break
                        }

                      if (X[2]) {
                        G.ops.pop();
                      }

                      G.trys.pop();
                      continue
                    }
                  }

                  j=M.call(P,G)
                }catch(ee){
                  j=[6,ee];
                  K=0;
                }finally{
                  V = 0;
                  X = 0;
                }
              }

            if (j[0]&5) {
                throw j[1];
              }return {value:j[0]?j[1]:void 0,done:true};
          }
        };

        _=(P, M) => {for (const G in P) {
          if (G!=="default"&&!Object.prototype.hasOwnProperty.call(M,G)) {
            $(M,P,G);
          }
        }};

        $=Object.create?((P, M, G, V = G) => {
          let K=Object.getOwnPropertyDescriptor(M,G);

          if ((!K || ("get"in K ? !M.__esModule : K.writable||K.configurable))) {
            (K = {enumerable:true,get() {return M[G]}});
          }

          Object.defineProperty(P,V,K);
        }):((P, M, G, V = G) => {
          P[V]=M[G];
        });

        p=P => {
          const M=typeof Symbol=="function"&&Symbol.iterator;
          const G=M&&P[M];
          let V=0;
          if (G) {
            return G.call(P);
          }if (P&&typeof P.length=="number") {
            return {next() {
              if (P&&V>=P.length) {
                (P = void 0);
              }

              return {value:P&&P[V++],done:!P};
            }};
          }throw new TypeError(M?"Object is not iterable.":"Symbol.iterator is not defined.")
        };

        E=(P, M) => {
          let G=typeof Symbol=="function"&&P[Symbol.iterator];if (!G) {
            return P;
          }
          const V=G.call(P);
          let K;
          const X=[];
          let v;
          try{
            while ((M===void 0||M-- >0)&&!(K=V.next()).done) {
              X.push(K.value)
            }
          }catch(w){v={error:w}}finally{try{
            if (K&&!K.done&&(G=V.return)) {
              G.call(V);
            }
          }finally{if (v) {
            throw v.error
          }}}return X
        };

        h=function(...args) {
          let P=[];
          for (let M=0; M<args.length; M++) {
            P=P.concat(E(args[M]));
          }return P
        };

        T=function(...args) {
          let P=0;
          for (var M=0, G=args.length; M<G; M++) {
            P+=args[M].length;
          }
          const V=Array(P);
          let K=0;
          for (var M=0; M<G; M++) {
            const X=args[M];
            for (let v=0, w=X.length; v<w; v++,K++) {
              V[K]=X[v];
            }
          }return V
        };

        m=function(P,M,G){if (G||args.length===2) {
          var X;
          for (let V=0, K=M.length; V<K; V++) {
            if ((X || !(V in M))) {
              X||(X=Array.prototype.slice.call(M,0,V));
              X[V]=M[V];
            }
          }
        }return P.concat(X||Array.prototype.slice.call(M))};

        A=function(P){return this instanceof A?(this.v=P,this):new A(P)};

        g=(P, M, G) => {
          if (!Symbol.asyncIterator) {
            throw new TypeError("Symbol.asyncIterator is not defined.");
          }
          const V=G.apply(P,M||[]);
          let K;
          const X=[];
          K=Object.create((typeof AsyncIterator=="function"?AsyncIterator:Object).prototype);
          w("next");
          w("throw");
          w("return",v);
          K[Symbol.asyncIterator]=function(){return this};
          return K;
          function v(se){return ue => Promise.resolve(ue).then(se,te);}function w(se,ue){
          if (V[se]) {
            K[se]=Te => new Promise((ve, we) => {
              if (X.push([se,Te,ve,we]) <= 1) {
                z(se,Te);
              }
            });

            ue&&(K[se]=ue(K[se]));
          }
        }function z(se,ue){try{j(V[se](ue))}catch(Te){_e(X[0][3],Te)}}function j(se){
          if (se.value instanceof A) {
            Promise.resolve(se.value.v).then(ee,te);
          } else {
            _e(X[0][2],se);
          }
        }function ee(se){z("next",se)}function te(se){z("throw",se)}function _e(se,ue){
          se(ue);
          X.shift();

          if (X.length) {
            z(X[0][0],X[0][1]);
          }
        }
        };

        R=P => {
          let M;
          let G;
          M={};
          V("next");
          V("throw",K => {throw K});
          V("return");
          M[Symbol.iterator]=function(){return this};
          return M;
          function V(K,X){M[K]=P[K]?v => (G=!G)?{value:A(P[K](v)),done:false}:X?X(v):v:X}
        };

        O=P => {
          if (!Symbol.asyncIterator) {
            throw new TypeError("Symbol.asyncIterator is not defined.");
          }
          const M=P[Symbol.asyncIterator];
          let G;
          return M?M.call(P):(P=typeof p=="function"?p(P):P[Symbol.iterator](),G={},V("next"),V("throw"),V("return"),G[Symbol.asyncIterator]=function(){return this},G);function V(X){G[X]=P[X]&&(v => new Promise((w, z) => {
            v=P[X](v);
            K(w,z,v.done,v.value);
          }))}function K(X,v,w,z){Promise.resolve(z).then(j => {X({value:j,done:w})},v)}
        };

        I=(P, M) => {
          if (Object.defineProperty) {
            Object.defineProperty(P,"raw",{value:M});
          } else {
            P.raw=M;
          }

          return P;
        };

        const oe=Object.create?((P, M) => {Object.defineProperty(P,"default",{enumerable:true,value:M})}):(P, M) => {P.default=M};

        let ae=P => {
          ae=Object.getOwnPropertyNames||(M => {const G=[];for (const V in M) {
            if (Object.prototype.hasOwnProperty.call(M,V)) {
              (G[G.length] = V);
            }
          }return G});

          return ae(P);
        };

        b=P => {
          if (P&&P.__esModule) {
            return P;
          }const M={};if (P!=null) {
            for (let G=ae(P), V=0; V<G.length; V++) {
              if (G[V]!=="default") {
                $(M,P,G[V]);
              }
            }
          }
          oe(M,P);
          return M;
        };

        L=P => P&&P.__esModule?P:{default:P};

        U=(P, M, G, V) => {if (G==="a"&&!V) {
          throw new TypeError("Private accessor was defined without a getter");
        }if (typeof M=="function"?P!==M||!V:!M.has(P)) {
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        }return G==="m"?V:G==="a"?V.call(P):V?V.value:M.get(P)};

        q=(P, M, G, V, K) => {
          if (V==="m") {
            throw new TypeError("Private method is not writable");
          }if (V==="a"&&!K) {
              throw new TypeError("Private accessor was defined without a setter");
            }if (typeof M=="function"?P!==M||!K:!M.has(P)) {
              throw new TypeError("Cannot write private member to an object whose class did not declare it");
            }

          if (V==="a") {
            K.call(P,G);
          } else if (K) {
            K.value=G;
          } else {
            M.set(P,G);
          }

          return G;
        };

        H=(P, M) => {if (M===null||typeof M!="object"&&typeof M!="function") {
          throw new TypeError("Cannot use 'in' operator on non-object");
        }return typeof P=="function"?M===P:P.has(M)};

        B=(P, M, G) => {if (M!=null) {
          if (typeof M!="object"&&typeof M!="function") {
            throw new TypeError("Object expected.");
          }
          let V;
          let K;
          if(G){if (!Symbol.asyncDispose) {
            throw new TypeError("Symbol.asyncDispose is not defined.");
          }V=M[Symbol.asyncDispose]}if(V===void 0){
            if (!Symbol.dispose) {
              throw new TypeError("Symbol.dispose is not defined.");
            }
            V=M[Symbol.dispose];

            if (G) {
              (K = V);
            }
          }if (typeof V!="function") {
              throw new TypeError("Object not disposable.");
            }

          if (K) {
            (V = function(){try{K.call(this)}catch(X){return Promise.reject(X)}});
          }

          P.stack.push({value:M,dispose:V,async:G});
        } else {
          if (G) {
            P.stack.push({async:true});
          }
        }return M};

        const ne=typeof SuppressedError=="function"?SuppressedError:(P, M, G) => {
          const V=new Error(G);
          V.name="SuppressedError";
          V.error=P;
          V.suppressed=M;
          return V;
        };

        F=P => {
          function M(X){
            P.error=P.hasError?new ne(X,P.error,"An error was suppressed during disposal."):X;
            P.hasError=true;
          }
          let G;
          let V=0;
          function K(){
            while (G=P.stack.pop()) {
              try{if (!G.async&&V===1) {
                V=0;
                P.stack.push(G);
                return Promise.resolve().then(K);
              }if (G.dispose) {const X=G.dispose.call(G.value);if (G.async) {
                V|=2;

                return Promise.resolve(X).then(K,v => {
                  M(v);
                  return K();
                });
              }} else {
                V|=1
              }}catch(v){M(v)}
            }

            if (V===1) {
              return P.hasError?Promise.reject(P.error):Promise.resolve();
            }if (P.hasError) {
              throw P.error
            }
          }return K()
        };

        D=(P, M) => typeof P=="string"&&/^\.\.?\//.test(P)?P.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i,(G, V, K, X, v) => V?M?".jsx":".js":K&&(!X||!v)?G:`${K+X}.${v.toLowerCase()}js`):P;
        k("__extends",t);
        k("__assign",n);
        k("__rest",r);
        k("__decorate",o);
        k("__param",s);
        k("__esDecorate",i);
        k("__runInitializers",a);
        k("__propKey",c);
        k("__setFunctionName",l);
        k("__metadata",f);
        k("__awaiter",d);
        k("__generator",u);
        k("__exportStar",_);
        k("__createBinding",$);
        k("__values",p);
        k("__read",E);
        k("__spread",h);
        k("__spreadArrays",T);
        k("__spreadArray",m);
        k("__await",A);
        k("__asyncGenerator",g);
        k("__asyncDelegator",R);
        k("__asyncValues",O);
        k("__makeTemplateObject",I);
        k("__importStar",b);
        k("__importDefault",L);
        k("__classPrivateFieldGet",U);
        k("__classPrivateFieldSet",q);
        k("__classPrivateFieldIn",H);
        k("__addDisposableResource",B);
        k("__disposeResources",F);
        k("__rewriteRelativeImportExtension",D);
      })
    })(W_);
  }

  return W_.exports;
}const HQ=BQ();
const FQ=zp(HQ);
const {__extends,__assign,__rest,__decorate,__param,__esDecorate,__runInitializers,__propKey,__setFunctionName,__metadata,__awaiter,__generator,__exportStar,__createBinding,__values,__read,__spread,__spreadArrays,__spreadArray,__await,__asyncGenerator,__asyncDelegator,__asyncValues,__makeTemplateObject,__importStar,__importDefault,__classPrivateFieldGet,__classPrivateFieldSet,__classPrivateFieldIn,__addDisposableResource,__disposeResources,__rewriteRelativeImportExtension}=FQ;

const Qb = (e => {
  __extends(t,e);function t(n,r,o){
    const s=e.call(this,n,r)||this;
    s.iterator=o;
    return s;
  }
  t.prototype.add=function(n){return this.iterator(n,this._result.length)?(this._result.push(n),true):false;};
  return t;
})(Io);

const $u={dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],tokens:{SKIP:/^[ \r\n\t]+|^\.$/,number:/^[1-9][0-9]*/,numberAsText:/^(one|two|three)/i,every:/^every/i,"day(s)":/^days?/i,"weekday(s)":/^weekdays?/i,"week(s)":/^weeks?/i,"hour(s)":/^hours?/i,"minute(s)":/^minutes?/i,"month(s)":/^months?/i,"year(s)":/^years?/i,on:/^(on|in)/i,at:/^(at)/i,the:/^the/i,first:/^first/i,second:/^second/i,third:/^third/i,nth:/^([1-9][0-9]*)(\.|th|nd|rd|st)/i,last:/^last/i,for:/^for/i,"time(s)":/^times?/i,until:/^(un)?til/i,monday:/^mo(n(day)?)?/i,tuesday:/^tu(e(s(day)?)?)?/i,wednesday:/^we(d(n(esday)?)?)?/i,thursday:/^th(u(r(sday)?)?)?/i,friday:/^fr(i(day)?)?/i,saturday:/^sa(t(urday)?)?/i,sunday:/^su(n(day)?)?/i,january:/^jan(uary)?/i,february:/^feb(ruary)?/i,march:/^mar(ch)?/i,april:/^apr(il)?/i,may:/^may/i,june:/^june?/i,july:/^july?/i,august:/^aug(ust)?/i,september:/^sep(t(ember)?)?/i,october:/^oct(ober)?/i,november:/^nov(ember)?/i,december:/^dec(ember)?/i,comma:/^(,\s*|(and|or)\s*)+/i}};
const Jb=(e, t) => e.includes(t);
const YQ=e => e.toString();
const jQ=(e, t, n) => `${t} ${n}, ${e}`;

const jn = (() => {
  function e(t, n = YQ, r = $u, o = jQ) {
    this.text=[];
    this.language=r||$u;
    this.gettext=n;
    this.dateFormatter=o;
    this.rrule=t;
    this.options=t.options;
    this.origOptions=t.origOptions;

    if (this.origOptions.bymonthday) {
      const s=[].concat(this.options.bymonthday);
      const i=[].concat(this.options.bynmonthday);
      s.sort((f, d) => f-d);
      i.sort((f, d) => d-f);
      this.bymonthday=s.concat(i);

      if (!this.bymonthday.length) {
        (this.bymonthday = null);
      }
    }

    if (ze(this.origOptions.byweekday)) {
      const a=kt(this.origOptions.byweekday)?this.origOptions.byweekday:[this.origOptions.byweekday];
      const c=String(a);
      this.byweekday={allWeeks:a.filter(f => !f.n),someWeeks:a.filter(f => !!f.n),isWeekdays:c.includes("MO")&&c.includes("TU")&&c.includes("WE")&&c.includes("TH")&&c.includes("FR")&&!c.includes("SA")&&!c.includes("SU"),isEveryDay:c.includes("MO")&&c.includes("TU")&&c.includes("WE")&&c.includes("TH")&&c.includes("FR")&&c.includes("SA")&&c.includes("SU")};const l=(f, d) => f.weekday-d.weekday;
      this.byweekday.allWeeks.sort(l);
      this.byweekday.someWeeks.sort(l);

      if (!this.byweekday.allWeeks.length) {
        (this.byweekday.allWeeks = null);
      }

      if (!this.byweekday.someWeeks.length) {
        (this.byweekday.someWeeks = null);
      }
    } else {
      this.byweekday=null
    }
  }

  e.isFullyConvertible=t => {const n=true;if (!(t.options.freq in e.IMPLEMENTED)||t.origOptions.until&&t.origOptions.count) {
    return false;
  }for(const r in t.origOptions){if (Jb(["dtstart","tzid","wkst","freq"],r)) {
    return true;
  }if (!Jb(e.IMPLEMENTED[t.options.freq],r)) {
    return false;
  }}return n};

  e.prototype.isFullyConvertible=function(){return e.isFullyConvertible(this.rrule)};

  e.prototype.toString=function(){
    const t=this.gettext;if (!(this.options.freq in e.IMPLEMENTED)) {
        return t("RRule error: Unable to fully convert this rrule to text");
      }
    this.text=[t("every")];
    this[pe.FREQUENCIES[this.options.freq]]();

    if (this.options.until)
      {this.add(t("until"));const n=this.options.until;this.add(this.dateFormatter(n.getUTCFullYear(),this.language.monthNames[n.getUTCMonth()],n.getUTCDate()))} else {
      if (this.options.count) {
        this.add(t("for")).add(this.options.count.toString()).add(this.plural(this.options.count)?t("times"):t("time"));
      }
    }

    if (!this.isFullyConvertible()) {
      this.add(t("(~ approximate)"));
    }

    return this.text.join("");
  };

  e.prototype.HOURLY=function(){
    const t=this.gettext;

    if (this.options.interval!==1) {
      this.add(this.options.interval.toString());
    }

    this.add(this.plural(this.options.interval)?t("hours"):t("hour"));
  };

  e.prototype.MINUTELY=function(){
    const t=this.gettext;

    if (this.options.interval!==1) {
      this.add(this.options.interval.toString());
    }

    this.add(this.plural(this.options.interval)?t("minutes"):t("minute"));
  };

  e.prototype.DAILY=function(){
    const t=this.gettext;

    if (this.options.interval!==1) {
      this.add(this.options.interval.toString());
    }

    if (this.byweekday&&this.byweekday.isWeekdays) {
      this.add(this.plural(this.options.interval)?t("weekdays"):t("weekday"));
    } else {
      this.add(this.plural(this.options.interval)?t("days"):t("day"));
    }

    if (this.origOptions.bymonth) {
      this.add(t("in"));
      this._bymonth();
    }

    if (this.bymonthday) {
      this._bymonthday();
    } else if (this.byweekday) {
      this._byweekday();
    } else if (this.origOptions.byhour) {
      this._byhour();
    }
  };

  e.prototype.WEEKLY=function(){
    const t=this.gettext;

    if (this.options.interval!==1) {
      this.add(this.options.interval.toString()).add(this.plural(this.options.interval)?t("weeks"):t("week"));
    }

    if (this.byweekday&&this.byweekday.isWeekdays) {
      if (this.options.interval===1) {
        this.add(this.plural(this.options.interval)?t("weekdays"):t("weekday"));
      } else {
        this.add(t("on")).add(t("weekdays"));
      }
    } else if (this.byweekday&&this.byweekday.isEveryDay) {
      this.add(this.plural(this.options.interval)?t("days"):t("day"));
    } else {
      this.options.interval===1&&this.add(t("week"));
      this.origOptions.bymonth&&(this.add(t("in")),this._bymonth());
      this.bymonthday?this._bymonthday():this.byweekday&&this._byweekday();
      this.origOptions.byhour&&this._byhour();
    }
  };

  e.prototype.MONTHLY=function(){
    const t=this.gettext;

    if (this.origOptions.bymonth) {
      this.options.interval!==1&&(this.add(this.options.interval.toString()).add(t("months")),this.plural(this.options.interval)&&this.add(t("in")));
      this._bymonth();
    } else {
      this.options.interval!==1&&this.add(this.options.interval.toString());
      this.add(this.plural(this.options.interval)?t("months"):t("month"));
    }

    if (this.bymonthday) {
      this._bymonthday();
    } else if (this.byweekday&&this.byweekday.isWeekdays) {
      this.add(t("on")).add(t("weekdays"));
    } else if (this.byweekday) {
      this._byweekday();
    }
  };

  e.prototype.YEARLY=function(){
    const t=this.gettext;

    if (this.origOptions.bymonth) {
      this.options.interval!==1&&(this.add(this.options.interval.toString()),this.add(t("years")));
      this._bymonth();
    } else {
      this.options.interval!==1&&this.add(this.options.interval.toString());
      this.add(this.plural(this.options.interval)?t("years"):t("year"));
    }

    if (this.bymonthday) {
      this._bymonthday();
    } else if (this.byweekday) {
      this._byweekday();
    }

    if (this.options.byyearday) {
      this.add(t("on the")).add(this.list(this.options.byyearday,this.nth,t("and"))).add(t("day"));
    }

    if (this.options.byweekno) {
      this.add(t("in")).add(this.plural(this.options.byweekno.length)?t("weeks"):t("week")).add(this.list(this.options.byweekno,void 0,t("and")));
    }
  };

  e.prototype._bymonthday=function(){
    const t=this.gettext;

    if (this.byweekday&&this.byweekday.allWeeks) {
      this.add(t("on")).add(this.list(this.byweekday.allWeeks,this.weekdaytext,t("or"))).add(t("the")).add(this.list(this.bymonthday,this.nth,t("or")));
    } else {
      this.add(t("on the")).add(this.list(this.bymonthday,this.nth,t("and")));
    }
  };

  e.prototype._byweekday=function(){
    const t=this.gettext;

    if (this.byweekday.allWeeks&&!this.byweekday.isWeekdays) {
      this.add(t("on")).add(this.list(this.byweekday.allWeeks,this.weekdaytext));
    }

    if (this.byweekday.someWeeks) {
      this.byweekday.allWeeks&&this.add(t("and"));
      this.add(t("on the")).add(this.list(this.byweekday.someWeeks,this.weekdaytext,t("and")));
    }
  };

  e.prototype._byhour=function(){const t=this.gettext;this.add(t("at")).add(this.list(this.origOptions.byhour,void 0,t("and")))};
  e.prototype._bymonth=function(){this.add(this.list(this.options.bymonth,this.monthtext,this.gettext("and")))};

  e.prototype.nth=function(t){
    t=parseInt(t.toString(),10);
    let n;
    const r=this.gettext;
    if (t===-1) {
      return r("last");
    }const o=Math.abs(t);switch(o){case 1:case 21:case 31:
      {
        n=o+r("st");break;
      }case 2:case 22:
      {
        n=o+r("nd");break;
      }case 3:case 23:
      {
        n=o+r("rd");break;
      }default:
      {
        n=o+r("th")
      }}return t<0?`${n} ${r("last")}`:n;
  };

  e.prototype.monthtext=function(t){return this.language.monthNames[t-1]};
  e.prototype.weekdaytext=function(t){const n=hn(t)?(t+1)%7:t.getJsWeekday();return (t.n?`${this.nth(t.n)} `:"")+this.language.dayNames[n];};
  e.prototype.plural=t => t%100!==1;

  e.prototype.add=function(t){
    this.text.push(" ");
    this.text.push(t);
    return this;
  };

  e.prototype.list=function(t, n, r, o = ",") {
    const s=this;

    if (!kt(t)) {
      (t = [t]);
    }

    const i=(c, l, f) => {
      let d="";
      for (let u=0; u<c.length; u++) {
        if (u!==0) {
          if (u===c.length-1) {
            d+=` ${f} `;
          } else {
            d+=`${l} `;
          }
        }

        d+=c[u];
      }return d
    };n=n||(c => c.toString());const a=c => n&&n.call(s,c);return r?i(t.map(a),o,r):t.map(a).join(`${o} `);
  };

  return e;
})();

const qQ = (() => {
  function e(t){
    this.done=true;
    this.rules=t;
  }

  e.prototype.start=function(t){
    this.text=t;
    this.done=false;
    return this.nextSymbol();
  };

  e.prototype.isDone=function(){return this.done&&this.symbol===null};

  e.prototype.nextSymbol=function(){
    let t;
    let n;
    this.symbol=null;
    this.value=null;
    do{
      if (this.done) {
        return false;
      }let r=void 0;t=null;for(const o in this.rules){
        r=this.rules[o];const s=r.exec(this.text);

        if (s&&(t===null||s[0].length>t[0].length)) {
          t=s;
          n=o;
        }
      }

      if (t!=null) {
        this.text=this.text.substr(t[0].length);
        this.text===""&&(this.done=true);
      }

      if (t==null) {
        this.done=true;
        this.symbol=null;
        this.value=null;
        return
      }
    }while(n==="SKIP");
    this.symbol=n;
    this.value=t;
    return true;
  };

  e.prototype.accept=function(t){if(this.symbol===t){
    if(this.value){
      const n=this.value;
      this.nextSymbol();
      return n;
    }
    this.nextSymbol();
    return true;
  }return false;};

  e.prototype.acceptNumber=function(){return this.accept("number")};

  e.prototype.expect=function(t){if (this.accept(t)) {
    return true;
  }throw new Error(`expected ${t} but found ${this.symbol}`)};

  return e;
})();

function GL(e, t = $u) {
  const n={};
  const r=new qQ(t.tokens);
  if (!r.start(e)) {
    return null;
  }
  o();
  return n;
  function o(){
    r.expect("every");const u=r.acceptNumber();

    if (u) {
      (n.interval = parseInt(u[0],10));
    }

    if (r.isDone()) {
      throw new Error("Unexpected end");
    }

    switch(r.symbol){case "day(s)":
      {
        n.freq=pe.DAILY;

        if (r.nextSymbol()) {
          i();
          d();
        }

        break;
      }case "weekday(s)":
      {
        n.freq=pe.WEEKLY;
        n.byweekday=[pe.MO,pe.TU,pe.WE,pe.TH,pe.FR];
        r.nextSymbol();
        i();
        d();
        break;
      }case "week(s)":
      {
        n.freq=pe.WEEKLY;

        if (r.nextSymbol()) {
          s();
          i();
          d();
        }

        break;
      }case "hour(s)":
      {
        n.freq=pe.HOURLY;

        if (r.nextSymbol()) {
          s();
          d();
        }

        break;
      }case "minute(s)":
      {
        n.freq=pe.MINUTELY;

        if (r.nextSymbol()) {
          s();
          d();
        }

        break;
      }case "month(s)":
      {
        n.freq=pe.MONTHLY;

        if (r.nextSymbol()) {
          s();
          d();
        }

        break;
      }case "year(s)":
      {
        n.freq=pe.YEARLY;

        if (r.nextSymbol()) {
          s();
          d();
        }

        break;
      }case"monday":case"tuesday":case"wednesday":case"thursday":case"friday":case"saturday":case "sunday":
      {
        n.freq=pe.WEEKLY;const _=r.symbol.substr(0,2).toUpperCase();
        n.byweekday=[pe[_]];

        if (!r.nextSymbol()) {
          return;
        }

        while (r.accept("comma")) {
          if (r.isDone()) {
            throw new Error("Unexpected end");
          }const p=c();if (!p) {
            throw new Error(`Unexpected symbol ${r.symbol}, expected weekday`);
          }
          n.byweekday.push(pe[p]);
          r.nextSymbol();
        }

        i();
        f();
        d();
        break;
      }case"january":case"february":case"march":case"april":case"may":case"june":case"july":case"august":case"september":case"october":case"november":case "december":
      {
        n.freq=pe.YEARLY;
        n.bymonth=[a()];

        if (!r.nextSymbol()) {
          return;
        }

        while (r.accept("comma")) {
          if (r.isDone()) {
            throw new Error("Unexpected end");
          }const E=a();if (!E) {
            throw new Error(`Unexpected symbol ${r.symbol}, expected month`);
          }
          n.bymonth.push(E);
          r.nextSymbol();
        }

        s();
        d();
        break;
      }default:
      {
        throw new Error("Unknown symbol")
      }}
  }function s(){
      const u=r.accept("on");
      const _=r.accept("the");
      if (u||_) {
        do{
          const p=l();
          const E=c();
          const h=a();
          if (p) {
            if (E) {
              r.nextSymbol();
              n.byweekday||(n.byweekday=[]);
              n.byweekday.push(pe[E].nth(p));
            } else {
              n.bymonthday||(n.bymonthday=[]);
              n.bymonthday.push(p);
              r.accept("day(s)");
            }
          } else if (E) {
            r.nextSymbol();

            if (!n.byweekday) {
              (n.byweekday = []);
            }

            n.byweekday.push(pe[E]);
          } else if (r.symbol==="weekday(s)") {
            r.nextSymbol();

            if (!n.byweekday) {
              (n.byweekday = [pe.MO,pe.TU,pe.WE,pe.TH,pe.FR]);
            }
          } else if(r.symbol==="week(s)"){r.nextSymbol();let T=r.acceptNumber();if (!T) {
            throw new Error(`Unexpected symbol ${r.symbol}, expected week number`);
          }for(n.byweekno=[parseInt(T[0],10)];r.accept("comma");){
            T=r.acceptNumber();

            if (!T) {
              throw new Error(`Unexpected symbol ${r.symbol}; expected monthday`);
            }

            n.byweekno.push(parseInt(T[0],10))
          }}else if (h) {
            r.nextSymbol();

            if (!n.bymonth) {
              (n.bymonth = []);
            }

            n.bymonth.push(h);
          } else {
            return
          }
        }while(r.accept("comma")||r.accept("the")||r.accept("on"))
      }
    }function i(){const u=r.accept("at");if (u) {
      do{let _=r.acceptNumber();if (!_) {
        throw new Error(`Unexpected symbol ${r.symbol}, expected hour`);
      }for(n.byhour=[parseInt(_[0],10)];r.accept("comma");){
        _=r.acceptNumber();

        if (!_) {
          throw new Error(`Unexpected symbol ${r.symbol}; expected hour`);
        }

        n.byhour.push(parseInt(_[0],10))
      }}while(r.accept("comma")||r.accept("at"))
    }}function a(){switch(r.symbol){case "january":
      {
        return 1;
      }case "february":
      {
        return 2;
      }case "march":
      {
        return 3;
      }case "april":
      {
        return 4;
      }case "may":
      {
        return 5;
      }case "june":
      {
        return 6;
      }case "july":
      {
        return 7;
      }case "august":
      {
        return 8;
      }case "september":
      {
        return 9;
      }case "october":
      {
        return 10;
      }case "november":
      {
        return 11;
      }case "december":
      {
        return 12;
      }default:
      {
        return false;
      }}}function c(){switch(r.symbol){case"monday":case"tuesday":case"wednesday":case"thursday":case"friday":case"saturday":case "sunday":
      {
        return r.symbol.substr(0,2).toUpperCase();
      }default:
      {
        return false;
      }}}function l(){switch(r.symbol){case "last":
      {
        r.nextSymbol();
        return -1;
      }case "first":
      {
        r.nextSymbol();
        return 1;
      }case "second":
      {
        r.nextSymbol();
        return r.accept("last")?-2:2;
      }case "third":
      {
        r.nextSymbol();
        return r.accept("last")?-3:3;
      }case "nth":
      {
        const u=parseInt(r.value[1],10);if (u<-366||u>366) {
          throw new Error(`Nth out of range: ${u}`);
        }
        r.nextSymbol();
        return r.accept("last")?-u:u;
      }default:
      {
        return false;
      }}}function f(){
      r.accept("on");
      r.accept("the");
      let u=l();if (u) {
    n.bymonthday=[u];
    r.nextSymbol();

    while (r.accept("comma")) {
      u=l();

      if (!u) {
        throw new Error(`Unexpected symbol ${r.symbol}; expected monthday`);
      }

      n.bymonthday.push(u);
      r.nextSymbol();
    }
  }
    }function d(){if (r.symbol==="until") {const u=Date.parse(r.text);if (!u) {
      throw new Error(`Cannot parse until date:${r.text}`);
    }n.until=new Date(u)} else {
    if (r.accept("for")) {
      n.count=parseInt(r.value[0],10);
      r.expect("number");
    }
  }}
}const Ce = {
  YEARLY: 0,
  MONTHLY: 1,
  WEEKLY: 2,
  DAILY: 3,
  HOURLY: 4,
  MINUTELY: 5,
  SECONDLY: 6,

  // reverse mapping
  0: "YEARLY",

  1: "MONTHLY",
  2: "WEEKLY",
  3: "DAILY",
  4: "HOURLY",
  5: "MINUTELY",
  6: "SECONDLY"
};function gh(e){return e<Ce.HOURLY}

const WQ=(e, t = $u) => {
  return new pe(GL(e,t)||void 0);
};

const os=["count","until","interval","byweekday","bymonthday","bymonth"];
jn.IMPLEMENTED=[];jn.IMPLEMENTED[Ce.HOURLY]=os;jn.IMPLEMENTED[Ce.MINUTELY]=os;jn.IMPLEMENTED[Ce.DAILY]=["byhour"].concat(os);jn.IMPLEMENTED[Ce.WEEKLY]=os;jn.IMPLEMENTED[Ce.MONTHLY]=os;jn.IMPLEMENTED[Ce.YEARLY]=["byweekno","byyearday"].concat(os);
const KQ=(e, t, n, r) => new jn(e,t,n,r).toString();
const zQ=jn.isFullyConvertible;

const Bu = (() => {
  function e(t,n,r,o){
    this.hour=t;
    this.minute=n;
    this.second=r;
    this.millisecond=o||0;
  }
  e.prototype.getHours=function(){return this.hour};
  e.prototype.getMinutes=function(){return this.minute};
  e.prototype.getSeconds=function(){return this.second};
  e.prototype.getMilliseconds=function(){return this.millisecond};
  e.prototype.getTime=function(){return (this.hour*60*60+this.minute*60+this.second)*1000/* 1e3 */+this.millisecond;};
  return e;
})();

const ZQ = (e => {
  __extends(t,e);function t(n,r,o,s,i,a,c){
    const l=e.call(this,s,i,a,c)||this;
    l.year=n;
    l.month=r;
    l.day=o;
    return l;
  }
  t.fromDate=function(n){return new this(n.getUTCFullYear(),n.getUTCMonth()+1,n.getUTCDate(),n.getUTCHours(),n.getUTCMinutes(),n.getUTCSeconds(),n.valueOf()%1000/* 1e3 */);};
  t.prototype.getWeekday=function(){return Fo(new Date(this.getTime()))};
  t.prototype.getTime=function(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond)).getTime()};
  t.prototype.getDay=function(){return this.day};
  t.prototype.getMonth=function(){return this.month};
  t.prototype.getYear=function(){return this.year};
  t.prototype.addYears=function(n){this.year+=n};

  t.prototype.addMonths=function(n){
    this.month+=n;

    if (this.month>12) {
      const r=Math.floor(this.month/12);
      const o=Ht(this.month,12);
      this.month=o;
      this.year+=r;

      if (this.month===0) {
        this.month=12;
        --this.year;
      }
    }
  };

  t.prototype.addWeekly=function(n,r){
    if (r>this.getWeekday()) {
      this.day+=-(this.getWeekday()+1+(6-r))+n*7;
    } else {
      this.day+=-(this.getWeekday()-r)+n*7;
    }

    this.fixDay();
  };

  t.prototype.addDaily=function(n){
    this.day+=n;
    this.fixDay();
  };

  t.prototype.addHours=function(n,r,o){for(r&&(this.hour+=Math.floor((23-this.hour)/n)*n);;){
    this.hour+=n;
    const s=q_(this.hour,24);
    const i=s.div;
    const a=s.mod;

    if (i) {
      this.hour=a;
      this.addDaily(i);
    }

    if (mn(o)||De(o,this.hour)) {
      break
    }
  }};

  t.prototype.addMinutes=function(n,r,o,s){for(r&&(this.minute+=Math.floor((1439-(this.hour*60+this.minute))/n)*n);;){
    this.minute+=n;
    const i=q_(this.minute,60);
    const a=i.div;
    const c=i.mod;

    if (a) {
      this.minute=c;
      this.addHours(a,false,o);
    }

    if ((mn(o)||De(o,this.hour))&&(mn(s)||De(s,this.minute))) {
      break
    }
  }};

  t.prototype.addSeconds=function(n,r,o,s,i){for(r&&(this.second+=Math.floor((86399-(this.hour*3600+this.minute*60+this.second))/n)*n);;){
    this.second+=n;
    const a=q_(this.second,60);
    const c=a.div;
    const l=a.mod;

    if (c) {
      this.second=l;
      this.addMinutes(c,false,o,s);
    }

    if ((mn(o)||De(o,this.hour))&&(mn(s)||De(s,this.minute))&&(mn(i)||De(i,this.second))) {
      break
    }
  }};

  t.prototype.fixDay=function(){if(!(this.day<=28)){let n=Kb(this.year,this.month-1)[1];if (!(this.day<=n)) {
    while (this.day>n) {
      this.day-=n;
      ++this.month;

      if (this.month===13&&(this.month=1,++this.year,this.year>LL)) {
        return;
      }

      n=Kb(this.year,this.month-1)[1]
    }
  }}};

  t.prototype.add=function(n,r){
    const o=n.freq;
    const s=n.interval;
    const i=n.wkst;
    const a=n.byhour;
    const c=n.byminute;
    const l=n.bysecond;
    switch(o){case Ce.YEARLY:
      {
        return this.addYears(s);
      }case Ce.MONTHLY:
      {
        return this.addMonths(s);
      }case Ce.WEEKLY:
      {
        return this.addWeekly(s,i);
      }case Ce.DAILY:
      {
        return this.addDaily(s);
      }case Ce.HOURLY:
      {
        return this.addHours(s,r,a);
      }case Ce.MINUTELY:
      {
        return this.addMinutes(s,r,a,c);
      }case Ce.SECONDLY:
      {
        return this.addSeconds(s,r,a,c,l)
      }}
  };

  return t;
})(Bu);

function VL(e){
  const t=[];
  const n=Object.keys(e);
  for(let r=0, o=n;r<o.length;r++){
    const s=o[r];

    if (!De(b5,s)) {
      t.push(s);
    }

    if (DL(e[s])&&!qa(e[s])) {
      t.push(s);
    }
  }if (t.length) {
    throw new Error(`Invalid options: ${t.join(", ")}`);
  }return __assign({},e);
}function XQ(e){
  const t=__assign(__assign({},Rh),VL(e));

  if (ze(t.byeaster)) {
    (t.freq = pe.YEARLY);
  }

  if (!(ze(t.freq)&&pe.FREQUENCIES[t.freq])) {
    throw new Error(`Invalid frequency: ${t.freq} ${e.freq}`);
  }

  if (!t.dtstart) {
    (t.dtstart = new Date(new Date().setMilliseconds(0)));
  }

  if (ze(t.wkst)) {
    if (!hn(t.wkst)) {
      (t.wkst = t.wkst.weekday);
    }
  } else {
    t.wkst=pe.MO.weekday;
  }

  if (ze(t.bysetpos)) {
    if (hn(t.bysetpos)) {
      (t.bysetpos = [t.bysetpos]);
    }

    for(var n=0;n<t.bysetpos.length;n++){var r=t.bysetpos[n];if (r===0||!(r>=-366&&r<=366)) {
      throw new Error("bysetpos must be between 1 and 366, or between -366 and -1")
    }}
  }

  if (!(t.byweekno||rt(t.byweekno)||rt(t.byyearday)||t.bymonthday||rt(t.bymonthday)||ze(t.byweekday)||ze(t.byeaster))) {
    switch(t.freq){case pe.YEARLY:
      {
        if (!t.bymonth) {
          (t.bymonth = t.dtstart.getUTCMonth()+1);
        }

        t.bymonthday=t.dtstart.getUTCDate();
        break;
      }case pe.MONTHLY:
      {
        t.bymonthday=t.dtstart.getUTCDate();break;
      }case pe.WEEKLY:
      {
        t.byweekday=[Fo(t.dtstart)];break
      }}
  }

  if (ze(t.bymonth)&&!kt(t.bymonth)) {
    (t.bymonth = [t.bymonth]);
  }

  if (ze(t.byyearday)&&!kt(t.byyearday)&&hn(t.byyearday)) {
    (t.byyearday = [t.byyearday]);
  }

  if (!ze(t.bymonthday)) {
    t.bymonthday=[];
    t.bynmonthday=[];
  } else if (kt(t.bymonthday)) {
    const o=[];
    const s=[];
    for(var n=0;n<t.bymonthday.length;n++){
      var r=t.bymonthday[n];

      if (r>0) {
        o.push(r);
      } else if (r<0) {
        s.push(r);
      }
    }
    t.bymonthday=o;
    t.bynmonthday=s;
  } else {
    if (t.bymonthday<0) {
      t.bynmonthday=[t.bymonthday];
      t.bymonthday=[];
    } else {
      t.bynmonthday=[];
      t.bymonthday=[t.bymonthday];
    }
  }

  if (ze(t.byweekno)&&!kt(t.byweekno)) {
    (t.byweekno = [t.byweekno]);
  }

  if (!ze(t.byweekday)) {
    t.bynweekday=null;
  } else if (hn(t.byweekday)) {
    t.byweekday=[t.byweekday];
    t.bynweekday=null;
  } else if (Wb(t.byweekday)) {
    t.byweekday=[gt.fromStr(t.byweekday).weekday];
    t.bynweekday=null;
  } else if (t.byweekday instanceof gt) {
    if (!t.byweekday.n||t.freq>pe.MONTHLY) {
      t.byweekday=[t.byweekday.weekday];
      t.bynweekday=null;
    } else {
      t.bynweekday=[[t.byweekday.weekday,t.byweekday.n]];
      t.byweekday=null;
    }
  } else {
    const i=[];
    const a=[];
    for(var n=0;n<t.byweekday.length;n++){
      const c=t.byweekday[n];if(hn(c)){i.push(c);continue}else if(Wb(c)){i.push(gt.fromStr(c).weekday);continue}

      if (!c.n||t.freq>pe.MONTHLY) {
        i.push(c.weekday);
      } else {
        a.push([c.weekday,c.n]);
      }
    }
    t.byweekday=rt(i)?i:null;
    t.bynweekday=rt(a)?a:null;
  }

  if (ze(t.byhour)) {
    if (hn(t.byhour)) {
      (t.byhour = [t.byhour]);
    }
  } else {
    t.byhour=t.freq<pe.HOURLY?[t.dtstart.getUTCHours()]:null;
  }

  if (ze(t.byminute)) {
    if (hn(t.byminute)) {
      (t.byminute = [t.byminute]);
    }
  } else {
    t.byminute=t.freq<pe.MINUTELY?[t.dtstart.getUTCMinutes()]:null;
  }

  if (ze(t.bysecond)) {
    if (hn(t.bysecond)) {
      (t.bysecond = [t.bysecond]);
    }
  } else {
    t.bysecond=t.freq<pe.SECONDLY?[t.dtstart.getUTCSeconds()]:null;
  }

  return {parsedOptions:t};
}function QQ(e){
  const t=e.dtstart.getTime()%1000/* 1e3 */;if (!gh(e.freq)) {
    return[];
  }const n=[];
  e.byhour.forEach(r => {e.byminute.forEach(o => {e.bysecond.forEach(s => {n.push(new Bu(r,o,s,t))})})});
  return n;
}function Hp(e){const t=e.split(`
`).map(JQ).filter(n => n!==null);return __assign(__assign({},t[0]),t[1]);}function Hu(e){
  const t={};
  const n=/DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(e);
  if (!n) {
    return t;
  }
  const r=n[1];
  const o=n[2];

  if (r) {
    (t.tzid = r);
  }

  t.dtstart=mh(o);
  return t;
}function JQ(e){
  e=e.replace(/^\s+|\s+$/,"");

  if (!e.length) {
    return null;
  }

  const t=/^([A-Z]+?)[:;]/.exec(e.toUpperCase());if (!t) {
    return eC(e);
  }const n=t[1];switch(n.toUpperCase()){case"RRULE":case "EXRULE":
    {
      return eC(e);
    }case "DTSTART":
    {
      return Hu(e);
    }default:
    {
      throw new Error(`Unsupported RFC prop ${n} in ${e}`)
    }}
}function eC(e){
  const t=e.replace(/^RRULE:/i,"");
  const n=Hu(t);
  const r=e.replace(/^(?:RRULE|EXRULE):/i,"").split(";");

  r.forEach(o => {
    const s=o.split("=");
    const i=s[0];
    const a=s[1];
    switch(i.toUpperCase()){case "FREQ":
      {
        n.freq=Ce[a.toUpperCase()];break;
      }case "WKST":
      {
        n.wkst=rn[a.toUpperCase()];break;
      }case"COUNT":case"INTERVAL":case"BYSETPOS":case"BYMONTH":case"BYMONTHDAY":case"BYYEARDAY":case"BYWEEKNO":case"BYHOUR":case"BYMINUTE":case "BYSECOND":
      {
        const c=e5(a);
        const l=i.toLowerCase();
        n[l]=c;break;
      }case"BYWEEKDAY":case "BYDAY":
      {
        n.byweekday=t5(a);break;
      }case"DTSTART":case "TZID":
      {
        const f=Hu(e);
        n.tzid=f.tzid;
        n.dtstart=f.dtstart;
        break;
      }case "UNTIL":
      {
        n.until=mh(a);break;
      }case "BYEASTER":
      {
        n.byeaster=Number(a);break;
      }default:
      {
        throw new Error(`Unknown RRULE property '${i}'`)
      }}
  });

  return n;
}function e5(e){if(e.includes(",")){const t=e.split(",");return t.map(tC)}return tC(e)}function tC(e){return /^[+-]?\d+$/.test(e)?Number(e):e;}function t5(e){const t=e.split(",");return t.map(n => {
  if (n.length===2) {
    return rn[n];
  }const r=n.match(/^([+-]?\d{1,2})([A-Z]{2})$/);if (!r||r.length<3) {
    throw new SyntaxError(`Invalid weekday string: ${n}`);
  }
  const o=Number(r[1]);
  const s=r[2];
  const i=rn[s].weekday;
  return new gt(i,o)
});}const Fu = (() => {
  function e(t,n){
    if (isNaN(t.getTime())) {
      throw new RangeError("Invalid date passed to DateWithZone");
    }
    this.date=t;
    this.tzid=n;
  }
  Object.defineProperty(e.prototype,"isUTC",{get() {return!this.tzid||this.tzid.toUpperCase()==="UTC"},enumerable:false,configurable:true});
  e.prototype.toString=function(){const t=Sh(this.date.getTime(),this.isUTC);return this.isUTC?`:${t}`:`;TZID=${this.tzid}:${t}`;};
  e.prototype.getTime=function(){return this.date.getTime()};
  e.prototype.rezonedDate=function(){return this.isUTC?this.date:$Q(this.date,this.tzid)};
  return e;
})();function Fp(e){
  const t=[];
  let n="";
  const o=Object.keys(Rh);
  for (let r=Object.keys(e), s=0; s<r.length; s++) {
    if(r[s]!=="tzid"&&De(o,r[s])){
      let i=r[s].toUpperCase();
      const a=e[r[s]];
      let c="";
      if(!(!ze(a)||kt(a)&&!a.length)){
        switch(i){case "FREQ":
          {
            c=pe.FREQUENCIES[e.freq];break;
          }case "WKST":
          {
            if (hn(a)) {
              c=new gt(a).toString();
            } else {
              c=a.toString();
            }

            break;
          }case "BYWEEKDAY":
          {
            i="BYDAY";
            c=DQ(a).map(_ => _ instanceof gt?_:kt(_)?new gt(_[0],_[1]):new gt(_)).toString();
            break;
          }case "DTSTART":
          {
            n=n5(a,e.tzid);break;
          }case "UNTIL":
          {
            c=Sh(a,!e.tzid);break;
          }default:
          {
            if (kt(a)) {
              const l=[];
              for (let f=0; f<a.length; f++) {
                l[f]=String(a[f]);
              }c=l.toString()
            } else {
              c=String(a)
            }
          }}

        if (c) {
          t.push([i,c]);
        }
      }
    }
  }

  const d=t.map(_ => {
    const p=_[0];
    const E=_[1];
    return `${p}=${E.toString()}`;
  }).join(";");

  let u="";

  if (d!=="") {
    (u = `RRULE:${d}`);
  }

  return [n,u].filter(_ => !!_).join(`
  `);
}function n5(e,t){return e?`DTSTART${new Fu(new Date(e),t).toString()}`:"";}function r5(e,t){return Array.isArray(e)?!Array.isArray(t)||e.length!==t.length?false:e.every((n, r) => n.getTime()===t[r].getTime()):e instanceof Date?t instanceof Date&&e.getTime()===t.getTime():e===t;}

const o5 = (() => {
  function e(){
    this.all=false;
    this.before=[];
    this.after=[];
    this.between=[];
  }

  e.prototype._cacheAdd=function(t,n,r){
    if (n) {
      (n = n instanceof Date?Bp(n):zb(n));
    }

    if (t==="all") {
      this.all=n;
    } else {
      r._value=n;
      this[t].push(r);
    }
  };

  e.prototype._cacheGet=function(t,n){
    let r=false;
    const o=n?Object.keys(n):[];

    const s=f => {
      for (const u of o) {
        if (!r5(n[u],f[u])) {
          return true;
        }
      }

      return false;
    };

    const i=this[t];
    if (t==="all") {
      r=this.all;
    } else if (kt(i)) {
      for(var a=0;a<i.length;a++){const c=i[a];if(!(o.length&&s(c))){r=c._value;break}}
    }if(!r&&this.all){
      for (var l=new Io(t,n),a=0; a<this.all.length&&l.accept(this.all[a]); a++)
        {}
      r=l.getValue();
      this._cacheAdd(t,r,n);
    }return kt(r)?zb(r):r instanceof Date?Bp(r):r
  };

  return e;
})();

const s5=__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([],be(1,31),true),be(2,28),true),be(3,31),true),be(4,30),true),be(5,31),true),be(6,30),true),be(7,31),true),be(8,31),true),be(9,30),true),be(10,31),true),be(11,30),true),be(12,31),true),be(1,7),true);
const i5=__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([],be(1,31),true),be(2,29),true),be(3,31),true),be(4,30),true),be(5,31),true),be(6,30),true),be(7,31),true),be(8,31),true),be(9,30),true),be(10,31),true),be(11,30),true),be(12,31),true),be(1,7),true);
const a5=bn(1,29);
const c5=bn(1,30);
const Qn=bn(1,31);
const ut=bn(1,32);
const u5=__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([],ut,true),c5,true),ut,true),Qn,true),ut,true),Qn,true),ut,true),ut,true),Qn,true),ut,true),Qn,true),ut,true),ut.slice(0,7),true);
const l5=__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([],ut,true),a5,true),ut,true),Qn,true),ut,true),Qn,true),ut,true),ut,true),Qn,true),ut,true),Qn,true),ut,true),ut.slice(0,7),true);
const d5=bn(-28,0);
const f5=bn(-29,0);
const Jn=bn(-30,0);
const lt=bn(-31,0);
const _5=__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([],lt,true),f5,true),lt,true),Jn,true),lt,true),Jn,true),lt,true),lt,true),Jn,true),lt,true),Jn,true),lt,true),lt.slice(0,7),true);
const p5=__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([],lt,true),d5,true),lt,true),Jn,true),lt,true),Jn,true),lt,true),lt,true),Jn,true),lt,true),Jn,true),lt,true),lt.slice(0,7),true);
const E5=[0,31,60,91,121,152,182,213,244,274,305,335,366];
const h5=[0,31,59,90,120,151,181,212,243,273,304,334,365];

const nC = (() => {
  let e=[];
  for (let t=0; t<55; t++) {
    e=e.concat(bn(7));
  }return e
})();

function T5(e,t){
  const n=uo(e,1,1);
  const r=Xa(e)?366:365;
  const o=Xa(e+1)?366:365;
  const s=$p(n);
  const i=Fo(n);
  const a=__assign(__assign({yearlen:r,nextyearlen:o,yearordinal:s,yearweekday:i},S5(e)),{wnomask:null});
  if (mn(t.byweekno)) {
    return a;
  }a.wnomask=be(0,r+7);
  let c;
  let l;
  let f=c=Ht(7-i+t.wkst,7);

  if (f>=4) {
    f=0;
    l=a.yearlen+Ht(i-t.wkst,7);
  } else {
    l=r-f;
  }

  const d=Math.floor(l/7);
  const u=Ht(l,7);
  const _=Math.floor(d+u/4);
  for(var p=0;p<t.byweekno.length;p++){
    let E=t.byweekno[p];

    if (E<0) {
      (E += _+1);
    }

    if (E>0&&E<=_) {
      var h=void 0;

      if (E>1) {
        h=f+(E-1)*7;
        f!==c&&(h-=7-c);
      } else {
        h=f;
      }

      for (let T=0; T<7&&(a.wnomask[h]=1,h++,a.wdaymask[h]!==t.wkst); T++)
        {}
    }
  }if(De(t.byweekno,1)){
    var h=f+_*7;

    if (f!==c) {
      (h -= 7-c);
    }

    if (h<r) {
      for (var p=0; p<7&&(a.wnomask[h]=1,h+=1,a.wdaymask[h]!==t.wkst); p++)
        {}
    }
  }if(f){let m=void 0;if (De(t.byweekno,-1)) {
      m=-1;
    } else {
    const A=Fo(uo(e-1,1,1));
    let g=Ht(7-A.valueOf()+t.wkst,7);
    const R=Xa(e-1)?366:365;
    let O=void 0;

    if (g>=4) {
      g=0;
      O=R+Ht(A-t.wkst,7);
    } else {
      O=r-f;
    }

    m=Math.floor(52+Ht(O,7)/4);
  }if (De(t.byweekno,m)) {
      for (var h=0; h<f; h++) {
        a.wnomask[h]=1
      }
    }}return a
}function S5(e){
  const t=Xa(e)?366:365;
  const n=uo(e,1,1);
  const r=Fo(n);
  return t===365?{mmask:s5,mdaymask:l5,nmdaymask:p5,wdaymask:nC.slice(r),mrange:h5}:{mmask:i5,mdaymask:u5,nmdaymask:_5,wdaymask:nC.slice(r),mrange:E5}
}function m5(e,t,n,r,o,s){
  const i={lastyear:e,lastmonth:t,nwdaymask:[]};
  let a=[];
  if (s.freq===pe.YEARLY) {
    if (mn(s.bymonth)) {
      a=[[0,n]];
    } else {
      for (var c=0; c<s.bymonth.length; c++) {
        t=s.bymonth[c];
        a.push(r.slice(t-1,t+1));
      }
    }
  } else {
    if (s.freq===pe.MONTHLY) {
      (a = [r.slice(t-1,t+1)]);
    }
  }if (mn(a)) {
    return i;
  }i.nwdaymask=be(0,n);for (var c=0; c<a.length; c++) {
    const l=a[c];
    const f=l[0];
    const d=l[1]-1;
    for(let u=0;u<s.bynweekday.length;u++){
      let _=void 0;
      const p=s.bynweekday[u];
      const E=p[0];
      const h=p[1];

      if (h<0) {
        _=d+(h+1)*7;
        _-=Ht(o[_]-E,7);
      } else {
        _=f+(h-1)*7;
        _+=Ht(7-o[_]+E,7);
      }

      if (f<=_&&_<=d) {
        (i.nwdaymask[_] = 1);
      }
    }
  }return i
}function A5(e, t = 0) {
  const n=e%19;
  const r=Math.floor(e/100);
  const o=e%100;
  const s=Math.floor(r/4);
  const i=r%4;
  const a=Math.floor((r+8)/25);
  const c=Math.floor((r-a+1)/3);
  const l=Math.floor(19*n+r-s-c+15)%30;
  const f=Math.floor(o/4);
  const d=o%4;
  const u=Math.floor(32+2*i+2*f-l-d)%7;
  const _=Math.floor((n+11*l+22*u)/451);
  const p=Math.floor((l+u-7*_+114)/31);
  const E=(l+u-7*_+114)%31+1;
  const h=Date.UTC(e,p-1,E+t);
  const T=Date.UTC(e,0,1);
  return [Math.ceil((h-T)/(1000/* 1e3 */*60*60*24))];
}const g5 = (() => {
  function e(t){this.options=t}

  e.prototype.rebuild=function(t,n){
    const r=this.options;

    if (t!==this.lastyear) {
      (this.yearinfo = T5(t,r));
    }

    if (rt(r.bynweekday)&&(n!==this.lastmonth||t!==this.lastyear)) {
      const o=this.yearinfo;
      const s=o.yearlen;
      const i=o.mrange;
      const a=o.wdaymask;
      this.monthinfo=m5(t,n,s,i,a,r)
    }

    if (ze(r.byeaster)) {
      (this.eastermask = A5(t,r.byeaster));
    }
  };

  Object.defineProperty(e.prototype,"lastyear",{get() {return this.monthinfo?this.monthinfo.lastyear:null},enumerable:false,configurable:true});
  Object.defineProperty(e.prototype,"lastmonth",{get() {return this.monthinfo?this.monthinfo.lastmonth:null},enumerable:false,configurable:true});
  Object.defineProperty(e.prototype,"yearlen",{get() {return this.yearinfo.yearlen},enumerable:false,configurable:true});
  Object.defineProperty(e.prototype,"yearordinal",{get() {return this.yearinfo.yearordinal},enumerable:false,configurable:true});
  Object.defineProperty(e.prototype,"mrange",{get() {return this.yearinfo.mrange},enumerable:false,configurable:true});
  Object.defineProperty(e.prototype,"wdaymask",{get() {return this.yearinfo.wdaymask},enumerable:false,configurable:true});
  Object.defineProperty(e.prototype,"mmask",{get() {return this.yearinfo.mmask},enumerable:false,configurable:true});
  Object.defineProperty(e.prototype,"wnomask",{get() {return this.yearinfo.wnomask},enumerable:false,configurable:true});
  Object.defineProperty(e.prototype,"nwdaymask",{get() {return this.monthinfo?this.monthinfo.nwdaymask:[]},enumerable:false,configurable:true});
  Object.defineProperty(e.prototype,"nextyearlen",{get() {return this.yearinfo.nextyearlen},enumerable:false,configurable:true});
  Object.defineProperty(e.prototype,"mdaymask",{get() {return this.yearinfo.mdaymask},enumerable:false,configurable:true});
  Object.defineProperty(e.prototype,"nmdaymask",{get() {return this.yearinfo.nmdaymask},enumerable:false,configurable:true});
  e.prototype.ydayset=function(){return[bn(this.yearlen),0,this.yearlen]};

  e.prototype.mdayset=function(t,n){
    const r=this.mrange[n-1];
    const s=be(null,this.yearlen);
    for (var o=this.mrange[n], i=r; i<o; i++) {
      s[i]=i;
    }return[s,r,o]
  };

  e.prototype.wdayset=function(t,n,r){
    const i=s;
    for (var o=be(null,this.yearlen+7), s=$p(uo(t,n,r))-this.yearordinal, a=0; a<7&&(o[s]=s,++s,this.wdaymask[s]!==this.options.wkst); a++)
      {}return[o,i,s]
  };

  e.prototype.ddayset=function(t,n,r){
    const o=be(null,this.yearlen);
    const s=$p(uo(t,n,r))-this.yearordinal;
    o[s]=s;
    return [o,s,s+1];
  };

  e.prototype.htimeset=function(t,n,r,o){
    const s=this;
    let i=[];
    this.options.byminute.forEach(a => {i=i.concat(s.mtimeset(t,a,r,o))});
    _c(i);
    return i;
  };

  e.prototype.mtimeset=function(t,n,r,o){
    const s=this.options.bysecond.map(i => new Bu(t,n,i,o));
    _c(s);
    return s;
  };

  e.prototype.stimeset=(t, n, r, o) => [new Bu(t,n,r,o)];

  e.prototype.getdayset=function(t){switch(t){case Ce.YEARLY:
    {
      return this.ydayset.bind(this);
    }case Ce.MONTHLY:
    {
      return this.mdayset.bind(this);
    }case Ce.WEEKLY:
    {
      return this.wdayset.bind(this);
    }case Ce.DAILY:
    {
      return this.ddayset.bind(this);
    }default:
    {
      return this.ddayset.bind(this)
    }}};

  e.prototype.gettimeset=function(t){switch(t){case Ce.HOURLY:
    {
      return this.htimeset.bind(this);
    }case Ce.MINUTELY:
    {
      return this.mtimeset.bind(this);
    }case Ce.SECONDLY:
    {
      return this.stimeset.bind(this)
    }}};

  return e;
})();function R5(e,t,n,r,o,s){
  const i=[];
  for(let a=0;a<e.length;a++){
    let c=void 0;
    let l=void 0;
    const f=e[a];

    if (f<0) {
      c=Math.floor(f/t.length);
      l=Ht(f,t.length);
    } else {
      c=Math.floor((f-1)/t.length);
      l=Ht(f-1,t.length);
    }

    const d=[];
    for(let u=n;u<r;u++){
      const _=s[u];

      if (ze(_)) {
        d.push(_);
      }
    }let p=void 0;

    if (c<0) {
      p=d.slice(c)[0];
    } else {
      p=d[c];
    }

    const E=t[l];
    const h=UL(o.yearordinal+p);
    const T=kL(h,E);

    if (!De(i,T)) {
      i.push(T);
    }
  }
  _c(i);
  return i;
}function xL(e,t){
  const n=t.dtstart;
  const r=t.freq;
  const o=t.interval;
  const s=t.until;
  const i=t.bysetpos;
  let a=t.count;
  if (a===0||o===0) {
    return Dn(e);
  }
  const c=ZQ.fromDate(n);
  const l=new g5(t);
  l.rebuild(c.year,c.month);
  let f=O5(l,c,t);

  while (true) {
    const d=l.getdayset(r)(c.year,c.month,c.day);
    const u=d[0];
    const _=d[1];
    const p=d[2];
    const E=y5(u,_,p,l,t);
    if (rt(i)) {
      for(var h=R5(i,f,_,p,l,u),T=0;T<h.length;T++){var m=h[T];if (s&&m>s) {
        return Dn(e);
      }if(m>=n){var A=rC(m,t);if (!e.accept(A)||a&&(--a,!a)) {
        return Dn(e)
      }}}
    } else {
      for(var T=_;T<p;T++){const g=u[T];if (ze(g)) {
        const R=UL(l.yearordinal+g);

        for (const I of f) {
          var m=kL(R,I);
          if (s&&m>s) {
            return Dn(e);
          }if(m>=n){var A=rC(m,t);if (!e.accept(A)||a&&(--a,!a)) {
              return Dn(e)
            }}
        }
      }}
    }if (t.interval===0||(c.add(t,E),c.year>LL)) {
        return Dn(e);
      }

    if (!gh(r)) {
      (f = l.gettimeset(r)(c.hour,c.minute,c.second,0));
    }

    l.rebuild(c.year,c.month);
  }
}function N5(e,t,n){
  const r=n.bymonth;
  const o=n.byweekno;
  const s=n.byweekday;
  const i=n.byeaster;
  const a=n.bymonthday;
  const c=n.bynmonthday;
  const l=n.byyearday;
  return rt(r)&&!De(r,e.mmask[t])||rt(o)&&!e.wnomask[t]||rt(s)&&!De(s,e.wdaymask[t])||rt(e.nwdaymask)&&!e.nwdaymask[t]||i!==null&&!De(e.eastermask,t)||(rt(a)||rt(c))&&!De(a,e.mdaymask[t])&&!De(c,e.nmdaymask[t])||rt(l)&&(t<e.yearlen&&!De(l,t+1)&&!De(l,-e.yearlen+t)||t>=e.yearlen&&!De(l,t+1-e.yearlen)&&!De(l,-e.nextyearlen+t-e.yearlen))
}function rC(e,t){return new Fu(e,t.tzid).rezonedDate()}function Dn(e){return e.getValue()}function y5(e,t,n,r,o){
  let s=false;
  for(let i=t;i<n;i++){
    const a=e[i];
    s=N5(r,a,o);

    if (s) {
      (e[a] = null);
    }
  }return s
}function O5(e,t,n){
  const r=n.freq;
  const o=n.byhour;
  const s=n.byminute;
  const i=n.bysecond;

  if (gh(r)) {
    return QQ(n);
  }

  if (r>=pe.HOURLY&&rt(o)&&!De(o,t.hour)||r>=pe.MINUTELY&&rt(s)&&!De(s,t.minute)||r>=pe.SECONDLY&&rt(i)&&!De(i,t.second)) {
    return [];
  }

  return e.gettimeset(r)(t.hour,t.minute,t.second,t.millisecond);
}
var rn={MO:new gt(0),TU:new gt(1),WE:new gt(2),TH:new gt(3),FR:new gt(4),SA:new gt(5),SU:new gt(6)};
var Rh={freq:Ce.YEARLY,dtstart:null,interval:1,wkst:rn.MO,count:null,until:null,tzid:null,bysetpos:null,bymonth:null,bymonthday:null,bynmonthday:null,byyearday:null,byweekno:null,byweekday:null,bynweekday:null,byhour:null,byminute:null,bysecond:null,byeaster:null};
var b5=Object.keys(Rh);

var pe = (() => {
  class e {
    constructor(t = {}, n = false) {
      this._cache=n?null:new o5;
      this.origOptions=VL(t);
      const r=XQ(t).parsedOptions;this.options=r
    }

    static parseText(t, n) {return GL(t,n)}
    static fromText(t, n) {return WQ(t,n)}
    static fromString(t) {return new e(e.parseString(t)||void 0)}
    _iter(t) {return xL(t,this.options)}
    _cacheGet(t, n) {return this._cache?this._cache._cacheGet(t,n):false;}

    _cacheAdd(t, n, r) {if (this._cache) {
      return this._cache._cacheAdd(t,n,r)
    }}

    all(t) {
      if (t) {
        return this._iter(new Qb("all",{},t));
      }let n=this._cacheGet("all");

      if (n===false) {
        n=this._iter(new Io("all",{}));
        this._cacheAdd("all",n);
      }

      return n;
    }

    between(t, n, r = false, o) {
      if (!qa(t)||!qa(n)) {
        throw new Error("Invalid date passed in to RRule.between");
      }

      const s={before:n,after:t,inc:r};if (o) {
          return this._iter(new Qb("between",s,o));
        }let i=this._cacheGet("between",s);

      if (i===false) {
        i=this._iter(new Io("between",s));
        this._cacheAdd("between",i,s);
      }

      return i;
    }

    before(t, n = false) {
      if (!qa(t)) {
        throw new Error("Invalid date passed in to RRule.before");
      }

      const r={dt:t,inc:n};
      let o=this._cacheGet("before",r);

      if (o===false) {
        o=this._iter(new Io("before",r));
        this._cacheAdd("before",o,r);
      }

      return o;
    }

    after(t, n = false) {
      if (!qa(t)) {
        throw new Error("Invalid date passed in to RRule.after");
      }

      const r={dt:t,inc:n};
      let o=this._cacheGet("after",r);

      if (o===false) {
        o=this._iter(new Io("after",r));
        this._cacheAdd("after",o,r);
      }

      return o;
    }

    count() {return this.all().length}
    toString() {return Fp(this.origOptions)}
    toText(t, n, r) {return KQ(this,t,n,r)}
    isFullyConvertibleToText() {return zQ(this)}
    clone() {return new e(this.origOptions)}
    static accept(u) {const _=Number(u);return isNaN(_)?a.call(this,u):!i[_]&&(c(new Date(_-1),new Date(_+1)),!i[_])?(i[_]=true,a.call(this,u)):true;}
  }

  e.FREQUENCIES=["YEARLY","MONTHLY","WEEKLY","DAILY","HOURLY","MINUTELY","SECONDLY"];
  e.YEARLY=Ce.YEARLY;
  e.MONTHLY=Ce.MONTHLY;
  e.WEEKLY=Ce.WEEKLY;
  e.DAILY=Ce.DAILY;
  e.HOURLY=Ce.HOURLY;
  e.MINUTELY=Ce.MINUTELY;
  e.SECONDLY=Ce.SECONDLY;
  e.MO=rn.MO;
  e.TU=rn.TU;
  e.WE=rn.WE;
  e.TH=rn.TH;
  e.FR=rn.FR;
  e.SA=rn.SA;
  e.SU=rn.SU;
  e.parseString=Hp;
  e.optionsToString=Fp;
  return e;
})();

function C5(e,t,n,r,o,s){
  const i={};
  const a=e.accept;
  function c(u,_){n.forEach(p => {p.between(u,_,true).forEach(E => {i[Number(E)]=true})})}
  o.forEach(u => {const _=new Fu(u,s).rezonedDate();i[Number(_)]=true});

  if (e.method==="between") {
    c(e.args.after,e.args.before);
    e.accept=function(u){const _=Number(u);return i[_]?true:(i[_]=true,a.call(this,u));};
  }

  for(let l=0;l<r.length;l++){const f=new Fu(r[l],s).rezonedDate();if (!e.accept(new Date(f.getTime()))) {
    break
  }}t.forEach(u => {xL(e,u.options)});const d=e._result;
  _c(d);

  switch (e.method) {
  case"all":
  case "between":
    {
      return d;
    }
  case "before":
    {
      return d.length&&d[d.length-1]||null;
    }
  case"after":
  default:
    {
      return d.length&&d[0]||null
    }
  }
}const oC={dtstart:null,cache:false,unfold:false,forceset:false,compatible:false,tzid:null};function I5(e,t){
  const n=[];
  let r=[];
  const o=[];
  let s=[];
  const i=Hu(e);
  const a=i.dtstart;
  let c=i.tzid;
  const l=w5(e,t.unfold);

  l.forEach(f => {
    if(f){
      const u=L5(f);
      const _=u.name;
      const p=u.parms;
      const E=u.value;
      switch(_.toUpperCase()){case "RRULE":
        {
          if (p.length) {
            throw new Error(`unsupported RRULE parm: ${p.join(",")}`);
          }n.push(Hp(f));break;
        }case "RDATE":
        {
          const h=/RDATE(?:;TZID=([^:=]+))?/i.exec(f) ?? [];
          const T=h[1];

          if (T&&!c) {
            (c = T);
          }

          r=r.concat(iC(E,p));
          break;
        }case "EXRULE":
        {
          if (p.length) {
            throw new Error(`unsupported EXRULE parm: ${p.join(",")}`);
          }o.push(Hp(E));break;
        }case "EXDATE":
        {
          s=s.concat(iC(E,p));break;
        }case "DTSTART":
        {
          break;
        }default:
        {
          throw new Error(`unsupported property: ${_}`)
        }}
    }
  });

  return {dtstart:a,tzid:c,rrulevals:n,rdatevals:r,exrulevals:o,exdatevals:s};
}function P5(e,t){
  const n=I5(e,t);
  const r=n.rrulevals;
  const o=n.rdatevals;
  const s=n.exrulevals;
  const i=n.exdatevals;
  const a=n.dtstart;
  const c=n.tzid;
  const l=t.cache===false;

  if (t.compatible) {
    t.forceset=true;
    t.unfold=true;
  }

  if (t.forceset||r.length>1||o.length||s.length||i.length) {
    const f=new U5(l);
    f.dtstart(a);
    f.tzid(c||void 0);
    r.forEach(u => {f.rrule(new pe(K_(u,a,c),l))});
    o.forEach(u => {f.rdate(u)});
    s.forEach(u => {f.exrule(new pe(K_(u,a,c),l))});
    i.forEach(u => {f.exdate(u)});

    if (t.compatible&&t.dtstart) {
      f.rdate(a);
    }

    return f;
  }

  const d=r[0]||{};return new pe(K_(d,d.dtstart||t.dtstart||a,d.tzid||t.tzid||c),l)
}function sC(e, t = {}) {
  return P5(e,M5(t));
}function K_(e,t,n){return __assign(__assign({},e),{dtstart:t,tzid:n});}function M5(e){
  const t=[];
  const n=Object.keys(e);
  const r=Object.keys(oC);
  n.forEach(o => {
    if (!De(r,o)) {
      t.push(o);
    }
  });

  if (t.length) {
    throw new Error(`Invalid options: ${t.join(", ")}`);
  }

  return __assign(__assign({},oC),e);
}function v5(e){
  if (!e.includes(":")) {
    return{name:"RRULE",value:e};
  }
  const t=UQ(e,":",1);
  const n=t[0];
  const r=t[1];
  return{name:n,value:r}
}function L5(e){
  const t=v5(e);
  const n=t.name;
  const r=t.value;
  const o=n.split(";");
  if (!o) {
    throw new Error("empty property name");
  }return{name:o[0].toUpperCase(),parms:o.slice(1),value:r}
}function w5(e, t = false) {
  e=e&&e.trim();

  if (!e) {
    throw new Error("Invalid empty string");
  }

  if (!t) {
    return e.split(/\s/);
  }for(var n=e.split(`
    `),r=0;r<n.length;){
    const o=n[r]=n[r].replace(/\s+$/g,"");

    if (o) {
      if (r>0&&o[0]===" ") {
        n[r-1]+=o.slice(1);
        n.splice(r,1);
      } else {
        r+=1;
      }
    } else {
      n.splice(r,1);
    }
  }return n
}function D5(e){e.forEach(t => {if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(t)) {
  throw new Error(`unsupported RDATE/EXDATE parm: ${t}`)
}})}function iC(e,t){
  D5(t);
  return e.split(",").map(n => mh(n));
}function aC(e){const t=this;return n => {
  if (n!==void 0) {
    (t[`_${e}`] = n);
  }

  if (t[`_${e}`]!==void 0) {
    return t[`_${e}`];
  }

  for(let r=0;r<t._rrule.length;r++){const o=t._rrule[r].origOptions[e];if (o) {
    return o
  }}
};}var U5 = (e => {
  __extends(t,e);

  class t {
    constructor(n = false) {
      const r=e.call(this,{},n)||this;
      r.dtstart=aC.apply(r,["dtstart"]);
      r.tzid=aC.apply(r,["tzid"]);
      r._rrule=[];
      r._rdate=[];
      r._exrule=[];
      r._exdate=[];
      return r;
    }

    _iter(n) {return C5(n,this._rrule,this._exrule,this._rdate,this._exdate,this.tzid())}
    rrule(n) {cC(n,this._rrule)}
    exrule(n) {cC(n,this._exrule)}
    rdate(n) {uC(n,this._rdate)}
    exdate(n) {uC(n,this._exdate)}
    rrules() {return this._rrule.map(n => sC(n.toString()));}
    exrules() {return this._exrule.map(n => sC(n.toString()));}
    rdates() {return this._rdate.map(n => new Date(n.getTime()));}
    exdates() {return this._exdate.map(n => new Date(n.getTime()));}

    valueOf() {
      let n=[];

      if (!this._rrule.length&&this._dtstart) {
        (n = n.concat(Fp({dtstart:this._dtstart})));
      }

      this._rrule.forEach(r => {n=n.concat(r.toString().split(`
      `))});

      this._exrule.forEach(r => {n=n.concat(r.toString().split(`
      `).map(o => o.replace(/^RRULE:/,"EXRULE:")).filter(o => !/^DTSTART/.test(o)))});

      if (this._rdate.length) {
        n.push(lC("RDATE",this._rdate,this.tzid()));
      }

      if (this._exdate.length) {
        n.push(lC("EXDATE",this._exdate,this.tzid()));
      }

      return n;
    }

    toString() {return this.valueOf().join(`
    `)}

    clone() {
      const n=new t(!!this._cache);
      this._rrule.forEach(r => n.rrule(r.clone()));
      this._exrule.forEach(r => n.exrule(r.clone()));
      this._rdate.forEach(r => n.rdate(new Date(r.getTime())));
      this._exdate.forEach(r => n.exdate(new Date(r.getTime())));
      return n;
    }
  }

  return t;
})(pe);function cC(e,t){
  if (!(e instanceof pe)) {
    throw new TypeError(`${String(e)} is not RRule instance`);
  }

  if (!De(t.map(String),String(e))) {
    t.push(e);
  }
}function uC(e,t){
  if (!(e instanceof Date)) {
    throw new TypeError(`${String(e)} is not Date instance`);
  }

  if (!De(t.map(Number),Number(e))) {
    t.push(e);
    _c(t);
  }
}function lC(e,t,n){
  const r=!n||n.toUpperCase()==="UTC";
  const o=r?`${e}:`:`${e};TZID=${n}:`;
  const s=t.map(i => Sh(i.valueOf(),r)).join(",");
  return `${o}${s}`;
}/*!
* Copyright (c) Squirrel Chat et al., All rights reserved.
* SPDX-License-Identifier: BSD-3-Clause
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
* 1. Redistributions of source code must retain the above copyright notice, this
*    list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright notice,
*    this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
* 3. Neither the name of the copyright holder nor the names of its contributors
*    may be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/function k5(e,t){let n=e.slice(0,t).split(/\r\n|\n|\r/g);return[n.length,n.pop().length+1]}function G5(e,t,n){
  let r=e.split(/\r\n|\n|\r/g);
  let o="";
  let s=(Math.log10(t+1)|0)+1;
  for(let i=t-1;i<=t+1;i++){
    let a=r[i-1];

    if (a) {
      o+=i.toString().padEnd(s," ");
      o+=":  ";
      o+=a;

      o+=`
      `;

      i===t&&(o+=" ".repeat(s+n+2),o+=`^
      `);
    }
  }return o
}class ge extends Error{line;column;codeblock;constructor(t,n){
  const [r,o]=k5(n.toml,n.ptr);
  const s=G5(n.toml,r,o);

  super(`Invalid TOML document: ${t}

  ${s}`,n);

  this.line=r;
  this.column=o;
  this.codeblock=s;
}}/*!
* Copyright (c) Squirrel Chat et al., All rights reserved.
* SPDX-License-Identifier: BSD-3-Clause
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
* 1. Redistributions of source code must retain the above copyright notice, this
*    list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright notice,
*    this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
* 3. Neither the name of the copyright holder nor the names of its contributors
*    may be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/function V5(e,t){
  let n=0;

  while (e[t-++n]==="\\")
    {}

  return--n&&n%2
}function Yu(e,t=0,n=e.length){
  let r=e.indexOf(`
  `,t);

  if (e[r-1]==="\r") {
    r--;
  }

  return r<=n?r:-1;
}function Nh(e,t){for(let n=t;n<e.length;n++){let r=e[n];if (r===`
`) {
  return n;
}if (r==="\r"&&e[n+1]===`
`) {
  return n+1;
}if (r<" "&&r!=="	"||r==="") {
  throw new ge("control characters are not allowed in comments",{toml:e,ptr:t})
}}return e.length}function Bn(e,t,n,r){
  let o;

  while ((o=e[t])===" "||o==="	"||!n&&(o===`
       `||o==="\r"&&e[t+1]===`
       `)) {
    t++;
  }

  return r||o!=="#"?t:Bn(e,Nh(e,t),n)
}function dC(e,t,n,r,o=false){if (!r) {
  t=Yu(e,t);
  return t<0?e.length:t;
}for(let s=t;s<e.length;s++){let i=e[s];if (i==="#") {
  s=Yu(e,s);
} else {if (i===n) {
  return s+1;
}if (i===r||o&&(i===`
`||i==="\r"&&e[s+1]===`
`)) {
  return s
}}}throw new ge("cannot find end of structure",{toml:e,ptr:t})}function $L(e,t){
  let n=e[t];
  let r=n===e[t+1]&&e[t+1]===e[t+2]?e.slice(t,t+3):n;
  t+=r.length-1;do {
      t=e.indexOf(r,++t);
    } while (t>-1&&n!=="'"&&V5(e,t));

  if (t>-1) {
    t+=r.length;
    r.length>1&&(e[t]===n&&t++,e[t]===n&&t++);
  }

  return t;
}/*!
* Copyright (c) Squirrel Chat et al., All rights reserved.
* SPDX-License-Identifier: BSD-3-Clause
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
* 1. Redistributions of source code must retain the above copyright notice, this
*    list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright notice,
*    this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
* 3. Neither the name of the copyright holder nor the names of its contributors
*    may be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/let x5=/^(\d{4}-\d{2}-\d{2})?[T ]?(?:(\d{2}):\d{2}:\d{2}(?:\.\d+)?)?(Z|[-+]\d{2}:\d{2})?$/i;class Po extends Date{#e=false;#t=false;#r=null;constructor(t){
  let n=true;
  let r=true;
  let o="Z";
  if(typeof t=="string"){
    let s=t.match(x5);

    if (s) {
      s[1]||(n=false,t=`0000-01-01T${t}`);
      r=!!s[2];
      r&&t[10]===" "&&(t=t.replace(" ","T"));
      s[2]&&+s[2]>23?t="":(o=s[3]||null,t=t.toUpperCase(),!o&&r&&(t+="Z"));
    } else {
      t="";
    }
  }
  super(t);

  if (!isNaN(this.getTime())) {
    this.#e=n;
    this.#t=r;
    this.#r=o;
  }
}isDateTime(){return this.#e&&this.#t}isLocal(){return!this.#e||!this.#t||!this.#r}isDate(){return this.#e&&!this.#t}isTime(){return this.#t&&!this.#e}isValid(){return this.#e||this.#t}toISOString(){
  let t=super.toISOString();if (this.isDate()) {
    return t.slice(0,10);
  }if (this.isTime()) {
    return t.slice(11,23);
  }if (this.#r===null) {
    return t.slice(0,-1);
  }if (this.#r==="Z") {
    return t;
  }let n=+this.#r.slice(1,3)*60+ +this.#r.slice(4,6);
  n=this.#r[0]==="-"?n:-n;
  return new Date(this.getTime()-n*60000/* 6e4 */).toISOString().slice(0,-1)+this.#r;
}static wrapAsOffsetDateTime(t,n="Z"){
  let r=new Po(t);
  r.#r=n;
  return r;
}static wrapAsLocalDateTime(t){
  let n=new Po(t);
  n.#r=null;
  return n;
}static wrapAsLocalDate(t){
  let n=new Po(t);
  n.#t=false;
  n.#r=null;
  return n;
}static wrapAsLocalTime(t){
  let n=new Po(t);
  n.#e=false;
  n.#r=null;
  return n;
}}

/*!
* Copyright (c) Squirrel Chat et al., All rights reserved.
* SPDX-License-Identifier: BSD-3-Clause
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
* 1. Redistributions of source code must retain the above copyright notice, this
*    list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright notice,
*    this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
* 3. Neither the name of the copyright holder nor the names of its contributors
*    may be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/let $5=/^((0x[0-9a-fA-F](_?[0-9a-fA-F])*)|(([+-]|0[ob])?\d(_?\d)*))$/;

let B5=/^[+-]?\d(_?\d)*(\.\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?$/;
let H5=/^[+-]?0[0-9_]/;
let F5=/^[0-9a-f]{4,8}$/i;

let fC={b:"\b",t:"	",n:`
`,f:"\f",r:"\r",'"':'"',"\\":"\\"};

function BL(e,t=0,n=e.length){
  let r=e[t]==="'";
  let o=e[t++]===e[t]&&e[t]===e[t+1];

  if (o) {
    n-=2;
    e[t+=2]==="\r"&&t++;

    e[t]===`
    `&&t++;
  }

  let s=0;
  let i;
  let a="";
  let c=t;

  while (t<n-1) {let l=e[t++];if(l===`
  `||l==="\r"&&e[t]===`
  `){if (!o) {
    throw new ge("newlines are not allowed in strings",{toml:e,ptr:t-1})
  }}else if (l<" "&&l!=="	"||l==="") {
    throw new ge("control characters are not allowed in strings",{toml:e,ptr:t-1});
  }if (i) {
    i=false;

    if (l==="u"||l==="U") {let f=e.slice(t,t+=l==="u"?4:8);if (!F5.test(f)) {
      throw new ge("invalid unicode escape",{toml:e,ptr:s});
    }try{a+=String.fromCodePoint(parseInt(f,16))}catch{throw new ge("invalid unicode escape",{toml:e,ptr:s})}} else if(o&&(l===`
    `||l===" "||l==="	"||l==="\r")){
      t=Bn(e,t-1,true);

      if (e[t]!==`
      `&&e[t]!=="\r") {
        throw new ge("invalid escape: only line-ending whitespace may be escaped",{toml:e,ptr:s});
      }

      t=Bn(e,t)
    }else if (l in fC) {
      a+=fC[l];
    } else {
      throw new ge("unrecognized escape sequence",{toml:e,ptr:s});
    }

    c=t
  } else {
    if (!r&&l==="\\") {
      s=t-1;
      i=true;
      a+=e.slice(c,s);
    }
  }}

  return a+e.slice(c,n-1)
}function Y5(e,t,n,r){if (e==="true") {
  return true;
}if (e==="false") {
  return false;
}if (e==="-inf") {
  return -Infinity;
}if (e==="inf"||e==="+inf") {
  return Infinity;
}if (e==="nan"||e==="+nan"||e==="-nan") {
  return NaN;
}if (e==="-0") {
  return r?0n:0;
}let o=$5.test(e);if(o||B5.test(e)){if (H5.test(e)) {
  throw new ge("leading zeroes are not allowed",{toml:t,ptr:n});
}e=e.replace(/_/g,"");let i=+e;if (isNaN(i)) {
  throw new ge("invalid number",{toml:t,ptr:n});
}if(o){
  if ((o=!Number.isSafeInteger(i))&&!r) {
    throw new ge("integer value cannot be represented losslessly",{toml:t,ptr:n});
  }

  if ((o || r===true)) {
    (i = BigInt(e));
  }
}return i}const s=new Po(e);if (!s.isValid()) {
  throw new ge("invalid value",{toml:t,ptr:n});
}return s}/*!
* Copyright (c) Squirrel Chat et al., All rights reserved.
* SPDX-License-Identifier: BSD-3-Clause
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
* 1. Redistributions of source code must retain the above copyright notice, this
*    list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright notice,
*    this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
* 3. Neither the name of the copyright holder nor the names of its contributors
*    may be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/function j5(e,t,n,r){
  let o=e.slice(t,n);
  let s=o.indexOf("#");

  if (s>-1) {
    Nh(e,s);
    o=o.slice(0,s);
  }

  let i=o.trimEnd();if(!r){let a=o.indexOf(`
    `,i.length);if (a>-1) {
      throw new ge("newlines are not allowed in inline tables",{toml:e,ptr:t+a})
    }}return[i,s]
}function yh(e,t,n,r,o){
  if (r===0) {
    throw new ge("document contains excessively nested structures. aborting.",{toml:e,ptr:t});
  }let s=e[t];if(s==="["||s==="{"){
      let [c,l]=s==="["?K5(e,t,r,o):W5(e,t,r,o);
      let f=n?dC(e,l,",",n):l;
      if(l-f&&n==="}"){let d=Yu(e,l,f);if (d>-1) {
        throw new ge("newlines are not allowed in inline tables",{toml:e,ptr:d})
      }}return[c,f]
    }let i;if(s==='"'||s==="'"){i=$L(e,t);let c=BL(e,t,i);if(n){
      i=Bn(e,i,n!=="]");

      if (e[i]&&e[i]!==","&&e[i]!==n&&e[i]!==`
      `&&e[i]!=="\r") {
        throw new ge("unexpected character encountered",{toml:e,ptr:i});
      }

      i+=+(e[i]===",")
    }return[c,i]}i=dC(e,t,",",n);let a=j5(e,t,i-+(e[i-1]===","),n==="]");if (!a[0]) {
      throw new ge("incomplete key-value declaration: no value specified",{toml:e,ptr:t});
    }

  if (n&&a[1]>-1) {
    i=Bn(e,t+a[1]);
    i+=+(e[i]===",");
  }

  return [Y5(a[0],e,t,o),i];
}/*!
* Copyright (c) Squirrel Chat et al., All rights reserved.
* SPDX-License-Identifier: BSD-3-Clause
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
* 1. Redistributions of source code must retain the above copyright notice, this
*    list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright notice,
*    this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
* 3. Neither the name of the copyright holder nor the names of its contributors
*    may be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/let q5=/^[a-zA-Z0-9-_]+[ \t]*$/;function Yp(e,t,n="="){
  let r=t-1;
  let o=[];
  let s=e.indexOf(n,t);
  if (s<0) {
    throw new ge("incomplete key-value: cannot find end of key",{toml:e,ptr:t});
  }do{let i=e[t=++r];if (i!==" "&&i!=="	") {
    if(i==='"'||i==="'"){
      if (i===e[t+1]&&i===e[t+2]) {
        throw new ge("multiline strings are not allowed in keys",{toml:e,ptr:t});
      }let a=$L(e,t);if (a<0) {
        throw new ge("unfinished string encountered",{toml:e,ptr:t});
      }r=e.indexOf(".",a);
      let c=e.slice(a,r<0||r>s?s:r);
      let l=Yu(c);
      if (l>-1) {
        throw new ge("newlines are not allowed in keys",{toml:e,ptr:t+r+l});
      }if (c.trimStart()) {
        throw new ge("found extra tokens after the string part",{toml:e,ptr:a});
      }if (s<a&&(s=e.indexOf(n,a),s<0)) {
        throw new ge("incomplete key-value: cannot find end of key",{toml:e,ptr:t});
      }o.push(BL(e,t,a))
    }else{r=e.indexOf(".",t);let a=e.slice(t,r<0||r>s?s:r);if (!q5.test(a)) {
      throw new ge("only letter, numbers, dashes and underscores are allowed in keys",{toml:e,ptr:t});
    }o.push(a.trimEnd())}
  }}while(r+1&&r<s);return [o,Bn(e,s+1,true,true)];
}function W5(e,t,n,r){
  let o={};
  let s=new Set;
  let i;
  let a=0;
  for(t++;(i=e[t++])!=="}"&&i;){let c={toml:e,ptr:t-1};if (i===`
  `) {
    throw new ge("newlines are not allowed in inline tables",c);
  }if (i==="#") {
    throw new ge("inline tables cannot contain comments",c);
  }if (i===",") {
    throw new ge("expected key-value, found comma",c);
  }if(i!==" "&&i!=="	"){
    let l;
    let f=o;
    let d=false;
    let [u,_]=Yp(e,t-1);
    for(let h=0;h<u.length;h++){
      if (h) {
        (f = d?f[l]:f[l]={});
      }

      l=u[h];

      if ((d=Object.hasOwn(f,l))&&(typeof f[l]!="object"||s.has(f[l]))) {
        throw new ge("trying to redefine an already defined value",{toml:e,ptr:t});
      }

      if (!d&&l==="__proto__") {
        Object.defineProperty(f,l,{enumerable:true,configurable:true,writable:true});
      }
    }if (d) {
      throw new ge("trying to redefine an already defined value",{toml:e,ptr:t});
    }let[p,E]=yh(e,_,"}",n-1,r);
    s.add(p);
    f[l]=p;
    t=E;
    a=e[t-1]===","?t-1:0;
  }}if (a) {
    throw new ge("trailing commas are not allowed in inline tables",{toml:e,ptr:a});
  }if (!i) {
    throw new ge("unfinished table encountered",{toml:e,ptr:t});
  }return[o,t]
}function K5(e,t,n,r){
  let o=[];
  let s;
  for(t++;(s=e[t++])!=="]"&&s;){if (s===",") {
    throw new ge("expected value, found comma",{toml:e,ptr:t-1});
  }if (s==="#") {
    t=Nh(e,t);
  } else if(s!==" "&&s!=="	"&&s!==`
  `&&s!=="\r"){
    let i=yh(e,t-1,"]",n-1,r);
    o.push(i[0]);
    t=i[1];
  }}if (!s) {
    throw new ge("unfinished array encountered",{toml:e,ptr:t});
  }return[o,t]
}/*!
* Copyright (c) Squirrel Chat et al., All rights reserved.
* SPDX-License-Identifier: BSD-3-Clause
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
* 1. Redistributions of source code must retain the above copyright notice, this
*    list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright notice,
*    this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
* 3. Neither the name of the copyright holder nor the names of its contributors
*    may be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/function _C(e,t,n,r){
  let o=t;
  let s=n;
  let i;
  let a=false;
  let c;
  for(let l=0;l<e.length;l++){
    if(l){
      o=a?o[i]:o[i]={};
      s=(c=s[i]).c;

      if (r===0&&(c.t===1||c.t===2)) {
        return null;
      }

      if(c.t===2){
        let f=o.length-1;
        o=o[f];
        s=s[f].c;
      }
    }
    i=e[l];

    if ((a=Object.hasOwn(o,i))&&s[i]?.t===0&&s[i]?.d) {
      return null;
    }

    if (!a) {
      i==="__proto__"&&(Object.defineProperty(o,i,{enumerable:true,configurable:true,writable:true}),Object.defineProperty(s,i,{enumerable:true,configurable:true,writable:true}));
      s[i]={t:l<e.length-1&&r===2?3:r,d:false,i:0,c:{}};
    }
  }
  c=s[i];

  if (c.t!==r&&!(r===1&&c.t===3)||(r===2&&(c.d||(c.d=true,o[i]=[]),o[i].push(o={}),c.c[c.i++]=c={t:1,d:false,i:0,c:{}}),c.d)) {
    return null;
  }

  c.d=true;

  if (r===1) {
    o=a?o[i]:o[i]={};
  } else if (r===0&&a) {
    return null;
  }

  return[i,o,c.c]
}function z5(e,{maxDepth:t=1000/* 1e3 */,integersAsBigInt:n}={}){
  let r={};
  let o={};
  let s=r;
  let i=o;
  for(let a=Bn(e,0);a<e.length;){
    if(e[a]==="["){
      let c=e[++a]==="[";
      let l=Yp(e,a+=+c,"]");
      if(c){if (e[l[1]-1]!=="]") {
        throw new ge("expected end of table declaration",{toml:e,ptr:l[1]-1});
      }l[1]++}let f=_C(l[0],r,o,c?2:1);if (!f) {
        throw new ge("trying to redefine an already defined table or value",{toml:e,ptr:a});
      }
      i=f[2];
      s=f[1];
      a=l[1];
    }else{
      let c=Yp(e,a);
      let l=_C(c[0],s,i,0);
      if (!l) {
        throw new ge("trying to redefine an already defined table or value",{toml:e,ptr:a});
      }let f=yh(e,c[1],void 0,t,n);
      l[1][l[0]]=f[0];
      a=f[1];
    }
    a=Bn(e,a,true);

    if (e[a]&&e[a]!==`
    `&&e[a]!=="\r") {
      throw new ge("each key-value declaration must be followed by an end-of-line",{toml:e,ptr:a});
    }

    a=Bn(e,a)
  }return r
}function Z5(e,t,n){
  const r=rQ(t);
  const o={message:r.message,status:X5(e),source:n.source,service:n.source,env:n.env,date:Date.now(),logger:{name:r.loggerName??"app"},"codex.app_session_id":n.codexAppSessionId,usr:n.userInfo};
  Q5(o,n.buildInfo);
  return o;
}function X5(e){switch(e){case"trace":case "debug":
  {
    return"debug";
  }case "info":
  {
    return"info";
  }case "warning":
  {
    return"warn";
  }case "error":
  {
    return"error"
  }}}function Q5(e,t){
  z_(e,"build_number",t.buildNumber);
  z_(e,"version",t.version);
  z_(e,"app_version",t.version);
}function z_(e,t,n){
  if (n!=null) {
    (e[t] = n);
  }
}
const J5=5000/* 5e3 */;
const e6=50;
const t6=64000/* 64e3 */;
class n6{onFlush;flushIntervalMs;maxBatchSize;maxBatchBytes;buffer=[];bufferBytes=0;flushTimeout=null;constructor(t){
  this.onFlush=t.onFlush;
  this.flushIntervalMs=t.flushIntervalMs??J5;
  this.maxBatchSize=t.maxBatchSize??e6;
  this.maxBatchBytes=t.maxBatchBytes??t6;
}enqueue(t){
  this.buffer.push(t);
  this.bufferBytes+=t.length;

  if (this.buffer.length>=this.maxBatchSize||this.bufferBytes>=this.maxBatchBytes)
    {this.flush();return}

  this.scheduleFlush()
}flushNow(){this.flush()}scheduleFlush(){
  if (this.flushTimeout==null) {
    (this.flushTimeout = setTimeout(()=>{this.flush()},this.flushIntervalMs));
  }
}flush(){
  if(this.buffer.length===0){this.clearFlushTimeout();return}const t=this.buffer.splice(0,this.buffer.length);
  this.bufferBytes=0;
  this.clearFlushTimeout();
  this.onFlush(t);
}clearFlushTimeout(){
  if (this.flushTimeout!=null) {
    clearTimeout(this.flushTimeout);
    this.flushTimeout=null;
  }
}}
const r6="https://chat.openai.com/ces/v1/telemetry/intake";
const o6="dummy-token";
const s6="browser";
const i6=2000/* 2e3 */;
const a6=30000/* 3e4 */;
const c6=5;
class u6{options;reportFailure;batcher;queue=[];inFlightSend=null;retryTimeout=null;retryAttempts=0;disabled=false;reportedDisabledReason=false;fetchImpl;userInfo=null;constructor(t){
  this.options=t;
  this.reportFailure=t.reportFailure;
  this.fetchImpl=t.fetchImpl??fetch;

  this.batcher=new n6({onFlush:n => this.enqueueBatch(n)});
}setUserInfo(t){this.userInfo=t}log(t,n){const r=Z5(t,n,{buildInfo:this.options.buildInfo,userInfo:this.userInfo,codexAppSessionId:this.options.codexAppSessionId,source:this.options.source,env:this.options.env});this.batcher.enqueue(JSON.stringify(r))}flushNow(){
  this.batcher.flushNow();
  this.drainQueue();
}enqueueBatch(t){
  if (!this.disabled) {
    if (t.length!==0) {
      this.queue.push({requestId:tc.randomUUID(),events:t});
      this.drainQueue();
    }
  }
}async drainQueue(){if(this.disabled){this.queue.length=0;return}if (this.inFlightSend!=null||this.retryTimeout!=null) {
  return;
}const t=this.queue[0];if (t==null) {
  return;
}const n=t.events.join(`
`);this.inFlightSend=(async()=>{try{
  await this.send(n,t.requestId);
  this.queue.shift();
  this.retryAttempts=0;
}catch{if(this.disabled){this.queue.length=0;return}this.scheduleRetry()}finally{
  this.inFlightSend=null;
  this.drainQueue();
}})()}scheduleRetry(){if (this.retryTimeout!=null) {
  return;
}if(this.retryAttempts>=c6){
  this.queue.shift();
  this.retryAttempts=0;
  this.drainQueue();
  return
}this.retryAttempts+=1;const t=Math.min(a6,i6*2 ** (this.retryAttempts - 1));this.retryTimeout=setTimeout(()=>{
  this.retryTimeout=null;
  this.drainQueue();
},t)}disableWithFailure(t){
  this.disabled=true;

  if (!this.reportedDisabledReason) {
    this.reportedDisabledReason=true;
    this.reportFailure(t);
  }
}async send(t,n){
  const r=l6(n);
  const o=await this.fetchImpl(r,{method:"POST",headers:{"content-type":"text/plain","x-request-id":n},body:Buffer.from(t)});
  if(!o.ok){const s=await o.text();if (o.status>=400&&o.status<500) {
    if ((o.status===401 || o.status===403)) {
      this.disableWithFailure({type:"disabled",reason:"invalid_client_token",status:o.status,body:s});
    }

    return o.status;
  }throw new Error(`[datadog] non-2xx response (${o.status})`)}return o.status
}}function l6(e){const n=`/api/v2/logs?${new URLSearchParams({ddsource:"browser","dd-api-key":o6,"dd-evp-origin":s6,"dd-request-id":e}).toString()}`;return`${r6}?ddforward=${encodeURIComponent(n)}`}function Z_(e,t){
  let n=null;
  let r=null;
  const o=((...s)=>{
    r=s;

    if (n) {
      clearTimeout(n);
    }

    n=setTimeout(()=>{
      n=null;const i=r;
      r=null;

      if (i) {
        e(...i);
      }
    },t);
  });

  o.cancel=()=>{
    if (n) {
      clearTimeout(n);
      n=null;
    }

    r=null;
  };

  return o;
}function d6(e){const t=(n,r,o)=>{const s=typeof n=="string"?new Error(n):n;try{e(s,r,o)}catch{}};return {report:t,reportNonFatal:(n, r) => t(n,"non-fatal",r),reportFatal:(n, r) => t(n,"fatal",r)};}async function f6(e,t){let n;try{
  const o=await lr.readFile(e,t);
  n=z5(o);
  n=_6(n);
}catch(o){return{configPath:e,cwdRelativeToGitRoot:e,type:"error",error:new Error(`Failed to parse environment config at ${e}: ${String(o)}`)}}const r=V9.safeParse(n);return r.success?{configPath:e,cwdRelativeToGitRoot:await T6(e,t),type:"success",environment:E6(r.data)}:{configPath:e,cwdRelativeToGitRoot:e,type:"error",error:new Error(`Invalid environment config at ${e}: ${r.error.toString()}`)}}function _6(e){return !HL(e)||!Array.isArray(e.actions)?e:{...e,actions:e.actions.filter(t => p6(t))};}function p6(e){return !HL(e)||typeof e.name!="string"||typeof e.command!="string"?false:e.name.trim().length>0&&e.command.trim().length>0;}function HL(e){return typeof e=="object"&&e!=null&&!Array.isArray(e)}function E6(e){return {...e,name:e.name.trim(),setup:h6(e.setup),actions:e.actions?e.actions.map(t => ({
  ...t,
  name:t.name.trim(),
  command:t.command.trim()
})):void 0};}function h6(e){return{...e,script:e.script.trim(),darwin:e.darwin?{script:e.darwin.script.trim()}:void 0,linux:e.linux?{script:e.linux.script.trim()}:void 0,win32:e.win32?{script:e.win32.script.trim()}:void 0}}async function T6(e,t){
  const n=fn(t);
  const r=await S6(e,t);
  let o=r;

  while (o!==n.dirname(o)&&!(await FL(o,t))) {
      o=n.dirname(o);
    }

  const s=n.relative(o,r);return s===""?".":s
}async function FL(e,t){const n=fn(t);try{const r=await lr.stat(n.join(e,".git"),t);return r.isDirectory()||r.isFile()}catch{return false;}}async function S6(e,t){
  const n=fn(t);let r=n.dirname(e);

  while (r!==n.dirname(r)) {if (await m6(r,t)) {
    return r;
  }if (await FL(r,t)) {
    return r;
  }r=n.dirname(r)}

  return e
}async function m6(e,t){const n=fn(t);try{const r=await lr.stat(n.join(e,".codex"),t);return r.isDirectory()||r.isFile()}catch{return false;}}const X_=Pt("git");async function re(e,t,n,r={}){
  const {env,signal,timeoutMs,onStdoutRaw,onStderrRaw,maxOutputBytes,trim=true,allowedNonZeroExitCodes}=r;
  const u={GIT_TERMINAL_PROMPT:"0",...env};
  const _=g6(e,t,n);
  const p=nQ(_);
  const E=A6(t);
  if (signal&&signal.aborted) {
    return {command:p,success:false,code:null,stdout:"",stderr:"git process aborted"};
  }
  let h=false;
  let T=false;
  let m;
  let A=0;
  const g=crypto.randomUUID().slice(0,8);
  let R;
  let O="";
  let I="";
  let b=null;
  const L=(H,$)=>{
    A+=$.length;

    if (maxOutputBytes!=null&&A>maxOutputBytes&&m==null) {
      m={stream:H,limitBytes:maxOutputBytes};
      X_().warning(`[${g}] output limit exceeded: ${H} ${A} > ${maxOutputBytes}`);
      R.kill();
    }

    if (H==="stdout") {
      onStdoutRaw?.($);
    } else {
      onStderrRaw?.($);
    }
  };try{
    if (Ue(n)) {
      R=await ur({hostConfig:n,args:_,env:u,stdoutChunkHandler:H => L("stdout",H),stderrChunkHandler:H => L("stderr",H)});
    } else {
      R=IL({args:_,cwd:e,env:{...process.env,...u},stdoutChunkHandler:H => L("stdout",H),stderrChunkHandler:H => L("stderr",H)});
    }
  }catch(H){X_().warning(`[${g}] failed to start git process (${E}, error=${st(H)})`);const $=H instanceof Error?H.message:"Failed to start git process";return {command:p,success:false,code:null,stdout:"",stderr:$};}const U=()=>{
      T=true;
      R.kill();
    };

  if (signal) {
    signal.addEventListener("abort",U);
    signal.aborted&&U();
  }

  const q=timeoutMs!=null?setTimeout(()=>{
      h=true;
      R.kill();
    },timeoutMs):null;try{
    const{stdout,stderr,code}=await R.wait();
    O=trim?stdout.trim():stdout;
    I=trim?stderr.trim():stderr;
    b=code;

    if (q) {
      clearTimeout(q);
    }

    if (signal) {
      signal.removeEventListener("abort",U);
    }

    if (T) {
      return {command:p,success:false,code:b,stdout:O,stderr:I?`${I}
      git process aborted`:"git process aborted",outputLimitExceeded:m,process:R};
    }

    const F=m==null&&b!=null&&(b===0||Array.isArray(allowedNonZeroExitCodes)&&allowedNonZeroExitCodes.includes(b));

    if (!F) {
      X_().warning(`[${g}] encountered an error running git command (${E}, code=${b}, stderr=${st(I)})`);
    }

    return {command:p,success:F,code:b,stdout:O,stderr:h?`${I}git process timed out after ${timeoutMs}ms`:I,outputLimitExceeded:m,process:R};
  }catch(H){
    if (q) {
      clearTimeout(q);
    }

    if (signal) {
      signal.removeEventListener("abort",U);
    }

    const $=H instanceof Error?H.message:String(H);return {command:p,success:false,code:b,stdout:R?.getStdout().toString("utf8")??O,stderr:R?.getStderr().toString("utf8")??($?`${I}${$}`:I),outputLimitExceeded:m,process:R};
  }
}function A6(e){return`subcommand=${e[0]??"<none>"},args=${e.length}`}function g6(e,t,n){return Ue(n)?["git","--no-optional-locks","-C",e,...t]:["git","--no-optional-locks",...t]}async function YL(e,t=null){
  const n=fn(t);
  const {success,stdout}=await re(e,["rev-parse","--git-dir"],t,{allowedNonZeroExitCodes:[128]});
  return !success||!stdout?null:n.isAbsolute(stdout)?stdout:n.resolve(e,stdout);
}async function R6(e,t){if (t) {
  try{const n=bw.join(t,qL);if ((await de.promises.stat(n)).isFile()) {
    return true;
  }}catch{}
}return N6(e)}async function N6(e){try{const t=await de.promises.stat(e);return t.birthtimeMs>0?t.birthtimeMs<y6:true;}catch{return false;}}async function jL(e,t=null){try{
  const n=fn(t);
  const r=await YL(e,t);
  if (!r) {
    return {success:false,error:new Error("Failed to resolve worktree git directory")};
  }const o=n.join(r,qL);
  await lr.writeFile(o,"",t);
  return {success:true};
}catch(n){return {success:false,error:n instanceof Error?n:new Error("Failed to mark worktree")};}}
const qL="codex-managed";
const y6=new Date("2026-01-29T00:00:00").getTime();
const on=5*1024*1024;
const Qa="origin";
const O6=["-c","diff.mnemonicPrefix=false","-c","diff.noprefix=false","-c","core.quotePath=false"];
const b6=["diff","--no-ext-diff","--no-textconv","--color=never","--src-prefix=a/","--dst-prefix=b/"];
function rr(e){return e?.outputLimitExceeded?{type:"diff-too-large",limitBytes:e.outputLimitExceeded.limitBytes}:{type:"unknown"}}async function sn(e,t,n,r={}){return re(e,[...O6,...b6,...(r.binary ? ["--binary"] : []),...t],n,{...r,maxOutputBytes:r.maxOutputBytes??on});}const C6=8;async function WL(e,t,n,r){
  if (!t.success) {
    return {success:false,error:{type:"unknown"}};
  }
  const o=new AbortController;
  const s=()=>{o.abort()};
  r?.addEventListener("abort",s);

  if (r?.aborted) {
    s();
  }

  const i=t.paths;
  const a=[];
  const c=Array.from({length:i.length},()=>{});
  let l=0;
  let f=0;
  let d=0;
  let u=false;
  let _=null;
  const p=g=>{
    if (!u) {
      u=true;
      _=g;
      o.abort();
    }
  };

  const E=g=>{
    const R=g.trim();if (R.length===0||u) {
      return;
    }

    const O=a.length>0?`
    `:"";

    const I=Buffer.byteLength(`${O}${R}`,"utf8");
    if(l+I>on){p({type:"diff-too-large",limitBytes:on});return}
    l+=I;
    a.push(g);
  };

  const h=()=>{if (!u) {
    while (d<c.length) {
      const g=c[d];if (g===void 0) {
        return;
      }
      d+=1;

      if (!(g==null||g.trim().length===0)&&(E(g),u)) {
        return
      }
    }
  }};

  const T=()=>{
    if (u||f>=i.length) {
      return null;
    }
    const g=i[f];
    const R=f;
    f+=1;
    return {index:R,path:g};
  };

  const m=async()=>{
    if (u) {
      return;
    }const g=T();if (g==null) {
      return;
    }const R=await sn(e,["--no-index","--","/dev/null",g.path],n,{trim:false,allowedNonZeroExitCodes:[0,1],signal:o.signal});if(R.outputLimitExceeded){p(rr(R));return}if(!R.success){p(rr(R));return}
    c[g.index]=R.stdout.trim().length>0?R.stdout:null;
    h();
    await m();
  };

  const A=Math.min(C6,i.length);
  try{await Promise.all(Array.from({length:A},() => m()))}finally{r?.removeEventListener("abort",s)}return _?{success:false,error:_}:{success:true,sections:a};
}async function jp(e,t,n,{includePaths:r}={}){
  const o=await t.getWorktreeRepository(e,n);if (!o) {
    return{type:"error",error:{type:"unknown"}};
  }
  const s=await o.getUntrackedPaths(r);
  const i=await WL(e,s,n);
  return i.success?{type:"success",unifiedDiff:i.sections.length>0?i.sections.map(c => I6(c)).join(`
  `):""}:{type:"error",error:i.error};
}function I6(e){return e.replace(/[\r\n]+$/,"");}async function $l(e,t,n){const{success,stdout}=await re(e,["rev-parse","--git-dir"],t,{signal:n});return !success||!stdout?null:ce.isAbsolute(stdout)?stdout:ce.join(e,stdout);}const P6=Pt("git");async function Oh(e,t,n){
  if (!Ue(t)&&!de.existsSync(e)) {
    throw new Error(`ENOENT: path does not exist: ${e}`);
  }const{success,stdout,stderr,code}=await re(e,["rev-parse","--show-toplevel"],t,{allowedNonZeroExitCodes:[128],signal:n});if (success&&stdout) {
    return stdout;
  }if (code===128&&stderr.toLowerCase().includes("not a git repository")) {
    return null;
  }
  P6().debug(`[getGitRoot] failed to resolve git root: ${stderr||stdout||"Unknown error"}`);
  throw new Error(`Failed to resolve git root: ${stderr||stdout||"Unknown error"}`);
}const Q_=Pt("git");async function KL(e,t,n){const r=await $l(e,t,n);if (!r) {
  return{type:"error",error:{type:"unknown"}};
}let o=null;try{
  o=await de.promises.mkdtemp(ce.join(jo.tmpdir(),"codex-git-index"));
  const s=ce.join(r,"index");
  const i=ce.join(o,"index");
  await de.promises.copyFile(s,i).catch(f=>{if (f.code!=="ENOENT") {
    throw f
  }});const a={GIT_INDEX_FILE:i};if (!(await re(e,["add","-u"],t,{env:a,signal:n})).success) {
    Q_().warning("Failed to stage uncommitted diff");
    return {type:"error",error:{type:"unknown"}};
  }const l=await sn(e,["--cached"],t,{trim:false,allowedNonZeroExitCodes:[0,1],env:a,signal:n});return l.outputLimitExceeded||!l.success?(Q_().warning("Failed to collect uncommitted diff"),{type:"error",error:rr(l)}):{type:"success",unifiedDiff:l.stdout}
}catch(s){
  Q_().error(`failed to collect tracked uncommitted diff (${st(s)})`);
  return {type:"error",error:{type:"unknown"}};
}finally{
  if (o) {
    (await de.promises.rm(o,{recursive:true,force:true}));
  }
}}async function M6(e,t,n,r){
  const o=await Oh(e,n,r);
  const [s,i]=await Promise.all([KL(e,n,r),o?jp(o,t,n):Promise.resolve({type:"error",error:{type:"unknown"}})]);
  return s.type!=="success"||i.type!=="success"?{type:"error",error:{type:"unknown"}}:{type:"success",unifiedDiff:v6([s.unifiedDiff,i.unifiedDiff])}
}function v6(e){const t=e.map(r => L6(r)).filter(r => r.length>0);if (t.length===0) {
  return"";
}const n=t.join(`
`);return n.endsWith(`
`)?n:`${n}
`}function L6(e){return e.replace(/[\r\n]+$/,"");}async function Yo(e,t,n){const{success,stdout}=await re(e,["rev-parse","--abbrev-ref","HEAD"],t,{signal:n});if (success&&stdout&&stdout!=="HEAD") {
  return stdout;
}const s=await re(e,["symbolic-ref","--quiet","--short","HEAD"],t,{signal:n});return s.success&&s.stdout?s.stdout:null}async function zL(e,t=Qa,n,r){const o=await re(e,["symbolic-ref","--quiet",`refs/remotes/${t}/HEAD`],n,{signal:r});if(o.success&&o.stdout){const a=o.stdout.split("/");return a[a.length-1]??null}const s=await re(e,["remote","show",t],n,{timeoutMs:10000/* 1e4 */,signal:r});if (!s.success||!s.stdout) {
  return null;
}const i=/HEAD branch:\s*(.+)/.exec(s.stdout);return i?i[1].trim():null}async function ZL(e,t,n,r,o){
  const s=await re(e,["rev-list","--left-right","--count",`${t}...${n}`],r,{allowedNonZeroExitCodes:[128,1],signal:o});if (!s.success||!s.stdout) {
      return null;
    }const i=w6(s.stdout);if (!i) {
      return null;
    }let a="equal";

  if (i.leftAhead>0&&i.rightAhead>0) {
    a="diverged";
  } else if (i.leftAhead>0) {
    a="left-ahead";
  } else if (i.rightAhead>0) {
    (a = "right-ahead");
  }

  return {leftAhead:i.leftAhead,rightAhead:i.rightAhead,state:a};
}function w6(e){
  const t=e.trim();if (!t) {
    return null;
  }const n=t.split(/\s+/);if (n.length<2) {
    return null;
  }
  const r=Number.parseInt(n[0]??"",10);
  const o=Number.parseInt(n[1]??"",10);
  return!Number.isFinite(r)||!Number.isFinite(o)?null:{leftAhead:r,rightAhead:o}
}async function D6(e,t,n,r){const o=await re(e,["rev-parse","--abbrev-ref","--symbolic-full-name",`${t}@{u}`],n,{allowedNonZeroExitCodes:[128,1],signal:r});return o.success&&o.stdout?o.stdout:null}async function U6(e,t,n,r,o){
  const s=async f=>{const d=await D6(e,f,r,o);return d&&(await ZL(e,f,d,r,o))?.state==="right-ahead"?d:f};

  const i=async () => t.type==="branch"?s(t.branchName):(await Yo(e,r,o))??(await zL(e,Qa,r,o))??"HEAD";

  const a=async()=>{if (t.type!=="working-tree") {
    return null;
  }const f=await M6(e,n,r,o);return f.type==="error"?null:f.unifiedDiff};

  const [c,l]=await Promise.all([i(),a()]);
  return{startingRef:c,startingDiff:l}
}function k6(e){return e?.id??"local"}
const pC=Pt("git");
const G6=3;
const EC=new Map;
function V6(e){
  const t=k6(e);
  const n=EC.get(t);
  if (n) {
    return n;
  }const r=new gL.Sema(G6);
  EC.set(t,r);
  return r;
}async function ju(e,t,n=false,r){const o=V6(t);await o.acquire();try{
  const s=["worktree","remove"];

  if (n) {
    s.push("--force");
  }

  s.push(e);

  if (((await re(e,s,t,{signal:r})).success || n)) {
    (await x6(e));
  }
}finally{o.release()}}async function x6(e){try{await de.promises.rm(e,{recursive:true,force:true})}catch(t){pC().warning(`Failed to remove worktree directory (${st(t)})`)}try{
  const t=ce.dirname(e);if (t===e) {
    return;
  }

  if ((await de.promises.readdir(t)).length===0) {
    (await de.promises.rm(t,{recursive:true,force:true}));
  }
}catch(t){pC().warning(`Failed to remove worktree parent directory (${st(t)})`)}}function $6(e,t){return [e,t].filter(r => r.length>0).join(`
`);}function er({command,stdout,stderr,fallbackOutput=stdout||stderr||"An unknown error occurred"}){const o=$6(stdout,stderr)||fallbackOutput;return {command:command,output:o};}async function XL(e,t,n,{preferWslPaths:r=false,convertWindowsPathToWslPath:o=void 0}={}){
  const s=Ue(n);
  const i=s?ce.posix.join(e,"index"):ce.join(e,"index");
  if (s)
    {const c=`cp ${Vt(t)} ${Vt(i)}`;await(await ur({hostConfig:n,args:[`sh -lc ${Vt(c)}`]})).check()} else {
    await de.promises.copyFile(t,i);
  }let a=i;

  if (r&&o) {
    (a = o(i));
  }

  return a;
}async function bh(e,t,n,r){const{success,stdout}=await re(e,["rev-parse","--git-path",t],n,{signal:r});if (!success||!stdout) {
  return null;
}if (ce.isAbsolute(stdout)) {
  return stdout;
}if (stdout.startsWith(".git/")) {
  return ce.join(e,stdout);
}const i=await $l(e,n,r);return i?ce.join(i,stdout):null;}async function Ch(e,t){return bh(e,"index",t)}function qu(e){return e.split(/[/\\]+/).join("/");}function QL(e,t,n){
  const r=B6(t,n);
  const o=H6(e,r);
  return o?qu(o):n
}function B6(e,t){return ce.isAbsolute(t)?t:ce.resolve(e,t)}function H6(e,t){const n=ce.relative(e,t);return n===""||n.startsWith("..")||ce.isAbsolute(n)?null:n}function F6(e,t){
  const n=new Set;
  const r=new Set;
  const o=new Set;
  let s=null;

  const i=[e,t].filter(Boolean).join(`
  `);

  const a=(F,D)=>{
    const k=(D??"").trim();if (!k) {
        return;
      }
    const Y=k.charAt(0);
    const oe=k.charAt(k.length-1);
    let ae=k;

    if ((Y==="'"||Y==='"')&&oe===Y&&k.length>=2) {
      (ae = k.slice(1,-1));
    }

    if (ae) {
      F.add(ae);
    }
  };

  const c=(F,D)=>{for (const k of D) {
    if (F[k]) {
      return F[k]
    }
  }};

  const l=/^(?:Applied patch(?: to)?\s+(?:(["'])(?<qpath>.+?)\1|(?<path>.+?))\s+cleanly\.?)$/i;
  const f=/^(?:Applied patch(?: to)?\s+(?:(["'])(?<qpath>.+?)\1|(?<path>.+?))\s+with conflicts\.?)$/i;
  const d=/^(?:Applying patch\s+(?:(["'])(?<qpath>.+?)\1|(?<path>.+?))\s+with\s+\d+\s+rejects?\.{0,3})$/i;
  const u=/^(?:Checking patch\s+(?:(["'])(?<qpath>.+?)\1|(?<path>.+?))\.\.\.)$/i;
  const _=/^(?:Performing three-way merge|Falling back to three-way merge)\.\.\.$/i;
  const p=/^Failed to perform three-way merge\.\.\.$/i;
  const E=/^Falling back to direct application\.\.\.$/i;
  const h=/^U\s+(?<path>.+)$/;
  const T=/^error:\s+patch failed:\s+(?<path>.+?)(?::\d+)?(?:\s|$)/i;
  const m=/^error:\s+(?<path>.+?):\s+patch does not apply$/i;
  const A=/^(?:error: )?repository lacks the necessary blob to (?:perform|fall back on) 3-?way merge\.?$/i;
  const g=/^error:\s+(?<path>.+?):\s+does not match index\b/i;
  const R=/^error:\s+(?<path>.+?):\s+does not exist in index\b/i;
  const O=/^error:\s+(?<path>.+?)\s+already exists in (?:the )?working directory\b/i;
  const I=/^error:\s+patch failed:\s+(?<path>.+?)\s+File exists/i;
  const b=/^error:\s+path\s+(?<path>.+?)\s+has been renamed\/deleted/i;
  const L=/^error:\s+cannot apply binary patch to\s+['"]?(?<path>.+?)['"]?\s+without full index line$/i;
  const U=/^error:\s+binary patch does not apply to\s+['"]?(?<path>.+?)['"]?$/i;
  const q=/^error:\s+binary patch to\s+['"]?(?<path>.+?)['"]?\s+creates incorrect result\b/i;
  const H=/^error:\s+cannot read the current contents of\s+['"]?(?<path>.+?)['"]?$/i;
  const $=/^Skipped patch\s+['"]?(?<path>.+?)['"]\.$/i;
  const B=/^warning:\s*Cannot merge binary files:\s+(?<path>.+?)\s+\(ours\s+vs\.\s+theirs\)/i;
  for(const F of i.split(/\r?\n/)){const D=F.trim();if (!D) {
    continue;
  }let k;if(k=D.match(l)){
    const Y=c(k.groups??{},["qpath","path"]);
    a(n,Y);
    s=Y??s;
    o.delete(Y??"");
    r.delete(Y??"");
    continue
  }if(k=D.match(f)){
    const Y=c(k.groups??{},["qpath","path"]);
    a(o,Y);
    s=Y??s;
    n.delete(Y??"");
    r.delete(Y??"");
    continue
  }if(k=D.match(d)){
    const Y=c(k.groups??{},["qpath","path"]);
    a(o,Y);
    s=Y??s;
    n.delete(Y??"");
    r.delete(Y??"");
    continue
  }if(k=D.match(h)){
    a(o,k.groups?.path);
    s=k.groups?.path??s;
    n.delete(k.groups?.path??"");
    r.delete(k.groups?.path??"");
    continue
  }if(k=D.match(u)){s=c(k.groups??{},["qpath","path"])??s;continue}if((k=D.match(T))||(k=D.match(m))){
    a(r,k.groups?.path);
    s=k.groups?.path??s;
    continue
  }if(!(_.test(D)||E.test(D))){if(p.test(D)){
    if (s) {
      a(r,s);
      n.delete(s);
      o.delete(s);
    }

    continue
  }if(A.test(D)){
    if (s) {
      a(r,s);
      n.delete(s);
      o.delete(s);
    }

    continue
  }if((k=D.match(g))||(k=D.match(R))||(k=D.match(O))||(k=D.match(I))||(k=D.match(b))||(k=D.match(L))||(k=D.match(U))||(k=D.match(q))||(k=D.match(H))||(k=D.match($))){
    a(r,k.groups?.path);
    s=k.groups?.path??s;
    n.delete(k.groups?.path??"");
    o.delete(k.groups?.path??"");
    continue
  }if(k=D.match(B)){
    a(o,k.groups?.path);
    s=k.groups?.path??s;
    n.delete(k.groups?.path??"");
    r.delete(k.groups?.path??"");
    continue
  }}}for (const F of o) {
    n.delete(F);
    r.delete(F);
  }for (const F of n) {
    r.delete(F);
  }return{appliedPaths:Array.from(n).sort(),skippedPaths:Array.from(r).sort(),conflictedPaths:Array.from(o).sort()}
}function JL(e){
  const t=new Set;
  const n=/^diff --git a\/(.*?) b\/(.*)$/gm;
  let r;

  while ((r=n.exec(e))!=null) {
    const[o,s,i]=r;

    if (s&&s!=="/dev/null") {
      t.add(s);
    }

    if (i&&i!=="/dev/null") {
      t.add(i);
    }
  }

  return Array.from(t)
}async function ew(e,t,n,{preferWslPaths:r=false,convertWindowsPathToWslPath:o,convertWslPathToWindowsPath:s,signal:i}={}){
  const {cwd,env,diff,revert,target="unstaged",allowBinary}=e;
  const _=xl("applyPatch");
  const E=(await t.getWorktreeRepository(cwd,n))?.root;
  if (!E) {
    throw new Error(`${cwd} is not a git repository`);
  }if (i?.aborted) {
      return{status:"error",appliedPaths:[],skippedPaths:[],conflictedPaths:[]};
    }const h=await j6({hostConfig:n,signal:i});let T=fn(n).join(h,"patch.diff");
  await q6(T,diff,{hostConfig:n,signal:i});

  if (r&&o) {
    (T = o(T));
  }

  try{
    let m=env;if(revert&&target==="unstaged"){const U=await Ch(E,n);if (!U) {
        _.warning("[applyPatch] Unable to resolve git index path; applying without temp index");
      } else {
        const q=await XL(h,U,n,{preferWslPaths:r,convertWindowsPathToWslPath:o});
        m={...env,GIT_INDEX_FILE:q};
        await Y6(E,diff,n,{preferWslPaths:r,convertWslPathToWindowsPath:s,env:{...env,GIT_INDEX_FILE:q},signal:i});
      }}const A=["apply"];

    if (revert) {
      A.push("-R");
    }

    if (allowBinary) {
      A.push("--binary");
    }

    A.push("--3way");

    if (target==="staged") {
      A.push("--cached");
    } else if (target==="staged-and-unstaged") {
      A.push("--index");
    }

    A.push(T);
    const {code,stdout,stderr}=await re(E,A,n,{env:m,signal:i,allowedNonZeroExitCodes:[1]});
    const {appliedPaths,skippedPaths,conflictedPaths}=F6(stdout,stderr);
    _.debug("ApplyPatch result metadata",{revert:revert,target:target,code:code,stdoutLength:stdout.length,stderrLength:stderr.length,appliedCount:appliedPaths.length,skippedCount:skippedPaths.length,conflictedCount:conflictedPaths.length});
    return {status:i?.aborted||code==null?"error":code===0?"success":code===1?"partial-success":"error",appliedPaths:appliedPaths,skippedPaths:skippedPaths,conflictedPaths:conflictedPaths,execOutput:er({command:A.join(" "),stdout:stdout,stderr:stderr})};
  }finally{await W6(h,{hostConfig:n})}
}async function Y6(e,t,n,{preferWslPaths,convertWslPathToWindowsPath,env,signal}){
  const a=JL(t);if (a.length===0) {
    return;
  }
  const c=[];
  const l=fn(n);

  await Promise.all(a.map(async f=>{
    const d=QL(e,e,f);let u=l.join(e,d);

    if (preferWslPaths&&convertWslPathToWindowsPath) {
      (u = convertWslPathToWindowsPath(u));
    }

    if ((await K6(u,{hostConfig:n,signal:signal}))) {
      c.push(d);
    }
  }));

  if (c.length!==0) {if (signal?.aborted) {
    throw new Error("Apply patch canceled");
  }await re(e,["--no-optional-locks","add","--",...c],n,{env:env,signal:signal})}
}async function Bl(e,t,{input:n,signal:r,timeoutMs:o=10000/* 1e4 */}={}){
  if (!Ue(e)) {
    throw new Error("runSshCommand requires a remote host config");
  }
  const s=`sh -lc ${Vt(t)}`;
  const [i,...a]=e.terminal_command;
  if (!i) {
    throw new Error("remote host config missing terminal command");
  }
  const c=[...a,"-o","BatchMode=yes","-o","ConnectTimeout=10",s];
  const l=Tc.spawn(i,c,{stdio:["pipe","pipe","pipe"]});

  if (n!=null) {
    l.stdin?.write(n);
  }

  l.stdin?.end();
  let f=false;

  const d=setTimeout(()=>{
    f=true;
    l.kill();
  },o);

  const u=()=>{l.kill()};

  if (r) {
    r.addEventListener("abort",u);
  }

  const _=[];
  const p=[];

  l.stdout?.on("data",m => _.push(m));

  l.stderr?.on("data",m => p.push(m));

  const{code}=await new Promise(m=>{
    l.on("close",A => m({code:A}));

    l.on("error",() => m({code:null}));
  });
  clearTimeout(d);

  if (r) {
    r.removeEventListener("abort",u);
  }

  const h=Buffer.concat(_).toString("utf8");
  const T=Buffer.concat(p).toString("utf8");
  return f?{code:null,stdout:h,stderr:`${T}ssh command timed out`}:{code:code,stdout:h,stderr:T};
}async function j6({hostConfig,signal}){if (!Ue(hostConfig)) {
  return de.promises.mkdtemp(FC.join(jo.tmpdir(),"codex-apply-"));
}const{code,stdout,stderr}=await Bl(hostConfig,'mktemp -d "${TMPDIR:-/tmp}/codex-apply-XXXXXX"',{signal:signal});if (code!==0||!stdout.trim()) {
  throw new Error(`failed to create remote temp dir: ${stderr||stdout}`.trim());
}return stdout.trim();}async function q6(e,t,{hostConfig,signal}){
  if(!Ue(hostConfig)){await de.promises.writeFile(e,t);return}
  const o=`cat > ${Vt(e)}`;
  const {code,stderr}=await Bl(hostConfig,o,{input:t,signal:signal});
  if (code!==0) {
    throw new Error(`failed to write remote file: ${stderr}`)
  }
}async function W6(e,{hostConfig}){if(!Ue(hostConfig)){await de.promises.rm(e,{recursive:true,force:true});return}await Bl(hostConfig,`rm -rf ${Vt(e)}`)}async function K6(e,{hostConfig,signal}){if (!Ue(hostConfig)) {
  try{
    await de.promises.access(e);
    return true;
  }catch{return false;}
}const{code}=await Bl(hostConfig,`test -e ${Vt(e)}`,{signal:signal});return code===0;}const hC=Pt("git");async function z6(e,t,n,r,o,s){try{const i=await Z6(e,t,n,r,o,s);if (!i.success) {
  try{await ju(t,o,true)}catch(a){hC().warning(`Failed to cleanup worktree (${st(a)})`)}
}return i}catch(i){try{await ju(t,o,true)}catch(a){hC().warning(`Failed to cleanup worktree (${st(a)})`)}return {success:false,error:X6(i)};}}async function Z6(e,t,n,r,o,s){
  const i=s?.onLog;
  const a=s?.signal;
  if (a&&a.aborted) {
    return {success:false,error:new Error("Operation canceled")};
  }const{startingRef,startingDiff}=await U6(e,n,r,o,a);if (a&&a.aborted) {
    return {success:false,error:new Error("Operation canceled")};
  }const d=await re(e,["worktree","add","--detach",t,startingRef],o,{onStdoutRaw:i?_ => i("stdout",_):void 0,onStderrRaw:i?_ => i("stderr",_):void 0,signal:a});if (!d.success) {
    return {success:false,error:new Error(`git worktree add failed: ${d.stderr||d.stdout}`)};
  }if (a&&a.aborted) {
    return {success:false,error:new Error("Operation canceled")};
  }const u=await jL(t,o);if (!u.success) {
    return u;
  }if(startingDiff){i?.("info",Un.Buffer.from(`[info] Applying working tree diff to new worktree
  `,"utf8"));const _=await ew({cwd:t,diff:startingDiff,revert:false},r,o,{signal:a});if(_.status!=="success"){
    const p=`git apply failed: applied:${_.appliedPaths.length} skipped:${_.skippedPaths.length} conflicted:${_.conflictedPaths.length}`;

    i?.("info",Un.Buffer.from(`${p}
    `,"utf8"));

    return {success:false,error:new Error(p)};
  }}return {success:true};
}function X6(e){return e instanceof Error?e:new Error(String(e))}function tw(){return ce.join(CQ({}),"worktrees")}const TC=Pt("git");async function Q6(e,t,n,r,o=tw()){
  const i=(await t.getWorktreeRepository(n,r))?.root;if (!i) {
    TC().error("[createWorktreePath] failed to resolve git root for workspace");
    return {success:false};
  }
  let a=ce.join;
  let c=ce.relative;
  let l=o;
  if(Ue(r)){
    const E=await IQ(r);if (!E) {
      TC().error("[createWorktreePath] failed to resolve remote codex home");
      return {success:false};
    }
    a=ce.posix.join;
    c=ce.posix.relative;
    l=a(E,"worktrees");
  }
  const f=tc.randomUUID().split("-")[0].slice(0,4);
  const d=ce.basename(e);
  const u=a(l,f,d);
  const _=c(i,n);
  const p=a(u,_);
  return {success:true,worktreeGitRoot:u,worktreeWorkspaceRoot:p};
}async function nw(e,t,n){const r=await re(e,["remote"],t,{signal:n});if (!r.success||!r.stdout) {
  return[];
}const o=r.stdout.split(`
`).map(s => s.trim()).filter(s => s.length>0);return o.includes(Qa)&&o.length>1?[Qa,...o.filter(s => s!==Qa)]:o;}async function Ja(e,t,n){const r=await nw(e,t,n);if (r.length===0) {
  return null;
}for(const o of r){const s=await zL(e,o,t,n);if (s) {
  return{remote:o,branch:s}
}}return null}async function Ih(e,t,n,r){const o=await re(e,["rev-parse",`${t}^{tree}`],n,{allowedNonZeroExitCodes:[128],signal:r});if (!o.success||!o.stdout) {
  throw new Error(o.stderr||o.stdout||"Failed to resolve tree");
}return o.stdout}const xa=Pt("git");async function J6(e,t,n,r){const o=eJ(t.environment.setup,process.platform);if (!o||o.length===0) {
  return null;
}const s=Date.now();if (r&&r.aborted) {
  return{cwd:e,scriptPath:t.configPath,status:"failed",startedAt:s,finishedAt:Date.now(),error:"Setup script canceled",log:""};
}let i=null;try{
  const a=ce.join(e,t.cwdRelativeToGitRoot);i=await de.promises.mkdtemp(ce.join(jo.tmpdir(),"codex-local-environment-"));
  const c=ce.join(i,`${tc.randomUUID()}-setup_script.sh`);
  const l=ce.join(i,`${tc.randomUUID()}-setup_exit_code.txt`);

  const f=o.replace(/\r\n/g,`
  `);

  await de.promises.writeFile(c,f,{mode:448});
  const d=`bash -xeo pipefail ${JSON.stringify(c)}; echo $? > ${JSON.stringify(l)}`;
  const u=Tc.spawn("bash",["-lc",d],{stdio:["ignore","pipe","pipe"],cwd:a});
  const _=new Array;
  const p=new JS.StringDecoder("utf8");
  const E=new JS.StringDecoder("utf8");
  let h="";
  let T="";

  const m=(b,L,U)=>{
    n?.(U,b);
    const B=((U==="stdout"?h:T)+(U==="stdout"?p:E).write(b)).split(/\r?\n/);
    const F=B.pop()??"";

    if (U==="stdout") {
      h=F;
    } else {
      T=F;
    }

    for (const D of B) {
      if (D) {
        _.push(D);
        L(`[${U}] ${D}`);
      }
    }
  };

  const A=()=>{
    const b=(L,U)=>{
      const $=(L==="stdout"?h:T)+(L==="stdout"?p:E).end();

      if (L==="stdout") {
        h="";
      } else {
        T="";
      }

      for (const B of $.split(/\r?\n/)) {
        if (B) {
          _.push(B);
          U(`[${L}] ${B}`);
        }
      }
    };

    b("stdout",L => xa().info(L));

    b("stderr",L => xa().error(L));
  };

  u.stdout?.on("data",b => m(b,L => xa().info(L),"stdout"));

  u.stderr?.on("data",b => m(b,L => xa().error(L),"stderr"));

  const g=async()=>{try{
    const b=await de.promises.readFile(l,"utf8");
    const L=Number.parseInt(b.trim(),10);
    return Number.isNaN(L)?null:L
  }catch{return null}};

  const R=async()=>{
    if (i!=null) {
      (await de.promises.rm(i,{recursive:true,force:true}));
    }
  };
  let O=false;const I=()=>{
      O=true;
      u.kill();
    };

  if (r) {
    r.addEventListener("abort",I);
  }

  return new Promise(b=>{
    u.once("error",L=>{
      if (r) {
        r.removeEventListener("abort",I);
      }

      (async () => {
        A();
        await R();

        return b({scriptPath:c,cwd:a,status:"failed",startedAt:s,finishedAt:Date.now(),error:L?.message??"Failed to run setup script",log:_.join(`
        `)});
      })();
    });

    u.once("close",L=>{
      if (r) {
        r.removeEventListener("abort",I);
      }

      (async()=>{
        const q=(await g())??L;
        A();
        await R();
        let H;
        let $;

        if (O) {
          H="failed";
          $="Setup script canceled";
        } else if (q===0) {
          H="succeeded";
        } else {
          H="failed";
          $=`worktree_init.sh exited with code ${q??"unknown"}`;
        }

        b({scriptPath:c,cwd:a,status:H,startedAt:s,finishedAt:Date.now(),error:$,log:_.join(`
        `)});
      })();
    });
  });
}catch(a){
  if (i!=null) {
    (await de.promises.rm(i,{recursive:true,force:true}));
  }

  xa().warning(`[local-environment] setup script failed (${st(a)})`);
  return {cwd:e,scriptPath:t.configPath,status:"failed",startedAt:s,finishedAt:Date.now(),error:String(a),log:""};
}}function eJ(e,t){if(t==="darwin"){const n=e.darwin?.script;if (n&&n.length>0) {
  return n
}}if(t==="linux"){const n=e.linux?.script;if (n&&n.length>0) {
  return n
}}if(t==="win32"){const n=e.win32?.script;if (n&&n.length>0) {
  return n
}}return e.script}async function rw(e,t,n,r,o,s){
  const a=["config",r==="local"?"--local":"--worktree",t,n];
  const c=await re(e,a,o,{signal:s});
  return c.success||r!=="worktree"?c.success:!c.stderr.toLowerCase().includes("worktreeconfig")||!(await re(e,["config","extensions.worktreeConfig","true"],o,{signal:s})).success?false:(await re(e,a,o,{signal:s})).success;
}async function tJ(e,t,n,r="worktree",o){return rw(e,L9,t,r,n,o)}
const SC=Pt("syncedBranchConfig");
const ow="codex-synced-branch.json";
const nJ=ar({branch:dt(),lastSyncedTreeRef:dt()});
async function sw(e,t,n){const r=await $l(e,t,n);return r?ce.join(r,ow):null}function rJ(e){try{const t=nJ.safeParse(JSON.parse(e));return t.success?t.data:(SC().warning(`Invalid synced branch config: ${t.error.message??"unknown error"}`),null)}catch(t){
  SC().warning(`Failed to parse synced branch config (${st(t)})`);
  return null;
}}async function Hl(e,t,n){const r=await sw(e,t,n);if (!r) {
  return null;
}try{const o=await lr.readFile(r,t);return rJ(o)}catch(o){
  o.code==="ENOENT";
  return null;
}}async function oJ(e,t,n,r){const o=await sw(e,n,r);if (!o) {
  throw new Error("No git repository found for synced branch config");
}const s=`${JSON.stringify(t,null,2)}
`;await lr.writeFile(o,s,n)}async function sJ(e,t,n,r,o){await oJ(e,{branch:t,lastSyncedTreeRef:n},r,o)}async function iJ(e,t,n){return bh(e,ow,t,n)}function aJ(e){return e.startsWith("refs/")?e:`refs/heads/${e}`}async function cJ({gitManager,workspaceRoot,startingState,localEnvironmentConfigPath,hostConfig,signal,onLog}){
  if (signal?.aborted) {
    return {success:false,error:new Error("Request canceled")};
  }const c=(await gitManager.getWorktreeRepository(workspaceRoot,hostConfig))?.root;if (!c) {
      return {success:false,error:new Error("Not a git repository")};
    }if (signal?.aborted) {
      return {success:false,error:new Error("Request canceled")};
    }
  const [l,f]=await Promise.all([uJ(c,startingState,hostConfig,signal),Ja(c,hostConfig,signal)]);
  const d=f?.branch??null;
  const u=l!=null&&l!==d;
  const _=await Q6(c,gitManager,workspaceRoot,hostConfig);
  if (!_.success) {
    return {success:false,error:new Error("Failed to compute worktree path")};
  }if (signal?.aborted) {
      return {success:false,error:new Error("Request canceled")};
    }
  const {worktreeGitRoot,worktreeWorkspaceRoot}=_;
  const h=await z6(c,worktreeGitRoot,startingState,gitManager,hostConfig,{onLog:onLog,signal:signal});
  if (!h.success) {
    return {success:false,error:h.error};
  }if (signal?.aborted) {
      return {success:false,error:new Error("Request canceled")};
    }if(u&&l){
      const R=aJ(l);
      const O=await Ih(c,R,hostConfig,signal);
      await sJ(worktreeGitRoot,R,O,hostConfig,signal)
    }

  onLog?.("info",Un.Buffer.from(`Worktree created at ${worktreeWorkspaceRoot}
  `,"utf8"));

  if (!(await tJ(worktreeWorkspaceRoot,localEnvironmentConfigPath??w9,hostConfig,"worktree",signal))) {
    onLog?.("stderr",Un.Buffer.from(`Failed to store selected environment in git config
    `,"utf8"));
  }

  if (localEnvironmentConfigPath==null) {
    onLog?.("info",Un.Buffer.from(`No local environment selected
    `,"utf8"));

    return {success:true,worktreeGitRoot:worktreeGitRoot,worktreeWorkspaceRoot:worktreeWorkspaceRoot,setupResult:null};
  }

  const A=await f6(localEnvironmentConfigPath,hostConfig);if (A.type==="error") {
      onLog?.("stderr",Un.Buffer.from(`${A.error.message}
      `,"utf8"));

      return {success:false,error:A.error};
    }onLog?.("info",Un.Buffer.from(`Running setup script ${A.configPath}
    `,"utf8"));const g=await J6(worktreeGitRoot,A,(R,O)=>{onLog?.(R,O)},signal);

  if (signal?.aborted) {
    return {success:false,error:new Error("Request canceled")};
  }

  if (g?.status==="failed") {
    onLog?.("stderr",Un.Buffer.from(`${g.error??"Setup script failed"}
      `,"utf8"));

    return {success:false,error:new Error(g.error??"Setup script failed")};
  }

  g?.status==="succeeded"&&onLog?.("info",Un.Buffer.from(`Setup script completed
    `,"utf8"));

  return {success:true,worktreeGitRoot:worktreeGitRoot,worktreeWorkspaceRoot:worktreeWorkspaceRoot,setupResult:g??null};
}async function uJ(e,t,n,r){return t.type==="branch"?t.branchName:Yo(e,n,r)}async function lJ(e,t,n){if (!Ue(t)&&!de.existsSync(e)) {
  throw new Error(`ENOENT: path does not exist: ${e}`);
}const{success,stdout,stderr,code}=await re(e,["rev-parse","--git-common-dir"],t,{signal:n});if(success&&stdout){
  const a=fn(t);
  const c=a.isAbsolute(stdout)?stdout:a.resolve(e,stdout);
  return c
}if (code===128&&stderr.toLowerCase().includes("not a git repository")) {
  return null;
}throw new Error(`Failed to resolve git common dir: ${stderr||stdout||"Unknown error"}`)}async function dJ(e,t,n){
  const r=await re(e,["status","--porcelain=v1","-z"],t,{trim:false,signal:n});if (!r.success) {
      return{type:"error"};
    }
  let o=0;
  let s=0;
  let i=0;
  const a=r.stdout;let c=0;

  while (c<a.length&&!(c+1>=a.length)) {
    const l=a[c];
    const f=a[c+1];

    if (l==="?"&&f==="?") {
      i+=1;
    } else {
      l!==" "&&(o+=1);
      f!==" "&&(s+=1);
    }

    const d=a.indexOf("\0",c);if (d===-1) {
          break;
        }
    c=d+1;

    if (l==="R"||l==="C"||f==="R"||f==="C") {const u=a.indexOf("\0",c);if (u===-1) {
      break;
    }c=u+1}
  }

  return{type:"success",stagedCount:o,unstagedCount:s,untrackedCount:i}
}async function iw(e,t,n,r){
  const o=t.trim();if (!o) {
    return null;
  }

  const s=async h => (await re(e,["rev-parse","--verify","--quiet",h],n,{signal:r})).success;

  const i=[];
  const a=new Set;
  const c=async h=>{
    const T=h?.trim();

    if (T && !a.has(T)) {
      if ((await s(T))) {
        i.push(T);
        a.add(T);
      }
    }
  };
  const l=await re(e,["for-each-ref","--format=%(upstream:short)",`refs/heads/${o}`],n,{signal:r});
  const f=l.success?l.stdout.trim():null;
  await c(f);
  await c(o);
  const d=await re(e,["remote"],n,{signal:r});if(d.success&&d.stdout){
    const h=d.stdout.split(`
    `).map(I => I.trim()).filter(I => I.length>0);

    const T=new Set(h);
    const m=o.indexOf("/");
    const A=m>0?o.slice(0,m):null;
    const g=A!=null&&T.has(A);
    const R=g&&m+1<o.length?o.slice(m+1):null;
    const O=[];
    for(const I of h){if(g&&I===A){
      if (R) {
        O.push(c(`refs/remotes/${I}/${R}`));
      }

      continue
    }O.push(c(`${I}/${o}`),c(`refs/remotes/${I}/${o}`))}await Promise.all(O)
  }const u=i[0];if (!u) {
    return null;
  }const{success,stdout}=await re(e,["merge-base","HEAD",u],n,{signal:r});if (!success||!stdout) {
    return null;
  }const E=stdout.trim();return E.length>0?E:null
}async function fJ(e,t,n){const r=await sn(e,[],t,{trim:false,allowedNonZeroExitCodes:[0,1],signal:n});return r.outputLimitExceeded||!r.success?{type:"error",error:rr(r)}:{type:"success",unifiedDiff:r.stdout}}function aw(e,t,n){const r=qu(ce.relative(e,t));return n.map(o=>{
  const s=qu(o);
  const a=r.length>0&&(s===r||s.startsWith(`${r}/`))?e:t;
  return QL(e,a,o)
});}async function _J(e,t,n,r,o){
  const s=await t.getWorktreeRepository(e,n);
  const i=s?.root;
  if (!i) {
    return{stagedChanges:{type:"error",error:{type:"unknown"}},unstagedChanges:{type:"error",error:{type:"unknown"}}};
  }const a=o==null?null:aw(i,e,o);if(a!=null){
    if (a.length===0) {
      return{stagedChanges:{type:"success",unifiedDiff:""},unstagedChanges:{type:"success",unifiedDiff:""}};
    }
    const f=await s.getUntrackedPaths(a);
    const d=new Set(f.paths);

    const u=f.success?a.filter(E => !d.has(E)):a;

    if (u.length===0) {
      return{stagedChanges:{type:"success",unifiedDiff:""},unstagedChanges:{type:"success",unifiedDiff:""}};
    }const[_,p]=await Promise.all([sn(i,["--cached","--",...u],n,{trim:false,allowedNonZeroExitCodes:[0,1],signal:r}),sn(i,["--",...u],n,{trim:false,allowedNonZeroExitCodes:[0,1],signal:r})]);return{stagedChanges:J_(_),unstagedChanges:J_(p)}
  }const[c,l]=await Promise.all([sn(i,["--cached"],n,{trim:false,allowedNonZeroExitCodes:[0,1],signal:r}),fJ(i,n,r)]);return{stagedChanges:J_(c),unstagedChanges:l}
}function J_(e){return e.outputLimitExceeded||!e.success?{type:"error",error:rr(e)}:{type:"success",unifiedDiff:e.stdout}}async function pJ(e,t,n,r,o){
  const s=await Oh(e,n,r);if (!s) {
    return{untrackedChanges:{type:"error",error:{type:"unknown"}}};
  }const i=o==null?null:aw(s,e,o);

  if (i!=null&&i.length===0) {
    return {untrackedChanges:{type:"success",unifiedDiff:""}};
  }

  if (i==null) {
    return {untrackedChanges:await jp(s,t,n)};
  }

  return {untrackedChanges:await jp(s,t,n,{includePaths:i})};
}async function cw(e,t,n){const r=await re(e,["worktree","list","--porcelain"],t,{signal:n});if (!r.success) {
  throw new Error(r.stderr||r.stdout||"Failed to list worktrees for repository");
}return EJ(r.stdout??"")}function EJ(e){
  const t=[];let n=null;const r=e.split(/\r?\n/);for(const o of r){const s=o.trim();if(s.length===0){
    if (n) {
      t.push(n);
      n=null;
    }

    continue
  }if(s.startsWith("worktree ")){
    if (n) {
      t.push(n);
    }

    const i=s.slice(9).trim();if(!i){n=null;continue}n={root:i,prunable:false,locked:false,headRef:{sha:"",type:"detached"}};continue
  }if(n){
    if(s.startsWith("HEAD ")){const i=s.slice(5).trim();n.headRef={sha:i,type:"detached"};continue}if(s.startsWith("branch ")){
      const i=s.slice(7).trim();

      if (i.startsWith("refs/heads/")) {
        n.headRef={sha:n.headRef.sha,type:"branch",string:i.slice(11)};
      } else {
        n.headRef={sha:n.headRef.sha,type:"branch",string:i};
      }

      continue
    }if(s==="detached"){n.headRef={sha:n.headRef.sha,type:"detached"};continue}if(s.startsWith("prunable")){n.prunable=true;continue}

    if (s.startsWith("locked")) {
      (n.locked = true);
    }
  }}

  if (n) {
    t.push(n);
  }

  return t;
}async function hJ({cwd},t,n){
  const r=String(cwd).trim();if (!r) {
    throw new Error("Workspace root is required");
  }const o=await re(r,["init"],n);if (!o.success) {
    throw new Error(o.stderr||o.stdout||"Failed to run git init");
  }
  t.invalidateStableMetadata();
  return {success:true};
}async function uw(e,t,n,r){const o=await re(e,["config","--get",...t],n,{signal:r});return o.success&&o.stdout?o.stdout:null}async function TJ(e,t,n,r,o){const a=await re(e,["config",n==="local"?"--local":"--worktree","--get",t],r,{signal:o});return a.success&&a.stdout?a.stdout:null}async function mC(e,t,{includePaths:n,signal:r}={}){
  const o=["ls-files","--others","--exclude-standard","-z"];

  if (n&&n.length>0) {
    o.push("--",...n);
  }

  const s=await re(e,o,t,{trim:false,signal:r});return s.success?{success:true,paths:s.stdout.split("\0").map(a => a.trim()).filter(a => a.length>0)??[],gitRoot:e}:{success:false,paths:[],gitRoot:e};
}class SJ{constructor(t,n){
  this.root=t;
  this.hostConfig=n;
}shouldUseSlowUntrackedPathsCache=false;async getConfigValue(t,n){return uw(this.root,[t],this.hostConfig,n)}async getConfigValueForScope(t,n,r){return TJ(this.root,t,n,this.hostConfig,r)}async setConfigValueForScope(t,n,r,o){return rw(this.root,t,n,r,this.hostConfig,o)}getUntrackedPaths=Object.assign(async t => t!=null&&t.length>0?mC(this.root,this.hostConfig,{includePaths:t}):this.shouldUseSlowUntrackedPathsCache?this.getAllUntrackedPathsSlow():this.getAllUntrackedPathsFast(),{clear:()=>{
  this.shouldUseSlowUntrackedPathsCache=false;
  this.getAllUntrackedPathsFast.clear();
  this.getAllUntrackedPathsSlow.clear();
},delete:t=>{
  if (t == null || t.length <= 0) {
    this.getAllUntrackedPathsFast.delete();
    this.getAllUntrackedPathsSlow.delete();
  }
}});fetchAllUntrackedPaths=async()=>{
  const t=Date.now();
  const n=await mC(this.root,this.hostConfig);
  const r=Date.now()-t;
  this.shouldUseSlowUntrackedPathsCache=r>=7000/* 7e3 */;
  return n;
};getAllUntrackedPathsFast=dc(async () => this.fetchAllUntrackedPaths(),{promise:true,maxAge:10000/* 1e4 */});getAllUntrackedPathsSlow=dc(async () => this.fetchAllUntrackedPaths(),{promise:true,maxAge:20000/* 2e4 */})}class mJ{constructor(t,n){
  this.commonDir=t;
  this.hostConfig=n;
}worktreesByRoot=new Map;getCommonDir(){return this.commonDir}getRepository(t){
  const n=this.worktreesByRoot.get(t);if (n) {
    return n;
  }const r=new SJ(t,this.hostConfig);
  this.worktreesByRoot.set(t,r);
  return r;
}invalidateUntrackedPathsCache(){for (const t of this.worktreesByRoot.values()) {
  t.getUntrackedPaths.clear()
}}getOriginUrl=dc(async t => await uw(this.commonDir,["remote.origin.url"],this.hostConfig,t),{length:0,promise:true,maxAge:Th})}function ep(e){return e?.id??"local"}class AJ{reposByKey=new Map;hasBackgroundedSinceLastForeground=false;constructor(t){t.subscribe(n=>{this.handleAppEvent(n)})}async getRepoRepository(t,n){const r=await this.getStableMetadata(t,n);return r?this.getOrCreateRepo(r.commonDir,n):null}async getWorktreeRepository(t,n){const[r,o]=await Promise.all([this.getRepoRepository(t,n),this.getStableMetadata(t,n)]);return!r||!o?null:r.getRepository(o.root)}getRepoKey(t,n){return`${ep(n)}|${t}`}getOrCreateRepo(t,n){
  const r=this.getRepoKey(t,n);
  const o=this.reposByKey.get(r);
  if (o) {
    return o;
  }const s=new mJ(t,n);
  this.reposByKey.set(r,s);
  return s;
}invalidateStableMetadata(){this.getStableMetadata.clear()}invalidateUntrackedPathsCache(t=null,n=null){if(t==null){for (const o of this.reposByKey.values()) {
  o.invalidateUntrackedPathsCache();
}return}const r=ep(n);for (const[o,s] of this.reposByKey) {
  if (o.startsWith(`${r}|`)) {
    s.invalidateUntrackedPathsCache();
  }
}}getStableMetadata=dc(async(t,n)=>{const r=await Oh(t,n);if (!r) {
  return null;
}const o=await lJ(r,n);return o?{root:r,commonDir:o}:null},{promise:true,maxAge:Th,normalizer:([t,n]) => `${ep(n)}|${t}`});handleAppEvent(t){switch(t.type){case "background":
  {
    this.hasBackgroundedSinceLastForeground=true;break;
  }case "foreground":
  {
    if (this.hasBackgroundedSinceLastForeground) {
      this.invalidateUntrackedPathsCache(null);
    }

    this.hasBackgroundedSinceLastForeground=false;
    break;
  }case "turnComplete":
  {
    this.invalidateUntrackedPathsCache(null);break
  }}}}async function gJ(e,t){const n=[];for (const r of e) {
  if (r) {
    try{
      if ((await lr.stat(r,t)).isDirectory()) {
        n.push(r);
      }
    }catch{continue}
  }
}return n}async function qp(e,t,n,{parentSha:r,message:o="Codex changes",coAuthor:s="Codex",signal:i}={}){
  const a=["commit-tree",t];

  if (r) {
    a.push("-p",r);
  }

  a.push("-m",o);

  if (s) {
    a.push("-m",`Co-authored-by: ${s}`);
  }

  const c=await re(e,a,n,{signal:i});return !c.success||!c.stdout?{success:false,error:c}:{success:true,commitSha:c.stdout};
}const AC=1024;async function lw({gitRoot,env,signal,hostConfig,untrackedPathsPromise}){if (!untrackedPathsPromise) {
  return re(gitRoot,["add","-A"],hostConfig,{env:env,signal:signal});
}const s=await untrackedPathsPromise;if (!s.success) {
  return re(gitRoot,["add","-A"],hostConfig,{env:env,signal:signal});
}const i=await re(gitRoot,["add","-u"],hostConfig,{env:env,signal:signal});if (!i.success||s.paths.length===0) {
  return i;
}for (const a of RJ(s.paths)) {
  if (!(await re(gitRoot,["add","--",...a],hostConfig,{env:env,signal:signal})).success) {
    return re(gitRoot,["add","-A"],hostConfig,{env:env,signal:signal});
  }
}return i}function RJ(e){const t=[];for (let n=0; n<e.length; n+=AC) {
  t.push(e.slice(n,n+AC));
}return t}const NJ="GIT_INDEX_FILE";async function dw(e,t,n){const r=await yJ(n);try{
  const o=await XL(r,e,n);
  const s={[NJ]:o};
  return await t(s)
}finally{await OJ(r,n)}}async function yJ(e){
  if (!Ue(e)) {
    return de.promises.mkdtemp(ce.join(jo.tmpdir(),"codex-index-"));
  }
  const t=await ur({hostConfig:e,args:["sh","-lc",'mktemp -d "${TMPDIR:-/tmp}/codex-index-XXXXXX"'],timeoutMs:10000/* 1e4 */});
  const {code,stdout,stderr}=await t.wait();
  if(code!==0||!stdout.trim()){const s=code==null?`${stderr}ssh command timed out`:stderr||stdout;throw new Error(`failed to create remote temp dir: ${s}`.trim())}return stdout.trim();
}async function OJ(e,t){if(!Ue(t)){await de.promises.rm(e,{recursive:true,force:true});return}await(await ur({hostConfig:t,args:["sh","-lc",`rm -rf ${Vt(e)}`],timeoutMs:10000/* 1e4 */})).wait()}async function Zr(e,t){
  const n=t.hostConfig;
  const r=await Ch(e,n);
  if (!r) {
    throw new Error("Failed to resolve git index path");
  }return dw(r,async o=>{
    const s=await lw({gitRoot:e,env:o,signal:t.signal,hostConfig:n,untrackedPathsPromise:t.untrackedPathsPromise});if (!s.success) {
      throw new Error(s.stderr||s.stdout||"Failed to stage working tree snapshot");
    }
    const i=await re(e,["write-tree"],n,{env:o,signal:t.signal});
    const a=i.success?i.stdout.trim():null;
    if (a) {if (!Oc(a)) {
      throw new Error(`Unexpected tree SHA: ${a}`)
    }} else {
      throw new Error("Failed to write working tree snapshot");
    }return a
  },n);
}function Oc(e){return /^[0-9a-f]{7,40}$/i.test(e);}const bJ="refs/codex/snapshots";async function CJ(e,t,n,r,o){
  const s=await e.getStableMetadata(t,n);if (!s) {
    throw new Error(`Not in a git repository: ${t}`);
  }
  const i=Mh(s.root);
  const a=Ph(i);
  const c=await e.getWorktreeRepository(t,n);
  if (!c) {
    throw new Error("Unable to resolve worktree repository for snapshot.");
  }
  const l=c.getUntrackedPaths();
  const f=await Zr(s.root,{hostConfig:n,signal:o,untrackedPathsPromise:l});
  const d=await re(s.root,["rev-parse","HEAD"],n,{allowedNonZeroExitCodes:[128],signal:o});
  const u=d.success&&d.stdout?d.stdout.trim():null;
  let _=u;if(u){if((await Ih(s.root,u,n,o)).trim()!==f){const h=await qp(s.root,f,n,{parentSha:u,message:gC(r),signal:o});if (!h.success) {
    throw new Error("Failed to create synthetic commit");
  }_=h.commitSha.trim()}}else{const E=await qp(s.root,f,n,{message:gC(r),signal:o});if (!E.success) {
    throw new Error("Failed to create synthetic commit");
  }_=E.commitSha.trim()}if (!_) {
    throw new Error("Failed to compute snapshot commit");
  }if (!(await re(s.root,["update-ref",a,_],n,{env:{GIT_TERMINAL_PROMPT:"0"},signal:o})).success) {
    throw new Error("Failed to update ref");
  }return{snapshotRef:a,worktreeId:i,repoRoot:s.root,commonDir:s.commonDir,commitSha:_}
}async function IJ(e,t,n,r,o){
  const s=n;
  const i=Mh(s);
  const a=Ph(i);
  const c=await gJ(t,r);
  if (c.length===0) {
    throw new Error("No candidate workspace roots exist on disk");
  }const l=(await Promise.all(c.map(async d=>{try{return await e.getStableMetadata(d,r)}catch{return null}}))).filter(d => !!d);if (l.length===0) {
    throw new Error("No candidate workspace roots are valid git repositories");
  }const f=await Promise.all(l.map(async d=>{const u=await re(d.root,["show-ref","--verify","--hash",a],r,{allowedNonZeroExitCodes:[128,1],env:{GIT_TERMINAL_PROMPT:"0"},signal:o});return{metadata:d,showRefResult:u}}));for (const{metadata,showRefResult} of f) {
    if(!(showRefResult.code===128||showRefResult.code===1)){if (!showRefResult.success||!showRefResult.stdout) {
      throw new Error(showRefResult.stderr||showRefResult.stdout||"Failed to resolve snapshot ref");
    }return {snapshotRef:a,worktreeId:i,repoRoot:metadata.root,commonDir:metadata.commonDir,exists:true,commitSha:showRefResult.stdout.trim()};}
  }return {snapshotRef:a,worktreeId:i,exists:false,commitSha:null};
}async function PJ(e,t,n,r){
  const o=Mh(t);
  const s=Ph(o);
  const i=await re(e,["worktree","add","--detach",t,s],n,{env:{GIT_TERMINAL_PROMPT:"0"},signal:r});
  if (!i.success) {
    throw new Error(i.stderr||i.stdout||"Failed to restore worktree");
  }const a=await jL(t,n);if(!a.success){try{await ju(t,n,true)}catch{await de.promises.rm(t,{recursive:true,force:true})}throw new Error(a.error.message)}return true;
}function Ph(e){return`${bJ}/${e}`}function Mh(e){return tc.createHash("sha1").update(e).digest("hex")}function gC(e){return`Codex worktree snapshot: ${e}`}const MJ=ar({state:dt().optional(),number:Za().optional(),url:dt().optional()});kl(MJ);qo.promisify(Tc.execFile);const RC={error:0,warning:1,info:2,debug:3,trace:4};function vJ(e,t){return RC[e]<=RC[t]}qo.promisify(Tc.execFile);ar({title:dt(),body:dt()});async function LJ({root,diff,gitManager,hostConfig,signal,logger}){const i=await Ch(root,hostConfig);return i?dw(i,a => NC(root,diff,gitManager,hostConfig,signal,logger,a),hostConfig):(logger&&logger.warning("Unable to resolve git index path; applying without temp index"),NC(root,diff,gitManager,hostConfig,signal,logger));}async function NC(e,t,n,r,o,s,i){
  if (!(await wJ(e,t,r,o,i)).success) {
    if (s) {
      s.error("Failed to stage target worktree changes");
    }
  }

  return ew({cwd:e,diff:t,allowBinary:true,revert:false,env:i},n,r,{signal:o});
}async function wJ(e,t,n,r,o){const s=JL(t);if (s.length===0) {
  return {success:true,command:"git add",stdout:"",stderr:""};
}const i=await DJ(e,s,n);return i.length===0?{success:true,command:"git add",stdout:"",stderr:""}:re(e,["add","--",...i],n,{env:o,signal:r});}async function DJ(e,t,n){
  const r=fn(n);
  const o=[];

  await Promise.all(t.map(async s=>{const i=r.join(e,s);try{
    await lr.stat(i,n);
    o.push(s);
  }catch{return}}));

  return o;
}async function UJ({sourceHeadRef,sourceTreeRef,destinationRoot,destinationHeadRef,gitManager,hostConfig,signal}){
  const a=AL("applyChanges");
  const c=await kJ(destinationRoot,sourceHeadRef,destinationHeadRef,hostConfig,signal);
  if (!c) {
    return{status:"command-error"};
  }const l=await sn(destinationRoot,[c,sourceTreeRef],hostConfig,{binary:true,trim:false,allowedNonZeroExitCodes:[0,1],signal:signal});if (l.outputLimitExceeded||!l.success) {
      return{status:"command-error",execOutput:er(l)};
    }const f=l.stdout;if (!f) {
      return{status:"success"};
    }const d=await LJ({root:destinationRoot,diff:f,gitManager:gitManager,hostConfig:hostConfig,signal:signal,logger:a});

  if (d.status==="error") {
    return {status:"command-error",execOutput:d.execOutput};
  }

  if (d.status==="partial-success") {
    return {status:"partial-success",appliedPaths:d.appliedPaths,skippedPaths:d.skippedPaths,conflictedPaths:d.conflictedPaths};
  }

  return {status:"success"};
}async function kJ(e,t,n,r,o){const s=await re(e,["merge-base",t,n],r,{allowedNonZeroExitCodes:[1],signal:o});if (!s.success||!s.stdout) {
  return null;
}const i=s.stdout.trim();return i?i:null}function GJ(...e){const t=[];let n=0;const r=o=>{
  const s=o.trim();if (s.length===0) {
    return true;
  }

  const i=t.length>0?`
  `:"";

  const a=Buffer.byteLength(`${i}${s}`,"utf8");
  return n+a>on?false:(n+=a,t.push(s),true);
};for (const o of e) {
  for (const s of o) {
    if (!r(s)) {
      return{type:"error",error:{type:"diff-too-large",limitBytes:on}};
    }
  }
}return{type:"success",sections:t}}async function VJ(e,t,n,r,o,s){if (!n||n.trim().length===0) {
  return{type:"error",error:{type:"unknown"}};
}const i=await sn(t,[n],o,{trim:false,allowedNonZeroExitCodes:[0,1],signal:s});if (i.outputLimitExceeded||!i.success) {
  return{type:"error",error:rr(i)};
}if (!r.success) {
  return{type:"error",error:{type:"unknown"}};
}const a=await WL(e,r,o,s);if (!a.success) {
  return{type:"error",error:a.error};
}const c=GJ([i.stdout],a.sections);return c.type==="error"?{type:"error",error:c.error}:{type:"success",unifiedDiff:c.sections.join(`
`)}}function pc(e){return e.startsWith("refs/heads/")?e.slice(11):e}async function xJ(e,t,n,r){
  const o=await e.getWorktreeRepository(t,n);
  const s=o?.root;
  if (!s) {
    return{gitRoot:null,branch:null,baseBranch:null,baseBranchRemote:null,branchChanges:{type:"error",error:{type:"unknown"}}};
  }const[i,a]=await Promise.all([Yo(s,n,r),Ja(s,n,r)]);let c=i;if(!c){const h=await Hl(t,n,r);c=h?pc(h.branch):null}if (!a) {
    return{gitRoot:s,branch:c,baseBranch:null,baseBranchRemote:null,branchChanges:{type:"error",error:{type:"unknown"}}};
  }
  const {branch,remote}=a;
  const d=branch;
  const u=d.includes("/")?d:`${remote}/${d}`;
  const _=await iw(s,u,n,r);
  if (!_) {
    return {gitRoot:s,branch:c,baseBranch:d,baseBranchRemote:remote,branchChanges:{type:"error",error:{type:"unknown"}}};
  }
  const p=await o.getUntrackedPaths();
  const E=await VJ(s,t,_,p,n,r);
  return {gitRoot:s,branch:c,baseBranch:d,baseBranchRemote:remote,branchChanges:E};
}
const $J=/^\d{6}-\d{4}-[0-9a-f]{8}$/i;
const BJ=/^[0-9a-f]{4}$/i;
async function HJ(){
  const e=tw();let t=[];try{t=await de.promises.readdir(e,{withFileTypes:true})}catch{return[]}

  const n=t.filter(i => i.isDirectory());

  const r=await Promise.all(n.map(async i=>{const a=ce.join(e,i.name);try{const c=await de.promises.readdir(a,{withFileTypes:true});return{parentName:i.name,parentPath:a,worktreeEntries:c}}catch{return null}}));
  const o=[];
  for(const i of r){if (!i) {
    continue;
  }const a=BJ.test(i.parentName);for(const c of i.worktreeEntries){
    if (!c.isDirectory()||!a&&!$J.test(c.name)) {
      continue;
    }
    const l=ce.join(i.parentPath,c.name);
    const f=l;

    if (f) {
      o.push(YL(l).then(async d => (await R6(l,d))?{dir:f,gitDir:d}:null));
    }
  }}return (await Promise.all(o)).filter(i => i!=null);
}const FJ=Pt("git");async function YJ(e,t,n){const r=await $l(e,t,n);if (!r) {
  return{lastModified:0};
}const o=ce.join(r,"index");try{return{lastModified:(await de.promises.stat(o)).mtimeMs}}catch(s){return s.code==="ENOENT"?{lastModified:0}:(FJ().error(`Failed to read index info for ${o}: ${String(s)}`),{lastModified:0})}}async function yC(e,t,n,r){const{success,stdout}=await re(e,["for-each-ref",`--count=${t}`,"--sort=-committerdate","refs/heads","--format=%(refname:short)"],n,{signal:r});return !success||!stdout?[]:stdout.split(`
`).map(i => i.trim()).filter(i => i.length>0);}async function jJ(e,t,n){const r=await re(e,["config","--file",".gitmodules","--get-regexp","path"],t,{allowedNonZeroExitCodes:[1],signal:n});if (!r.success||!r.stdout) {
  return[];
}const o=r.stdout.split(`
`).map(s => s.trim()).filter(s => s.length>0).map(s=>{
  const i=s.split(/\s+/);
  const a=i[i.length-1]??"";
  return qu(a)
}).filter(s => s.length>0);return Array.from(new Set(o))}async function qJ(e,t,n){return{trackedChanges:await KL(e,t,n)}}
const WJ=new RegExp("(?<=\\n)");
const KJ=/^0+$/;
const Wu=30000/* 3e4 */;
async function zJ(e,{cwd,oid,path,fallbackToDisk},s,i){const a=Ue(s);try{
  const c=await e.getStableMetadata(cwd,s);if (!c) {
    return{type:"error",error:{type:"unknown"}};
  }
  const l=String(c.root);
  const d=fn(s).join(l,path);
  if (!ZJ(oid)) {
    return fallbackToDisk?bC(d,s):{type:"error",error:{type:"not-found"}};
  }const u=await QJ(l,oid,s,i,a);return u.type==="success"?u:fallbackToDisk&&u.error.type==="not-found"?bC(d,s):u;
}catch(c){return c.code==="ENOENT"?{type:"error",error:{type:"not-found"}}:{type:"error",error:{type:"unknown"}}}}function fw(e){return e.includes("No such file")||e.includes("cannot open")||e.includes("not found")}function Wp(e){const t=e.split(WJ);return t.length===1&&t[0]===""?[]:(t.at(-1)===""&&t.pop(),t)}function ZJ(e){return e?!KJ.test(e):false;}function OC(e){return e.code===128?"not-found":"unknown"}async function XJ(e,t){if(Ue(t)){
  const{stdout,stderr,code}=await ur({hostConfig:t,args:["wc","-c",e],timeoutMs:Wu}).then(c => c.wait());if(code!==0){if(fw(stderr)){
    const c=new Error(`File not found: ${e}`);
    c.code="ENOENT";
    throw c;
  }throw new Error(`Failed to stat remote file: ${e}`)}
  const i=stdout.trim().split(/\s+/)[0];
  const a=Number.parseInt(i??"",10);
  if (Number.isNaN(a)) {
    throw new Error(`Failed to parse file size for ${e}`);
  }return a
}return(await VC.stat(e)).size}async function bC(e,t){if ((await XJ(e,t))>on) {
  return{type:"error",error:{type:"too-large",limitBytes:on}};
}if(Ue(t)){
  const{stdout,stderr,code}=await ur({hostConfig:t,args:["cat",e],timeoutMs:Wu}).then(a => a.wait());

  if (code!==0) {
    if (fw(stderr)) {
      return {type:"error",error:{type:"not-found"}};
    }

    return {type:"error",error:{type:"unknown"}};
  }

  return {type:"success",lines:Wp(stdout)};
}const r=await VC.readFile(e,"utf8");return{type:"success",lines:Wp(r)}}async function QJ(e,t,n,r,o){
  const s=await re(e,["cat-file","-s",t],n,{signal:r,timeoutMs:o?Wu:void 0});if (!s.success) {
    return{type:"error",error:{type:OC(s)}};
  }const i=Number.parseInt(s.stdout,10);if (!Number.isNaN(i)&&i>on) {
    return{type:"error",error:{type:"too-large",limitBytes:on}};
  }const a=await re(e,["cat-file","-p",t],n,{maxOutputBytes:on,signal:r,timeoutMs:o?Wu:void 0,trim:false});

  if (a.outputLimitExceeded) {
    return {type:"error",error:{type:"too-large",limitBytes:on}};
  }

  if (a.success) {
    return {type:"success",lines:Wp(a.stdout)};
  }

  return {type:"error",error:{type:OC(a)}};
}async function vh(e,t,n,r){
  const o=await re(e,["rev-parse",t],n,{allowedNonZeroExitCodes:[128],signal:r});
  const s=o.success?o.stdout.trim():null;
  if (s&&!Oc(s)) {
    throw new Error(`Unexpected ${t} SHA: ${s}`);
  }return s?s:null
}async function _w(e,t,n){const r=await vh(e,"HEAD",t,n);if (r&&!Oc(r)) {
  throw new Error(`Unexpected HEAD SHA: ${r}`);
}return r?r:null}async function pw(e,t,n,r){const o=await vh(e,`${t}^{tree}`,n,r);if (o&&!Oc(o)) {
  throw new Error(`Unexpected ${t} SHA: ${o}`);
}return o?o:null}const CC=1024;async function JJ({gitRoot,targetRoot,branchName,headCommitSha,treeSha,targetCurrentBranch,hostConfig,signal}){
  const c=AL("syncedBranch.overwrite");
  const l=targetRoot?await _w(targetRoot,hostConfig,signal):null;
  const f=await pw(gitRoot,headCommitSha,hostConfig,signal);
  if (!f) {
    return{status:"command-error"};
  }const u=treeSha&&treeSha!==f&&(!targetRoot||!(!targetCurrentBranch||targetCurrentBranch===branchName));let _;if (u) {const T=await qp(gitRoot,treeSha,hostConfig,{parentSha:headCommitSha,signal:signal});if (!T.success) {
    return{status:"command-error",execOutput:er({command:"git commit-tree",stdout:"",stderr:T.error.stderr,fallbackOutput:T.error.stderr||T.error.stdout||"Failed to create synthetic commit"})};
  }_=T.commitSha} else {
    _=headCommitSha;
  }
  const [p,E]=await Promise.all([gitRoot&&_!==headCommitSha?await re(gitRoot,["reset","--hard",_],hostConfig,{signal:signal}):null,targetRoot?await re(targetRoot,["update-ref",targetCurrentBranch?`refs/heads/${targetCurrentBranch}`:"HEAD",_],hostConfig,{signal:signal}):gitRoot?await re(gitRoot,["branch","-f",branchName,_],hostConfig,{signal:signal}):null]);
  const h=E&&!E.success?E:p?.success===false?p:null;
  if(h){const T=h.stderr||h.stdout||"Failed to reset branch";return{status:"command-error",execOutput:er({command:h.command,stdout:h.stdout,stderr:h.stderr,fallbackOutput:T})}}if(targetRoot){
  const T=await re(targetRoot,["reset","--mixed","HEAD"],hostConfig,{signal:signal});if(!T.success){const g=T.stderr||T.stdout||"Failed to reset index";return{status:"command-error",execOutput:er({command:T.command,stdout:T.stdout,stderr:T.stderr,fallbackOutput:g})}}const m=treeSha?treeSha:f;

  if (l) {
    (await t8({gitRoot:targetRoot,baseRef:l,treeToRestore:m,hostConfig:hostConfig,signal:signal,logger:c}));
  }

  const A=await re(targetRoot,["restore","--source",m,"--worktree","--","."],hostConfig,{signal:signal});if(!A.success){const g=A.stderr||A.stdout||"Failed to restore working tree";return{status:"command-error",execOutput:er({command:A.command,stdout:A.stdout,stderr:A.stderr,fallbackOutput:g})}}
}
  c.info("Synced branch applied to branch checkout");
  return {status:"success"};
}async function e8(e,t,n,r){let o=null;for(const s of n8(t)){const i=await re(e,["clean","-fd","--",...s],n,{signal:r});if(!i.success){o=i;break}}return o}async function t8({gitRoot,baseRef,treeToRestore,hostConfig,signal,logger}){
  const i=await re(gitRoot,["diff","--name-only","--diff-filter=D","--no-renames",baseRef,treeToRestore],hostConfig,{allowedNonZeroExitCodes:[1],signal:signal});if(!i.success){logger.warning("Failed to compute deleted paths before cleaning untracked files.");return}const a=i.stdout.length>0?i.stdout.split(`
  `).map(l => l.trim()).filter(l => l.length>0):[];if (a.length===0) {
    return;
  }

  if ((await e8(gitRoot,a,hostConfig,signal))) {
    logger.warning("Failed to clean untracked files for deleted paths before restore.");
  }
}function n8(e){const t=[];for (let n=0; n<e.length; n+=CC) {
  t.push(e.slice(n,n+CC));
}return t}async function Ew(e,t,n,r){return (await cw(e,n,r)).find(s => s.headRef.type!=="branch"?false:s.headRef.string===t)?.root??null;}const r8=Pt("git");async function o8(e,t,n,r){
  const o=await t.getWorktreeRepository(e,n);
  const s=o?.root;
  if (!s) {
    return{gitRoot:null,branch:null,base:null,unsyncedChanges:{type:"error",error:{type:"unknown"}},branchChanges:{type:"error",error:{type:"unknown"}}};
  }
  const i=o.getUntrackedPaths();
  const a=await Hl(e,n,r);
  if (!a) {
    return{gitRoot:s,branch:null,base:null,unsyncedChanges:{type:"error",error:{type:"unknown"}},branchChanges:{type:"error",error:{type:"unknown"}}};
  }try{
    const c=pc(a.branch);
    const [l,f,d,u]=await Promise.all([Ih(s,a.lastSyncedTreeRef,n,r),Zr(s,{hostConfig:n,signal:r,untrackedPathsPromise:i}),pw(s,a.branch,n,r),Ew(s,c,n,r)]);
    const _=u==null?null:await t.getWorktreeRepository(u,n);
    let p=null;if (u==null) {
      p=null;
    } else if (u===s) {
      p=await Zr(u,{hostConfig:n,signal:r,untrackedPathsPromise:i});
    } else if (_) {
      p=await Zr(u,{hostConfig:n,signal:r,untrackedPathsPromise:_.getUntrackedPaths()});
    } else {
      throw new Error("Unable to resolve repository for synced branch worktree.");
    }
    const E=p??d;
    const [h,T]=await Promise.all([sn(s,[l,f],n,{trim:false,allowedNonZeroExitCodes:[0,1],signal:r}),E?sn(s,[l,E],n,{trim:false,allowedNonZeroExitCodes:[0,1],signal:r}):Promise.resolve(null)]);
    const m=T?T.outputLimitExceeded||!T.success?{type:"error",error:rr(T)}:{type:"success",unifiedDiff:T.stdout}:{type:"error",error:{type:"unknown"}};
    return h.outputLimitExceeded||!h.success?{gitRoot:s,branch:c,base:a.lastSyncedTreeRef,unsyncedChanges:{type:"error",error:rr(h)},branchChanges:m}:{gitRoot:s,branch:c,base:a.lastSyncedTreeRef,unsyncedChanges:{type:"success",unifiedDiff:h.stdout},branchChanges:m}
  }catch(c){
    r8().warning(`failed to collect synced branch changes: ${String(c)}`);
    return {gitRoot:s,branch:pc(a.branch),base:a.lastSyncedTreeRef,unsyncedChanges:{type:"error",error:{type:"unknown"}},branchChanges:{type:"error",error:{type:"unknown"}}};
  }
}async function s8(e,t,n){const r=await re(e,["ls-files","-u"],t,{signal:n});return r.success?r.stdout.trim().length>0:false;}async function i8(e,t,n){const r=await Hl(e,t,n);if (!r) {
  return {branch:null,base:null,hasConflicts:false};
}const o=await s8(e,t,n);return{branch:pc(r.branch),base:r.lastSyncedTreeRef,hasConflicts:o}}const hw={filesChanged:0,linesAdded:0,linesRemoved:0};async function IC(e,t,n,r,o){const s=await sn(e,["--numstat",t,n],r,{allowedNonZeroExitCodes:[0,1],signal:o});return!s.success||!s.stdout?hw:a8(s.stdout)}function a8(e){
  const t=e.trim();if (!t) {
    return hw;
  }
  let n=0;
  let r=0;
  let o=0;
  for(const s of t.split(/\r?\n/)){
    const i=s.trim();if (!i) {
      continue;
    }const[a,c,...l]=i.split("	");

    if (a && c && l.length !== 0) {
      n+=1;
      r+=PC(a);
      o+=PC(c);
    }
  }return{filesChanged:n,linesAdded:r,linesRemoved:o}
}function PC(e){if (e==="-") {
  return 0;
}const t=Number.parseInt(e,10);return Number.isFinite(t)?t:0}async function c8(e,t,n,r){const o=await vh(e,t,n,r);if (o&&!Oc(o)) {
  throw new Error(`Unexpected ${t} SHA: ${o}`);
}return o?o:null}const u8=Pt("git");async function l8(e,t,n,r){
  const o=await t.getWorktreeRepository(e,n);if (!o) {
    throw new Error("Unable to resolve git root for synced branch status.");
  }
  const s=o.root;
  const i=o.getUntrackedPaths();
  const a=await Hl(e,n,r);
  if (!a) {
    throw new Error("No synced branch config found for the current worktree.");
  }try{
    const c=pc(a.branch);
    const l=Zr(s,{hostConfig:n,signal:r,untrackedPathsPromise:i});
    const [f,d,u,_,p]=await Promise.all([Ew(s,c,n,r),_w(s,n,r),l,c8(s,a.branch,n,r),Yo(s,n,r)]);
    if (p) {
      throw new Error("Worktree has a branch checked out.");
    }if (d) {if (!_) {
      throw new Error("Unable to resolve synced branch head SHA.")
    }} else {
      throw new Error("Unable to resolve worktree head state.");
    }const E=f==null?null:await t.getWorktreeRepository(f,n);let h;if (!f) {
      h=Promise.resolve(null);
    } else if (f===s) {
      h=Zr(f,{hostConfig:n,signal:r,untrackedPathsPromise:i});
    } else if (E) {
      h=Zr(f,{hostConfig:n,signal:r,untrackedPathsPromise:E.getUntrackedPaths()});
    } else {
      throw new Error("Unable to resolve repository for synced branch worktree.");
    }
    const T=ZL(s,_,d,n,r);
    const [m,A]=await Promise.all([T,h]);

    const g=I => ({
      leftRef:I,
      rightRef:I,
      filesChanged:0,
      linesAdded:0,
      linesRemoved:0
    });

    const R=u?{...(await IC(s,d,u,n,r)),leftRef:d,rightRef:u}:g(d);
    const O=f&&A?{...(await IC(f,_,A,n,r)),leftRef:_,rightRef:A}:g(_);
    return {branch:a.branch,worktreeSnapshot:{root:s,headCommitSha:d,workingTreeRef:u??void 0},branchSnapshot:f?{checkedOut:true,snapshot:{root:f,headCommitSha:_,workingTreeRef:A??void 0}}:{checkedOut:false,headCommitSha:_},localCommitsAhead:m?.leftAhead??0,worktreeCommitsAhead:m?.rightAhead??0,localUncommittedDiffStats:O,worktreeUncommittedDiffStats:R};
  }catch(c){
    u8().warning(`failed to collect synced branch status: ${String(c)}`);
    throw c;
  }
}class d8{constructor(t){this.emit=t}}async function f8(e,t){return bh(e,"HEAD",t)}class _8{constructor(t){
  this.options=t;
  this.emitHeadChangedDebounced=Z_(()=>{const n={type:"git-repo-changed",changeType:"head",commonDir:this.options.commonDir,root:this.options.root};this.options.emit({type:"worker-event",event:n})},500);
  this.emitRemoteRefsChangedDebounced=Z_(()=>{const n={type:"git-repo-changed",changeType:"remote-refs",commonDir:this.options.commonDir,root:this.options.root};this.options.emit({type:"worker-event",event:n})},500);
  this.emitSyncedBranchChangedDebounced=Z_(()=>{const n={type:"git-repo-changed",changeType:"synced-branch",commonDir:this.options.commonDir,root:this.options.root};this.options.emit({type:"worker-event",event:n})},500);
}logger=xl("git-repo-watcher");watchers=[];emitHeadChangedDebounced;emitRemoteRefsChangedDebounced;emitSyncedBranchChangedDebounced;async start(){
  this.logger.info("Starting git repo watcher");
  const t=await f8(this.options.root,this.options.hostConfig);
  const n=await iJ(this.options.root,this.options.hostConfig);
  await this.tryWatch(t,this.emitHeadChangedDebounced);
  await this.tryWatch(ce.join(this.options.commonDir,"FETCH_HEAD"),this.emitRemoteRefsChangedDebounced);
  await this.tryWatch(ce.join(this.options.commonDir,"packed-refs"),this.emitRemoteRefsChangedDebounced);
  await this.tryWatch(n,this.emitSyncedBranchChangedDebounced);
}dispose(){
  this.watchers.forEach(t=>{t.close()});
  this.watchers.length=0;
}async tryWatch(t,n){if (t) {
  try{
    const r=ce.dirname(t);
    const o=ce.basename(t);
    let s=await MC(t);const i=de.watch(r,(a,c)=>{
    if (!c || c === o) {
      MC(t).then(l=>{
        if (a === "rename" || l !== s) {
          s=l;
          n();
        }
      });
    }
  });this.watchers.push(i)
  }catch(r){this.logger.warning(`Failed to watch git path (${ce.basename(t)}, ${st(r)})`)}
}}}async function MC(e){try{return(await de.promises.stat(e)).mtimeMs}catch{return null}}const p8=Pt("git");class E8 extends d8{constructor(t,n){
  super(t);
  this.gitManager=n;
}watchesByKey=new Map;inFlightRequests=new Map;canceledRequests=new Set;uncancelableRequestIds=new Set;worktreeDeletePromises=new Map;async handleRequest(t){
  const n=new AbortController;
  const r=t.params.hostConfig??null;
  const o=t.method!=="delete-worktree"&&t.method!=="invalidate-stable-metadata"&&t.method!=="git-init-repo";
  if (o) {
    this.inFlightRequests.set(t.id,n);

    if (this.canceledRequests.has(t.id)) {
      this.canceledRequests.delete(t.id);
      n.abort();
      this.inFlightRequests.delete(t.id);
      return
    }
  } else {
    this.uncancelableRequestIds.add(t.id);
    this.canceledRequests.delete(t.id);
  }let s;try{switch(t.method){case"stable-metadata":{s=await this.handleResolveStableMetadata(t.params,{hostConfig:r});break}case"current-branch":{const a=await Yo(t.params.root,r,n.signal);s=Oe({branch:a});break}case"upstream-branch":{const a=await this.handleUpstreamBranch(t.params,{hostConfig:r,signal:n.signal});s=Oe(a);break}case"branch-ahead-count":{const a=await this.handleBranchAheadCount(t.params,{hostConfig:r,signal:n.signal});s=Oe(a);break}case"default-branch":{s=await this.handleDefaultBranch(t.params,{hostConfig:r,signal:n.signal});break}case"base-branch":{s=await this.handleBaseBranch(t.params,{hostConfig:r,signal:n.signal});break}case"recent-branches":{s=await this.handleRecentBranches(t.params,{hostConfig:r,signal:n.signal});break}case"branch-changes":{const a=await xJ(this.gitManager,t.params.cwd,r,n.signal);s=Oe(a);break}case"status-summary":{const a=await dJ(String(t.params.cwd),r,n.signal);s=Oe(a);break}case"staged-and-unstaged-changes":{const a=await _J(String(t.params.cwd),this.gitManager,r,n.signal,t.params.paths);s=Oe(a);break}case"untracked-changes":{const a=await pJ(String(t.params.cwd),this.gitManager,r,n.signal,t.params.paths);s=Oe(a);break}case"synced-branch":{const a=await i8(t.params.cwd,r,n.signal);s=Oe(a);break}case"synced-branch-changes":{const a=await o8(t.params.cwd,this.gitManager,r);s=Oe(a);break}case"synced-branch-state":{const a=await l8(t.params.cwd,this.gitManager,r,n.signal);s=Oe(a);break}case"overwrite-repo":{const a=await JJ({...t.params,hostConfig:r,signal:n.signal});s=Oe(a);break}case"invalidate-stable-metadata":{
    this.gitManager.invalidateStableMetadata();
    s=Oe({success:true});
    break
  }case"git-init-repo":{s=Oe(await hJ(t.params,this.gitManager,r));break}case"tracked-uncommitted-changes":{const a=await qJ(t.params.cwd,r,n.signal);s=Oe(a);break}case"submodule-paths":{const a=await jJ(t.params.root,r,n.signal);s=Oe({paths:a});break}case"cat-file":{const a=await zJ(this.gitManager,{cwd:t.params.cwd,oid:t.params.oid,path:t.params.path,fallbackToDisk:t.params.fallbackToDisk},r,n.signal);s=Oe(a);break}case"index-info":{const a=await YJ(t.params.cwd,r,n.signal);s=Oe(a);break}case"config-value":{
    const a=await this.gitManager.getWorktreeRepository(t.params.root,r);
    const c=a?await a.getConfigValueForScope(t.params.key,t.params.scope,n.signal):null;
    s=Oe({value:c});break
  }case"set-config-value":{
    const a=await this.gitManager.getWorktreeRepository(t.params.root,r);
    const c=a?await a.setConfigValueForScope(t.params.key,t.params.value,t.params.scope,n.signal):false;
    s=Oe({success:c});break
  }case"create-worktree":{s=await this.handleCreateWorktree(t.params,{hostConfig:r,signal:n.signal});break}case"codex-worktree":{try{const a=await HJ();s=Oe({worktrees:a})}catch(a){const c=a instanceof Error?a.message:String(a);s=Va(c)}break}case"list-worktrees":{const a=await cw(t.params.cwd,r,n.signal);s=Oe({worktrees:a});break}case"worktree-snapshot-ref":{const a=await IJ(this.gitManager,t.params.candidateRoots,t.params.worktreePath,r,n.signal);s=Oe(a);break}case"restore-worktree":{const a=await PJ(t.params.repoRoot,t.params.worktreePath,r,n.signal);s=Oe({success:a});break}case"delete-worktree":{const a=await this.scheduleWorktreeDelete(t.params);s=Oe({success:a});break}case"apply-changes":{const a=await UJ({...t.params,gitManager:this.gitManager,hostConfig:r,signal:n.signal});s=Oe(a);break}case"commit":{
    const a=await this.gitManager.getWorktreeRepository(t.params.cwd,r);a?.getUntrackedPaths.clear();
    const c=a?.root;
    const l=c??String(t.params.cwd);
    if(t.params.includeUnstaged){const _=c?await lw({gitRoot:c,env:process.env,signal:n.signal,hostConfig:r,untrackedPathsPromise:a.getUntrackedPaths()}):await re(l,["add","-A"],r,{signal:n.signal});if(!_.success){const p=_.stderr||_.stdout||"Failed to stage changes";s=Oe({status:"error",error:p,execOutput:er({command:_.command,stdout:_.stdout,stderr:_.stderr,fallbackOutput:p})});break}}const f=await re(l,["commit","-m",t.params.message],r,{signal:n.signal});if(!f.success){const _=f.stderr||f.stdout||"Failed to commit changes";s=Oe({status:"error",error:_,execOutput:er({command:f.command,stdout:f.stdout,stderr:f.stderr,fallbackOutput:_})});break}
    const d=await re(l,["rev-parse","HEAD"],r,{signal:n.signal});
    const u=d.success?d.stdout:null;
    s=Oe({status:"success",commitSha:u});break
  }}}catch(a){s=Va(a)}finally{
  if(T8(t.method)){const a=h8(t);this.gitManager.invalidateUntrackedPathsCache(a,r)}

  if (o) {
    this.inFlightRequests.delete(t.id);
  } else {
    this.uncancelableRequestIds.delete(t.id);
  }

  this.canceledRequests.delete(t.id);
}if (o&&n.signal.aborted) {
    return;
  }const i={id:t.id,method:t.method,result:s};this.emit({type:"worker-response",response:i})
}async deleteWorktreeWithLimit(t){
  try{await CJ(this.gitManager,t.worktree,t.hostConfig,t.reason)}catch(n){p8().warning(`[worktree-snapshot] failed to snapshot worktree (${st(n)})`)}
  await ju(t.worktree,t.hostConfig,t.force??false);
  return true;
}async scheduleWorktreeDelete(t){
  const r=`${t.hostConfig?.id??"local"}|${t.worktree}`;
  const o=this.worktreeDeletePromises.get(r);
  if (o) {
    return o;
  }const s=this.deleteWorktreeWithLimit(t);this.worktreeDeletePromises.set(r,s);try{return await s}finally{this.worktreeDeletePromises.delete(r)}
}async handleResolveStableMetadata(t,{hostConfig}){
  const r=await this.gitManager.getStableMetadata(t.cwd,hostConfig);if (!r) {
    return Va("Not a git repository");
  }const o={commonDir:r.commonDir,root:r.root};
  await this.ensureWatching(o,hostConfig);
  return Oe(o);
}async handleUpstreamBranch(t,{hostConfig,signal}){
  const o=await Yo(t.root,hostConfig,signal);
  const s=await re(t.root,["rev-parse","--abbrev-ref","--symbolic-full-name","@{u}"],hostConfig,{signal:signal,allowedNonZeroExitCodes:[128,1]});
  const i=s.success&&s.stdout?s.stdout:null;
  return i?{branch:o,upstream:{branch:i}}:{branch:o,upstream:null}
}async handleBranchAheadCount(t,{hostConfig,signal}){
  const o=await Ja(t.root,hostConfig,signal);
  const s=o?.branch??null;
  let i=o?.remote??null;

  if (!i) {
    (i = (await nw(t.root,hostConfig,signal))[0]??null);
  }

  const a=await re(t.root,["rev-parse","--abbrev-ref","--symbolic-full-name","@{u}"],hostConfig,{signal:signal,allowedNonZeroExitCodes:[128,1]});
  const c=a.success&&a.stdout?a.stdout:null;

  const l=async()=>{if (!c) {
    return 0;
  }const h=await re(t.root,["rev-list","--count",`${c}..HEAD`],hostConfig,{allowedNonZeroExitCodes:[128,1],signal:signal});if(h.success&&h.stdout){const T=Number.parseInt(h.stdout,10);return Number.isNaN(T)?0:T}return 0};

  const f=async()=>{if (!i) {
    return null;
  }const h=await re(t.root,["rev-list","--count","HEAD","--not",`--remotes=${i}`],hostConfig,{allowedNonZeroExitCodes:[128,1],signal:signal});if(h.success&&h.stdout){const T=Number.parseInt(h.stdout,10);return Number.isNaN(T)?null:T}return null};

  const d=async()=>{
    if (!s) {
      return 0;
    }
    const h=s.includes("/")?s:i?`${i}/${s}`:s;
    const T=await iw(t.root,h,hostConfig,signal);
    if(T){const m=await re(t.root,["rev-list","--count",`${T}..HEAD`],hostConfig,{allowedNonZeroExitCodes:[128,1],signal:signal});if(m.success&&m.stdout){const A=Number.parseInt(m.stdout,10);return Number.isNaN(A)?0:A}}return 0
  };

  const [u,_,p]=await Promise.all([l(),f(),d()]);
  let E=p;

  if (_!=null) {
    E=_;
  } else if (c!=null) {
    (E = u);
  }

  return {commitsAhead:E};
}async handleDefaultBranch(t,{hostConfig,signal}){
  let s=(await Ja(t.root,hostConfig,signal))?.branch??null;

  if (!s) {
    (s = (await yC(t.root,10,hostConfig,signal)).find(a => a==="main"||a==="master")??null);
  }

  return Oe({branch:s});
}async handleBaseBranch(t,{hostConfig,signal}){const o=await Ja(t.root,hostConfig,signal);return Oe({local:o?.branch??null,remote:o?.remote??null})}async handleRecentBranches(t,{hostConfig,signal}){
  const o=Math.max(1,Math.min(t.limit??10,100));
  const s=await yC(t.root,o,hostConfig,signal);
  return Oe({branches:s})
}async handleCreateWorktree(t,{hostConfig,signal}){
  const o=this.emit.bind(this);
  const s=t.streamId;
  if (!(await this.gitManager.getRepoRepository(t.cwd,hostConfig))) {
    return Va("Not a git repository (not repo repository)");
  }const a=await cJ({gitManager:this.gitManager,workspaceRoot:t.cwd,startingState:t.startingState,localEnvironmentConfigPath:t.localEnvironmentConfigPath,hostConfig:hostConfig,signal:signal,onLog:(c,l)=>{
  if (!signal.aborted) {
    o({type:"worker-event",event:{type:"create-worktree-stream",streamId:s,stream:c,data:l}});
  }
}});return a.success?Oe({worktreeGitRoot:a.worktreeGitRoot,worktreeWorkspaceRoot:a.worktreeWorkspaceRoot}):Va(a.error.message)
}getWatchKey(t,n){return`${n?.id??"local"}|${t}`}async ensureWatching(t,n){
  const r=this.getWatchKey(t.root,n);if (this.watchesByKey.get(r)) {
    return;
  }const s=new _8({commonDir:t.commonDir,root:t.root,hostConfig:n,emit:this.emit});
  this.watchesByKey.set(r,s);
  await s.start();
}handleCancel(t){
  if (this.uncancelableRequestIds.has(t)) {
    return;
  }const n=this.inFlightRequests.get(t);if(!n){this.canceledRequests.add(t);return}
  this.inFlightRequests.delete(t);
  n.abort();
}}function h8(e){return typeof e.params.cwd=="string"?e.params.cwd:typeof e.params.root=="string"?e.params.root:null}function T8(e){switch(e){case"overwrite-repo":case"git-init-repo":case"create-worktree":case"restore-worktree":case"delete-worktree":case"apply-changes":case "commit":
  {
    return true;
  }case"stable-metadata":case"current-branch":case"upstream-branch":case"branch-ahead-count":case"default-branch":case"base-branch":case"recent-branches":case"branch-changes":case"status-summary":case"staged-and-unstaged-changes":case"untracked-changes":case"tracked-uncommitted-changes":case"submodule-paths":case"cat-file":case"synced-branch":case"synced-branch-changes":case"synced-branch-state":case"index-info":case"config-value":case"set-config-value":case"list-worktrees":case"codex-worktree":case"worktree-snapshot-ref":case "invalidate-stable-metadata":
  {
    return false;
  }}}function S8(e,t,n){switch(e){case "git":
  {
    return new E8(n,t)
  }}}function m8(){
  const e=process.platform;
  const t=process.env;
  const n=jo.homedir();
  if (e==="darwin") {
    return ce.join(n,"Library","Logs","com.openai.codex");
  }if(e==="win32"){const r=t.LOCALAPPDATA??ce.join(n,"AppData","Local");return ce.join(r,"Codex","Logs")}if(e==="linux"){const r=t.XDG_STATE_HOME??ce.join(n,".local","state");return ce.join(r,"codex","logs")}return ce.join(n,".codex","logs")
}
const vC=10*1024*1024;
const LC=5;
const wC=10000/* 1e4 */;
const A8=1024*1024;
const g8=15;
function ec(e){return e.toString().padStart(2,"0")}function DC(e,t){
  const n=t.getUTCFullYear().toString();
  const r=ec(t.getUTCMonth()+1);
  const o=ec(t.getUTCDate());
  return ce.join(e,n,r,o)
}function tp(e,t,n,r){return e>0?e:(n(new Error(`[file-logger] invalid ${r}`),{[r]:e}),t)}function UC(e,t,n,r,o){return`codex-desktop-${e}-${t}-t${n}-i${r}-${ec(o.getUTCHours())}${ec(o.getUTCMinutes())}${ec(o.getUTCSeconds())}`}let kC=0;function R8(){
  kC+=1;
  return kC;
}function N8(e,t,n,r){try{
  const o=new Date(Date.UTC(t.getUTCFullYear(),t.getUTCMonth(),t.getUTCDate()));
  const s=new Date(o);
  s.setUTCDate(s.getUTCDate()-(n-1));for(const i of de.readdirSync(e)){
  if (!/^\d{4}$/.test(i)) {
      continue;
    }const a=Number(i);if (!Number.isFinite(a)) {
      continue;
    }const c=ce.join(e,i);for(const l of de.readdirSync(c)){
    if (!/^\d{2}$/.test(l)) {
        continue;
      }const f=Number(l);if (!Number.isFinite(f)||f<1||f>12) {
        continue;
      }const d=ce.join(c,l);for(const u of de.readdirSync(d)){
      if (!/^\d{2}$/.test(u)) {
          continue;
        }const _=Number(u);if (!Number.isFinite(_)||_<1||_>31) {
          continue;
        }

      if (new Date(Date.UTC(a,f-1,_))<s) {
        de.rmSync(ce.join(d,u),{recursive:true,force:true});
      }
    }

    if (de.readdirSync(d).length===0) {
      de.rmSync(d,{recursive:true,force:true});
    }
  }

  if (de.readdirSync(c).length===0) {
    de.rmSync(c,{recursive:true,force:true});
  }
}
}catch(o){r(new Error("[file-logger] failed to prune old logs"),{rootDir:e,retentionDays:n,error:o instanceof Error?o.message:String(o)})}}function y8(e,t={}){
  const n=(A, g) => e.nonFatalReporter.reportNonFatal(A,{kind:"file-based-logger",extra:g});

  const r=e.rootDir??m8();
  const o=t.processId??process.pid;
  const s=t.threadId??Ku.threadId??0;
  const i=t.instanceId??R8();
  const a=e.appSessionId;

  const c=t.now??(() => new Date);

  const l=e.maxSegmentBytes??vC;
  const f=e.maxSegments??LC;
  const d=e.pendingLineLimit??wC;
  const u=e.highWaterMarkBytes??A8;
  const _=g8;

  const p=t.createStream??((A, g) => de.createWriteStream(A,{flags:"w",highWaterMark:g}));

  const E=tp(f,LC,n,"maxSegments");
  const h=tp(l,vC,n,"maxSegmentBytes");
  const T=tp(d,wC,n,"pendingLineLimit");
  const m={logLine:()=>{}};
  try{
    const A=c();let g=DC(r,A);
    de.mkdirSync(g,{recursive:true});
    N8(r,A,_,n);
    let R=UC(a,o,s,i,A);const O=ne => ce.join(g,`${R}-${ne}.log`);let I=false;

    const b=ne=>{
      I=true;
      n(new Error("[file-logger] stream error"),{error:ne instanceof Error?ne.message:String(ne),rootDir:r,appSessionId:a,processId:o,threadId:s,instanceId:i});
    };

    const L=ne => {
      ne.on("error",P=>{b(P)});
      return ne;
    };

    let U=0;
    let q=0;
    let H=L(p(O(U),u));
    let $=[];
    let B=0;
    let F=false;
    let D=0;

    const k=()=>{
      const ne=c();
      const P=DC(r,ne);

      if (P!==g) {
        g=P;
        de.mkdirSync(g,{recursive:true});
        R=UC(a,o,s,i,ne);
        H.end();
        U=0;
        q=0;
        D=0;
        H=L(p(O(U),u));
      }
    };

    const Y=()=>{
      H.end();
      U=(U+1)%E;
      q=0;
      H=L(p(O(U),u));
    };

    const oe=()=>{
      if (D===0) {
        return;
      }const ne=`[file-logger] dropped ${D} lines due to backpressure
      `;
      $.push({text:ne,bytes:Buffer.byteLength(ne)});
      D=0;
    };

    const ae=()=>{if(I){
      $=[];
      B=0;
      D=0;
      return
    }if (F) {
      return;
    }F=true;let ne=false;try{
      while (!(B>=$.length&&(oe(),B>=$.length))) {
        const P=$[B];

        if (q+P.bytes>h) {
          Y();
        }

        const M=H.write(P.text);
        q+=P.bytes;
        B+=1;

        if (!M) {
          ne=true;

          H.once("drain",()=>{
            F=false;
            ae();
          });

          return
        }
      }

      $=[];
      B=0;
    }catch(P){
      n(new Error("[file-logger] write failed"),{error:P instanceof Error?P.message:String(P),rootDir:r,appSessionId:a,processId:o,threadId:s,instanceId:i,maxSegments:E,maxSegmentBytes:h,pendingLineLimit:T});
      $=[];
      B=0;
    }finally{
      if (F&&!ne) {
        (F = false);
      }
    }};

    return {logLine:ne=>{if (!I) {
      try{
        if (!F&&$.length===0) {
          k();
        }

        const P=`${ne}
          `;if($.length-B>=T){D+=1;return}
        $.push({text:P,bytes:Buffer.byteLength(P)});
        ae();
      }catch(P){n(new Error("[file-logger] logLine threw"),{error:P instanceof Error?P.message:String(P),rootDir:r,appSessionId:a,processId:o,threadId:s,instanceId:i})}
    }}};
  }catch{
    n(new Error("[file-logger] failed to initialize"),{rootDir:r,appSessionId:a,processId:o,threadId:s,instanceId:i});
    return m;
  }
}const O8={colors:false,depth:8,maxArrayLength:100};function b8(...e){return qo.formatWithOptions(O8,...e)}function C8(e,t){switch(e){case "error":
  {
    console.error(t);break;
  }case "warning":
  {
    console.warn(t);break;
  }case "info":
  {
    console.info(t);break;
  }case "debug":
  {
    console.debug(t);break;
  }case "trace":
  {
    console.log(t);break
  }}}function I8(e,t,n,r){
  const o=y8({appSessionId:n,nonFatalReporter:e});
  const s=c=>{const l=new Date().toISOString();o.logLine(`${l} ${c}`)};

  const i=c => (l,...f)=>{
    if (!vJ(c,r)) {
      return;
    }const d=b8(l,...f);
    C8(c,d);
    s(`${c} ${d}`);
    t.log(c,d);
  };

  const a={trace:i("trace"),debug:i("debug"),info:i("info"),warning:i("warning"),error:i("error")};
  oQ({trace:a.trace,debug:a.debug,info:a.info,warning:a.warning,error:a.error,log:(c,l,...f)=>{a[c](l,...f)},dispose:()=>{}});

  uQ(() => false);
}const P8="app:///";function M8(e,t){v8(e,t)}function v8(e,t){
  const n=F9(e.buildFlavor);
  const r=B9(e.appVersion);

  Rz({dsn:x9,environment:e.buildFlavor,release:r,dist:e.buildNumber??void 0,tracesSampleRate:n,integrations:o => [...o,xV({root:t,prefix:P8})]});

  z1("codex_app_session_id",e.codexAppSessionId);

  aQ({startSpan:(o, s) => Qo(o,s)});
}function L8(e,t,n){if(e==null){ug(null);return}ug({id:t??void 0,email:n??void 0,auth_method:e})}const{workerId,sentryInitOptions,sentryRewriteFramesRoot,maxLogLevel}=Ku.workerData;M8(sentryInitOptions,sentryRewriteFramesRoot);
const Tw=d6((e,t,n)=>{xe(e,{level:t==="fatal"?"fatal":"error",tags:n.tags,extra:n.extra})});
const Sw=new u6({source:"codex-desktop",env:sentryInitOptions.buildFlavor,codexAppSessionId:sentryInitOptions.codexAppSessionId,buildInfo:{version:sentryInitOptions.appVersion,buildNumber:sentryInitOptions.buildNumber},reportFailure:e=>{Tw.reportNonFatal("Datadog log sink failure",{kind:"datadog-log-sink-failure",tags:{failureType:e.type,reason:e.reason,workerId:workerId},extra:{failure:e}})}});
I8(Tw,Sw,sentryInitOptions.codexAppSessionId,maxLogLevel);const Lh=Ku.parentPort;if (!Lh) {
  throw new Error("worker-entry must be run in a worker thread");
}
const mw=new vQ;
const U8=new AJ(mw);
const GC=S8(workerId,U8,e=>{const t={...e,workerId:workerId};Lh.postMessage(t)});
Lh.on("message",e=>{if(e.type==="worker-sentry-user-update"){L8(e.authMethod,e.userId,e.email);const t=e.authMethod==null?null:{id:e.userId??void 0,email:e.email??void 0,authMethod:e.authMethod};Sw.setUserInfo(t);return}else if(e.type==="worker-app-event"){mw.emit(e.event.type,e.event.at);return}else if (e.workerId!==workerId) {
  return;
}switch(e.type){case"worker-request":{hh({op:"codex.worker.request",name:`${workerId}.${e.request.method}`},() => GC.handleRequest(e.request));return}case"worker-request-cancel":{GC.handleCancel(e.id);return}}});
//# sourceMappingURL=worker.js.map
